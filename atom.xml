<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fredo&#39;s Blog</title>
  
  
  <link href="http://fu-jw.com/atom.xml" rel="self"/>
  
  <link href="http://fu-jw.com/"/>
  <updated>2023-07-09T11:25:56.293Z</updated>
  <id>http://fu-jw.com/</id>
  
  <author>
    <name>Fredo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot单元测试</title>
    <link href="http://fu-jw.com/posts/6d37548c.html"/>
    <id>http://fu-jw.com/posts/6d37548c.html</id>
    <published>2023-07-02T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了SpringBoot单元测试的方法和使用。通过JUnit和MockMvc框架，可以精确控制测试粒度，提高单元测试的效率和质量。文章详述了Springboot单元测试相关注解，断言，嵌套测试以及参数化测试的使用方法，帮助开发者系统性的理解和掌握SpringBoot单元测试相关知识。</p></blockquote><h1 id="SpringBoot单元测试"><a href="#SpringBoot单元测试" class="headerlink" title="SpringBoot单元测试"></a>SpringBoot单元测试</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在平时的开发当中，一个项目往往包含了大量的方法，可能有成千上万个。如何去保证这些方法产生的结果是我们想要的呢？</p><p>传统解决方案：Postman 发报文，System.out打印debug日志，或者眼睛看返回报文</p><ol><li>眼睛看结果是否正确，瞅瞎不说，也太不智能.我们是高智商程序员,能让代码解决的事情,绝不能靠人工去解决. </li><li>postman 只能对controller进行测试。controller要正确，前提是service，dao都正确。发现问题太晚，解决成本高。</li><li>对于一些交易系统，由于交易主键的存在，每次都要更改参数后，再进行测试，效率太低。</li><li>无法对内部的函数功能做测试</li><li>postman的测试案例与项目工程不再一起，这些案例只能自己一个人用，无法团队共享</li></ol><p>这时，就轮到单元测试闪亮出场了</p><ul><li>测试代码和工程代码在同一工程文件中，便于维护和传承。 </li><li>使用断言自动检测结果 </li><li>测试粒度小，可以小到每个函数 </li><li>测试模块间相互依赖小。开发完一个模块，就可以测试一个模块。妈妈再也不用担心我犯大错了。</li></ul><h2 id="SpringBoot单元测试-1"><a href="#SpringBoot单元测试-1" class="headerlink" title="SpringBoot单元测试"></a>SpringBoot单元测试</h2><p>业界单元测试一般采用基于<strong>JUnit</strong>和<strong>MockMvc</strong>框架进行</p><ul><li><strong>JUnit</strong>: 是通用测试框架,主要进行Dao层和Service层测试</li><li><strong>MockMvc</strong>: 主要进行Controller层测试</li></ul><h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><p><strong>JUnit5</strong>的注解与<strong>JUnit4</strong>的注解有所变化,详见<a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">官方文档</a></p><ul><li><code>@Test</code>:表示方法是测试方法。但是与<strong>JUnit4</strong>的<code>@Test</code>不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li><li><code>@ParameterizedTest</code>: 表示方法是参数化测试</li><li><code>@RepeatedTest</code>: 表示方法可重复执行</li><li><code>@DisplayName</code>: 为测试类或者测试方法设置展示名称</li><li><code>@BeforeEach</code>: 表示在每个单元测试之前执行</li><li><code>@AfterEach</code>: 表示在每个单元测试之后执行</li><li><code>@BeforeAll</code>: 表示在所有单元测试之前执行</li><li><code>@AfterAll</code>: 表示在所有单元测试之后执行</li><li><code>@Tag</code>: 表示单元测试类别，类似于<strong>JUnit4</strong>中的<code>@Categories</code></li><li><code>@Disabled</code>: 表示测试类或测试方法不执行，类似于<strong>JUnit4</strong>中的<code>@Ignore</code></li><li><code>@Timeout</code>: 表示测试方法运行如果超过了指定时间将会返回错误</li><li><code>@ExtendWith</code>: 为测试类或测试方法提供扩展类引用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StandardTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span> <span class="comment">//表示在所有单元测试之前执行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始单元测试:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span> <span class="comment">//表示在每个单元测试之前执行</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试名称&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">succeedingTest</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">failingTest</span><span class="params">()</span> &#123;</span><br><span class="line">        fail(<span class="string">&quot;a failing test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Disabled(&quot;for demonstration purposes&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">skippedTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// not executed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abortedTest</span><span class="params">()</span> &#123;</span><br><span class="line">        assumeTrue(<span class="string">&quot;abc&quot;</span>.contains(<span class="string">&quot;Z&quot;</span>));</span><br><span class="line">        fail(<span class="string">&quot;test should have been aborted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tearDownAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;单元测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>assertEquals</td><td>判断两个对象或两个原始类型是否相等</td></tr><tr><td>assertNotEquals</td><td>判断两个对象或两个原始类型是否不相等</td></tr><tr><td>assertSame</td><td>判断两个对象引用是否指向同一个对象</td></tr><tr><td>assertNotSame</td><td>判断两个对象引用是否指向不同的对象</td></tr><tr><td>assertTrue</td><td>判断给定的布尔值是否为 true</td></tr><tr><td>assertFalse</td><td>判断给定的布尔值是否为 false</td></tr><tr><td>assertNull</td><td>判断给定的对象引用是否为 null</td></tr><tr><td>assertNotNull</td><td>判断给定的对象引用是否不为 null</td></tr><tr><td>assertArrayEquals</td><td>数组断言</td></tr><tr><td>assertAll</td><td>组合断言</td></tr><tr><td>assertThrows</td><td>异常断言</td></tr><tr><td>assertTimeout</td><td>超时断言</td></tr><tr><td>fail</td><td>快速失败</td></tr></tbody></table><h2 id="嵌套测试"><a href="#嵌套测试" class="headerlink" title="嵌套测试"></a>嵌套测试</h2><blockquote><p><strong>JUnit5</strong>可以通过Java中的内部类和<code>@Nested</code>注解实现嵌套测试, 从而可以更好的把相关的测试方法组织在一起.<br>在内部类中可以使用<code>@BeforeEach</code>和<code>@AfterEach</code>注解, 而且嵌套的层次没有限制</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;A stack&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestingAStackDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">isInstantiatedWithNew</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;when new&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WhenNew</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">createNewStack</span><span class="params">()</span> &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPeeked</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::peek);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nested</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;after pushing an element&quot;)</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AfterPushing</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">anElement</span> <span class="operator">=</span> <span class="string">&quot;an element&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@BeforeEach</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">pushAnElement</span><span class="params">()</span> &#123;</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;it is no longer empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">isNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when popped and is empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">returnElementWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">returnElementWhenPeeked</span><span class="params">()</span> &#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><p>参数化测试是<strong>JUnit5</strong>很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。</p><p>利用<code>@ValueSource</code>等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p><ul><li><code>@ValueSource</code>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型</li><li><code>@NullSource</code>: 表示为参数化测试提供一个null的入参</li><li><code>@EnumSource</code>: 表示为参数化测试提供一个枚举入参</li><li><code>@CsvFileSource</code>：表示读取指定CSV文件内容作为参数化测试入参</li><li><code>@MethodSource</code>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;参数化测试1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parameterizedTest1</span><span class="params">(String string)</span> &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    Assertions.assertTrue(StringUtils.isNotBlank(string));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource(&quot;method&quot;)</span>    <span class="comment">//指定方法名</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;方法来源参数&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWithExplicitLocalMethodSource</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    Assertions.assertNotNull(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了SpringBoot单元测试的方法和使用。通过JUnit和MockMvc框架，可以精确控制测试粒度，提高单元测试的效率和质量。文章详述了Springboot单元测试相关注解，断言，嵌套测试以及参数化测试的使用方法，</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot核心特性</title>
    <link href="http://fu-jw.com/posts/dcf57196.html"/>
    <id>http://fu-jw.com/posts/dcf57196.html</id>
    <published>2023-07-02T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了SpringBoot的核心特性，包括SpringApplication的使用，如何通过配置文件和代码进行自定义设置，以及启动失败时的处理方式。文中还详述了如何实现配置文件的隔离和外置，解释了属性占位符的用途，以及配置的优先级顺序。最后，介绍了日志的使用和JUnit5单元测试。</p></blockquote><h1 id="SpringBoot核心特性"><a href="#SpringBoot核心特性" class="headerlink" title="SpringBoot核心特性"></a>SpringBoot核心特性</h1><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html">官方文档:</a></p><blockquote><p>Spring Application: SpringApplication<br>External Configuration: External Configuration<br>Profiles: Profiles<br>Logging: Logging</p></blockquote><h2 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h2><p><code>SpringApplication</code>简化了Spring程序的启动过程.<br>大多数情况下, 可以委托给静态<code>SpringApplication.run</code>方法, 如以下示例所示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动日志:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::                (v3.1.0)</span><br><span class="line"></span><br><span class="line">2023-07-05T14:07:10.668+08:00  INFO 9584 --- [           main] com.fredo.Main                           : Starting Main using Java 17.0.2 with PID 9584 (D:\Develop\Projects\ideaProject\spring-tutorial\spring-boot\demo05-features\target\classes started by Administrator in D:\Develop\Projects\ideaProject\spring-tutorial)</span><br><span class="line">2023-07-05T14:07:10.673+08:00  INFO 9584 --- [           main] com.fredo.Main                           : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2023-07-05T14:07:12.122+08:00  INFO 9584 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="line">2023-07-05T14:07:12.123+08:00  INFO 9584 --- [           main] o.a.catalina.core.AprLifecycleListener   : An older version [1.2.34] of the Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [2.0.1]</span><br><span class="line">2023-07-05T14:07:12.123+08:00  INFO 9584 --- [           main] o.a.catalina.core.AprLifecycleListener   : Loaded Apache Tomcat Native library [1.2.34] using APR version [1.7.0].</span><br><span class="line">2023-07-05T14:07:12.140+08:00  INFO 9584 --- [           main] o.a.catalina.core.AprLifecycleListener   : OpenSSL successfully initialized [OpenSSL 1.1.1o  3 May 2022]</span><br><span class="line">2023-07-05T14:07:12.159+08:00  INFO 9584 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2023-07-05T14:07:12.159+08:00  INFO 9584 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.8]</span><br><span class="line">2023-07-05T14:07:12.356+08:00  INFO 9584 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2023-07-05T14:07:12.360+08:00  INFO 9584 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1596 ms</span><br><span class="line">2023-07-05T14:07:13.208+08:00  INFO 9584 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#x27;&#x27;</span><br><span class="line">2023-07-05T14:07:13.219+08:00  INFO 9584 --- [           main] com.fredo.Main                           : Started Main in 3.223 seconds (process running for 4.118)</span><br></pre></td></tr></table></figure><p>注意: 只有前两行和最后一行是SpringBoot的<strong>启动日志</strong><br>启动日志可以关闭:</p><ul><li>配置文件</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.main.log-startup-info</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><ul><li>代码:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplication application=<span class="keyword">new</span> <span class="title class_">SpringApplication</span>(Main.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭启动日志(注意:配置文件的优先级大于代码优先级!!!)</span></span><br><span class="line">        application.setLogStartupInfo(<span class="literal">false</span>);</span><br><span class="line">        application.run(args);</span><br></pre></td></tr></table></figure><h3 id="启动失败"><a href="#启动失败" class="headerlink" title="启动失败"></a>启动失败</h3><p>如果应用程序无法启动, 已注册的<code>FailureAnalyzers</code>将有机会提供专用的错误消息和解决问题的具体操作<br>以端口占用为例:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Embedded servlet container failed to start. Port 8080 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that is listening on port 8080 or configure this application to listen on another port.</span><br></pre></td></tr></table></figure><p><code>FailureAnalyzers</code>是一个用于分析应用程序失败原因的工具.当应用程序发生失败时,<code>FailureAnalyzers</code>会收集失败信息,<br>并分析失败原因,以便开发人员能够更好地理解应用程序的健康状况.</p><p>可自定义:</p><ul><li>1.自定义类继承<code>AbstractFailureAnalyzer</code>,并重写<code>analyze</code>方法.可参考:<code>BindValidationFailureAnalyzer</code></li><li>2.注册在META-INF&#x2F;spring.factories 文件中</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">com.fredo.custom.MyFailureAnalyzer</span><br></pre></td></tr></table></figure><h3 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h3><p>在容器启动时不初始化Bean,只有在第一次使用时再初始化</p><p>配置方法:</p><ul><li>配置文件</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.main.lazy-initialization</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><ul><li>代码:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启延迟初始化(默认关闭,不建议开启)</span></span><br><span class="line">application.setLazyInitialization(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>可以使用注解<code>@Lazy(false)</code>, 单独指定某些Bean延迟初始化</p><h3 id="自定义Banner"><a href="#自定义Banner" class="headerlink" title="自定义Banner"></a>自定义Banner</h3><p>Banner 就是程序启动时最上面的信息</p><p>类路径添加文件:<strong>banner.txt</strong>或设置<code>spring.banner.location</code>就可以定制 Banner<br><a href="https://www.bootschool.net/ascii">推荐网址</a></p><p>关闭</p><ul><li>配置文件</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.main.banner-mode</span>=<span class="string">off</span></span><br></pre></td></tr></table></figure><ul><li>代码:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭Banner,默认值:CONSOLE</span></span><br><span class="line">application.setBannerMode(Banner.Mode.OFF);</span><br></pre></td></tr></table></figure><h3 id="自定义SpringApplication"><a href="#自定义SpringApplication" class="headerlink" title="自定义SpringApplication"></a>自定义SpringApplication</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">  SpringApplication application=<span class="keyword">new</span> <span class="title class_">SpringApplication</span>(Main.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭启动日志(注意:配置文件的优先级大于代码优先级!!!)</span></span><br><span class="line">  application.setLogStartupInfo(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开启延迟初始化(默认关闭,不建议开启)</span></span><br><span class="line">  application.setLazyInitialization(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭Banner,默认值:CONSOLE</span></span><br><span class="line"><span class="comment">//        application.setBannerMode(Banner.Mode.OFF);</span></span><br><span class="line"></span><br><span class="line">  application.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义信息在<code>application.properties</code>中,<br>具体可<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config">参考官网</a></p><h3 id="流式构造API"><a href="#流式构造API" class="headerlink" title="流式构造API"></a>流式构造API</h3><p>可用于构建父子层次结构</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>()</span><br><span class="line">  .sources(Main.class) <span class="comment">// 父</span></span><br><span class="line">  .child(Main.class) <span class="comment">// 子,非必须</span></span><br><span class="line">  .bannerMode(Banner.Mode.OFF)</span><br><span class="line">  .run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件隔离"><a href="#配置文件隔离" class="headerlink" title="配置文件隔离"></a>配置文件隔离</h2><blockquote><p>环境隔离: 快速切换开发、测试、生产环境<br>步骤：</p><ol><li>标识环境：指定哪些组件、配置在哪个环境生效</li><li>切换环境：这个环境对应的所有组件和配置就应该生效</li></ol></blockquote><h3 id="指定环境"><a href="#指定环境" class="headerlink" title="指定环境"></a>指定环境</h3><p>Spring Profiles 提供一种隔离配置的方式, 使其仅在特定环境生效<br>任何组件都可用<code>@Profile</code>标记, 来指定何时被加载</p><p>例如:</p><ul><li>dev环境: @Profile({“dev”})</li><li>dev和prod环境: @Profile({“dev”, “prod”})</li></ul><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><p>配置文件激活</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">prod</span></span><br></pre></td></tr></table></figure><p>命令行激活</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=prod</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>不标注<code>@Profile</code>的组件无论是在哪个环境中都会激活</li><li>存在默认环境<code>@Profile(&#123;&quot;default&quot;&#125;)</code>,需要激活默认环境才有效</li><li>也可以设置默认激活的环境, <code>spring.profiles.default=dev</code></li><li>推荐使用激活方式激活指定环境</li></ul><h3 id="环境包含"><a href="#环境包含" class="headerlink" title="环境包含"></a>环境包含</h3><p>在配置文件(必须是在主配置文件中)中设置:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.include[0]</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.profiles.include[1]</span>=<span class="string">test</span></span><br><span class="line"><span class="attr">或者</span>:<span class="string"></span></span><br><span class="line"><span class="attr">spring.profiles.include</span>=<span class="string">dev,test</span></span><br></pre></td></tr></table></figure><h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p><strong>生效的环境 &#x3D; 激活的环境&#x2F;默认环境 + 包含的环境</strong></p><p>项目中:</p><ul><li>基础的配置<code>mybatis</code>,<code>log</code>,…：写到<strong>包含环境</strong>中</li><li>要动态切换变化的<code>db</code>, <code>redis</code>,…：写到<strong>激活的环境</strong>中</li></ul><h4 id="Profile-分组"><a href="#Profile-分组" class="headerlink" title="Profile 分组"></a>Profile 分组</h4><p>创建prod组，指定包含db和mq配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.group.prod[0]</span>=<span class="string">db</span></span><br><span class="line"><span class="attr">spring.profiles.group.prod[1]</span>=<span class="string">mq</span></span><br></pre></td></tr></table></figure><p>使用<code>--spring.profiles.active=prod</code>, 就会激活prod, 就会使用db, mq配置文件</p><h4 id="Profile-配置文件"><a href="#Profile-配置文件" class="headerlink" title="Profile 配置文件"></a>Profile 配置文件</h4><ul><li><code>application-&#123;profile&#125;.properties</code>可以作为指定环境的配置文件</li><li>激活这个环境，配置就会生效。最终生效的所有配置是<ul><li><code>application.properties</code>：主配置文件，任意时候都生效</li><li><code>application-&#123;profile&#125;.properties</code>：指定环境配置文件，激活指定环境生效</li></ul></li></ul><p>profile优先级 &gt; application</p><h2 id="外置配置文件"><a href="#外置配置文件" class="headerlink" title="外置配置文件"></a>外置配置文件</h2><blockquote><p>场景：线上应用如何快速修改配置，并应用最新配置？</p><ul><li>SpringBoot 使用  <strong>配置优先级</strong> + <strong>外部配置</strong>  简化配置更新、简化运维。</li><li>只需要给jar应用所在的文件夹放一个<code>application.properties</code>最新配置文件，重启项目就能自动应用最新配置</li></ul></blockquote><p>SpringBoot允许将配置外部化, 以便可以在不同的环境中使用相同的应用程序代码.<br>我们可以使用各种<strong>外部配置源</strong>, 包括<strong>Java Properties文件</strong>、<strong>YAML文件</strong>、<strong>环境变量</strong>和<strong>命令行参数</strong>。</p><p><code>@Value</code>可以获取值, 也可以用<code>@ConfigurationProperties</code>将所有属性<strong>绑定</strong>到java object中</p><h3 id="配置优先级"><a href="#配置优先级" class="headerlink" title="配置优先级"></a>配置优先级</h3><p>以下是SpringBoot属性源加载顺序。<strong>由低到高，高优先级配置覆盖低优先级</strong></p><ol><li><strong>默认属性</strong>（通过<code>SpringApplication.setDefaultProperties</code>指定的）</li><li><code>@PropertySource</code>指定加载的配置（需要写在<code>@Configuration</code>类上才可生效）</li><li>配置文件（application.properties&#x2F;yml等）</li><li><code>RandomValuePropertySource</code>支持的<code>random.*</code>配置（如：<code>@Value(&quot;$&#123;random.int&#125;&quot;)</code>）</li><li>OS 环境变量</li><li>Java 系统属性（System.getProperties()）</li><li>JNDI 属性（来自java:comp&#x2F;env）</li><li>ServletContext 初始化参数</li><li>ServletConfig 初始化参数</li><li>SPRING_APPLICATION_JSON属性（内置在环境变量或系统属性中的 JSON）</li><li><strong>命令行参数</strong></li><li>测试属性。(@SpringBootTest进行测试时指定的属性)</li><li>测试类@TestPropertySource注解</li><li>Devtools 设置的全局属性。($HOME&#x2F;.config&#x2F;spring-boot)</li></ol><p>小结一下:<br>常见的优先级顺序：<br>命令行&gt; 配置文件&gt; springapplication配置</p><p><strong>配置文件优先级如下</strong>：(后面覆盖前面)</p><ol><li>jar 包内的application.properties&#x2F;yml</li><li>jar 包内的application-{profile}.properties&#x2F;yml</li><li>jar 包外的application.properties&#x2F;yml</li><li>jar 包外的application-{profile}.properties&#x2F;yml</li></ol><blockquote><p>建议：用一种格式的配置文件。如果.properties和.yml同时存在,则.properties优先</p></blockquote><p>小结一下:</p><ul><li>包外 &gt; 包内</li><li>同级情况：profile配置 &gt; application配置</li></ul><p>所有参数均可由命令行传入，使用<code>--参数项=参数值</code>，将会被添加到环境变量中，并优先于配置文件<br>比如<code>java -jar app.jar --name=&quot;Spring&quot;</code>,可以使用<code>@Value(&quot;$&#123;name&#125;&quot;)</code>获取</p><p>演示场景：</p><ul><li>包内： application.properties   server.port&#x3D;8000</li><li>包内： application-dev.properties    server.port&#x3D;9000</li><li>包外：  application.properties   server.port&#x3D;8001</li><li>包外： application-dev.properties    server.port&#x3D;9001</li></ul><p>启动端口: 命令行 &gt; 9001 &gt; 8001 &gt; 9000 &gt; 8000</p><h3 id="外部配置"><a href="#外部配置" class="headerlink" title="外部配置"></a>外部配置</h3><p>SpringBoot 应用启动时会自动寻找<strong>application.properties</strong>和<strong>application.yaml</strong>位置进行加载.<br>顺序如下：（后面覆盖前面）</p><ul><li>类路径: 内部<ul><li>类根路径</li><li>类下<code>/config</code>包</li></ul></li><li>当前路径（项目所在的位置）<ul><li>当前路径</li><li>当前下<code>/config</code>子目录</li><li><code>/config</code>目录的直接子目录</li></ul></li></ul><p>最终效果：优先级由高到低，前面覆盖后面</p><ul><li>命令行 &gt; 包外config直接子目录 &gt; 包外config目录 &gt; 包外根目录 &gt; 包内目录</li><li>同级比较：<ul><li>profile配置 &gt; 默认配置</li><li>properties配置 &gt; yaml配置</li></ul></li></ul><img alt="配置优先级" src="https://image.fu-jw.com/img/2023/07/06/64a67fc67db26.png"/><p>规律：最外层的最优先</p><ul><li>命令行 &gt; 所有</li><li>包外 &gt; 包内</li><li>config目录 &gt; 根目录</li><li>profile &gt; application</li></ul><p>配置不同就都生效（互补），配置相同高优先级覆盖低优先级</p><h3 id="导入配置"><a href="#导入配置" class="headerlink" title="导入配置"></a>导入配置</h3><p>使用<code>spring.config.import</code>可以导入额外配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.config.import</span>=<span class="string">my.properties</span></span><br><span class="line"><span class="attr">my.property</span>=<span class="string">value</span></span><br></pre></td></tr></table></figure><p>无论以上写法的先后顺序, <strong>my.properties</strong>的值总是优先于直接在文件中编写的<strong>my.property</strong></p><h3 id="属性占位符"><a href="#属性占位符" class="headerlink" title="属性占位符"></a>属性占位符</h3><p>配置文件中可以使用<code>$&#123;name:default&#125;</code>形式取出之前配置过的值</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="attr">app.description</span>=<span class="string">$&#123;app.name&#125; is a Spring Boot application written by $&#123;username:Unknown&#125;</span></span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>详细可参考<a href="https://blog.fu-jw.com/posts/4275e528.html">SpringBoot日志</a></p><h2 id="单元测试-JUnit5"><a href="#单元测试-JUnit5" class="headerlink" title="单元测试-JUnit5"></a>单元测试-JUnit5</h2><p>详细可参考<a href="http://localhost:4000/posts/6d37548c.html">SpringBoot单元测试</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了SpringBoot的核心特性，包括SpringApplication的使用，如何通过配置文件和代码进行自定义设置，以及启动失败时的处理方式。文中还详述了如何实现配置文件的隔离和外置，解释了属性占位符的用途，以及配</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发1-自动配置原理浅析</title>
    <link href="http://fu-jw.com/posts/d5a9e6d8.html"/>
    <id>http://fu-jw.com/posts/d5a9e6d8.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了SpringBoot Web开发自动配置原理，包括web场景启动器的使用和自动装配功能，在web场景中添加特性如视图解析，静态资源处理，数据类型转换等。还有自定义静态资源的两种方式，通过配置文件或代码。</p></blockquote><h1 id="SpringBoot-Web开发1-自动配置原理浅析"><a href="#SpringBoot-Web开发1-自动配置原理浅析" class="headerlink" title="SpringBoot Web开发1-自动配置原理浅析"></a>SpringBoot Web开发1-自动配置原理浅析</h1><blockquote><p>我的<a href="https://github.com/fu-jw/spring-tutorial">SpringBoot项目</a>第四个模块</p></blockquote><p>由前面<a href="https://blog.fu-jw.com/posts/4ccc97e8.html">SpringBoot快速入门</a>分析可知,SpringBoot提出场景启动器的概念,<br>将场景中需要的所有依赖囊括进来,并自动装配,简化配置.<br>场景一引入,配置即完成</p><p>web开发同样需要<strong>web场景启动器</strong></p><h2 id="引入web场景启动器"><a href="#引入web场景启动器" class="headerlink" title="引入web场景启动器"></a>引入web场景启动器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-boot-starter-web</code>依赖<strong>核心场景启动器:</strong><code>spring-boot-starter</code><br><code>spring-boot-starter</code>依赖:<code>spring-boot-autoconfigure</code><br><code>spring-boot-autoconfigure</code>会加载:META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports<br>中的自动配置类<br>其中web相关有如下:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</span><br><span class="line">------------------------------以下是响应式编程相关--------------------------------------</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveMultipartAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebSessionIdResolverAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration</span><br></pre></td></tr></table></figure><p>上面的自动配置类会绑定的配置有:</p><ul><li><code>server</code> &#x3D;&#x3D;&gt;服务器相关</li><li><code>spring.mvc</code> &#x3D;&#x3D;&gt;springMVC相关</li><li><code>server.servlet.encoding</code> &#x3D;&#x3D;&gt;servlet编码相关</li><li><code>spring.servlet.multipart</code> &#x3D;&#x3D;&gt;servlet文件处理相关</li></ul><p>SpringBoot 的自动装配功能在<code>web场景</code>中添加了如下特性:</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc">官网介绍</a>:</p><blockquote><ol><li>Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.</li><li>Support for serving static resources, including support for WebJars (covered later in this document).</li><li>Automatic registration of Converter, GenericConverter, and Formatter beans.</li><li>Support for HttpMessageConverters (covered later in this document).</li><li>Automatic registration of MessageCodesResolver (covered later in this document).</li><li>Static index.html support.</li><li>Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).</li></ol><p>If you want to keep those Spring Boot MVC customizations and make more<br>MVC customizations (interceptors, formatters, view controllers, and other features),<br>you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc.</p><p>If you want to provide custom instances of RequestMappingHandlerMapping,<br>RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver,<br>and still keep the Spring Boot MVC customizations, you can declare a bean of<br>type WebMvcRegistrations and use it to provide custom instances of those components.</p><p>If you want to take complete control of Spring MVC,<br>you can add your own @Configuration annotated with @EnableWebMvc,<br>or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration<br>as described in the Javadoc of @EnableWebMvc</p></blockquote><p><code>web场景</code>引入后,就有了如下功能:</p><ol><li>包含<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>组件,方便视图解析</li><li>默认的静态资源处理机制: 静态资源放在<strong>static</strong>文件夹下即可直接访问</li><li>自动注册了<code>Converter</code>,<code>GenericConverter</code>,<code>Formatter</code>组件,适配常见<strong>数据类型转换</strong>和<strong>格式化</strong>需求</li><li>支持<code>HttpMessageConverters</code>,可以方便返回json等数据类型</li><li>自动注册<code>MessageCodesResolver</code>,方便<strong>国际化</strong>及错误消息处理</li><li>支持静态 index.html</li><li>自动使用<code>ConfigurableWebBindingInitializer</code>,实现<strong>消息处理</strong>,<strong>数据绑定</strong>,<strong>类型转化</strong>,<strong>数据校验</strong>等功能</li></ol><p>注意:</p><ul><li>如果想保持 SpringBoot MVC 的默认配置,并且自定义更多的 MVC 配置,如:<code>interceptors</code>,<code>formatters</code>,<code>view controllers</code><br>等.可以使用<code>@Configuration</code>注解添加一个<strong>WebMvcConfigurer</strong>类型的配置类,但不要标注<code>@EnableWebMvc</code></li><li>如果想保持 SpringBoot MVC<br>的默认配置,但要自定义核心组件实例,比如:<code>RequestMappingHandlerMapping</code>,<code>RequestMappingHandlerAdapter</code><br>,或<code>ExceptionHandlerExceptionResolver</code>,给容器中放一个<code>WebMvcRegistrations</code>组件即可</li><li>如果想全面接管 Spring MVC,<code>@Configuration</code>标注一个配置类,并加上<code>@EnableWebMvc</code>注解,实现<strong>WebMvcConfigurer</strong>接口</li></ul><p>接下来分别展开分析.</p><h2 id="自动配置原理浅析"><a href="#自动配置原理浅析" class="headerlink" title="自动配置原理浅析"></a>自动配置原理浅析</h2><p>由前面知道引入<code>web场景</code>会加载自动配置类:<code>WebMvcAutoConfiguration</code></p><p>下面简要分析<code>WebMvcAutoConfiguration</code>原理</p><h3 id="生效条件"><a href="#生效条件" class="headerlink" title="生效条件"></a>生效条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration(after = &#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">        ValidationAutoConfiguration.class&#125;)</span> <span class="comment">// 需要在这三个自动配置之后</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span> <span class="comment">// //需要是普通的SERVLET类型的 web应用就生效,REACTIVE类型的响应式web是另一套</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span> <span class="comment">// 需要包括这三个类</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span> <span class="comment">// 需要容器中没有这个bean</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span> <span class="comment">// 优先级</span></span><br><span class="line"><span class="meta">@ImportRuntimeHints(WebResourcesRuntimeHints.class)</span></span><br><span class="line"><span class="comment">// 项目启动就注册的静态资源:&quot;META-INF/resources/&quot;,&quot;resources/&quot;,&quot;static/&quot;,&quot;public/&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生效后, 在容器中放入两个bean:</p><h3 id="HiddenHttpMethodFilter-过滤页面表单提交的Rest请求"><a href="#HiddenHttpMethodFilter-过滤页面表单提交的Rest请求" class="headerlink" title="HiddenHttpMethodFilter: 过滤页面表单提交的Rest请求"></a><code>HiddenHttpMethodFilter</code>: 过滤页面表单提交的Rest请求</h3><blockquote><ul><li>Rest 请求有: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code></li><li>请求数据包含三部分: <strong>请求行</strong>, <strong>请求头</strong>, <strong>请求体</strong></li><li>浏览器只能发送<code>GET</code>请求和<code>POST</code>请求</li><li><code>GET</code>请求没有<strong>请求体</strong>, 参数在<strong>请求行</strong>中,获取参数的方法是<code>getQueryString()</code></li><li><code>POST</code>请求的参数在<strong>请求体</strong>中, 获取方法是<code>getReader()</code>或<code>getInputStream()</code></li><li>getMethod() 获取具体哪种请求方式</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法将浏览器不支持的请求,转换成标准的HTTP方法:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将发出请求的方法参数转换为 HTTP 方法，可通过 HttpServletRequest.getMethod() 检索。</span></span><br><span class="line"><span class="comment"> * 由于浏览器目前仅支持GET和POST，通常是使用带有附加隐藏表单字段（_method）的普通POST来传递“真正的”HTTP方法。</span></span><br><span class="line"><span class="comment"> * 例如:&lt;form action=&quot;...&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot; /&gt;</span></span><br><span class="line"><span class="comment"> *       ......</span></span><br><span class="line"><span class="comment"> *     &lt;/form&gt;</span></span><br><span class="line"><span class="comment"> * 此过滤器读取该参数并相应地更改 HttpServletRequestWrapper.getMethod（） 返回值。</span></span><br><span class="line"><span class="comment"> * 只允许使用“PUT”、“DELETE”和“PATCH” HTTP方法。</span></span><br><span class="line"><span class="comment"> * 请求参数的名称默认为 _method，但可以通过 methodParam 属性进行调整。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：在大部分 POST 请求的情况下，此过滤器需要在 MultipartFilter 处理后运行，因为它本来就需要检查 POST 正文参数。</span></span><br><span class="line"><span class="comment"> * 所以通常，在你的web.xml过滤器链中，在隐藏的HttpMethodFilter之前放置一个 </span></span><br><span class="line"><span class="comment"> * Spring org.springframework.web.multipart.support.MultipartFilter。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即在此过滤之前会有专门处理 POST 请求的 MultipartFilter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiddenHttpMethodFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; ALLOWED_METHODS =</span><br><span class="line">            List.of(HttpMethod.PUT.name(), HttpMethod.DELETE.name(), HttpMethod.PATCH.name());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">requestToUse</span> <span class="operator">=</span> request;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">paramValue</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.methodParam);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">              <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">                requestToUse = <span class="keyword">new</span> <span class="title class_">HttpMethodRequestWrapper</span>(request, method);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      filterChain.doFilter(requestToUse, response);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FormContentFilter-用于分析表单内容-与前面的过滤器配合使用"><a href="#FormContentFilter-用于分析表单内容-与前面的过滤器配合使用" class="headerlink" title="FormContentFilter:用于分析表单内容, 与前面的过滤器配合使用,"></a><code>FormContentFilter</code>:用于分析表单内容, 与前面的过滤器配合使用,</h3><p>同样只针对<code>PUT</code>,<code>PATCH</code>,<code>DELETE</code>三种HTTP请求</p><h3 id="静态内部类WebMvcAutoConfigurationAdapter"><a href="#静态内部类WebMvcAutoConfigurationAdapter" class="headerlink" title="静态内部类WebMvcAutoConfigurationAdapter"></a>静态内部类<code>WebMvcAutoConfigurationAdapter</code></h3><p>在<code>WebMvcAutoConfiguration</code>中有静态内部类<code>WebMvcAutoConfigurationAdapter</code>源码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Defined as a nested config to ensure WebMvcConfigurer is not read when not on the classpath</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, WebProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>, ServletContextAware &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口WebMvcConfigurer"><a href="#接口WebMvcConfigurer" class="headerlink" title="接口WebMvcConfigurer"></a>接口<code>WebMvcConfigurer</code></h4><p><code>WebMvcAutoConfigurationAdapter</code>实现了<code>WebMvcConfigurer</code>接口,可以重写一些有关Web MVC的配置方法,比如添加拦截器、配置视图解析器、配置静态资源等.<br>通过重写这些方法,可以根据自己的需要定制化Web MVC的行为.可定制功能有:</p><img src="https://image.fu-jw.com/img/2023/07/01/649f85725fe98.webp" alt="WebMvcConfigurer"/><ul><li>addArgumentResolvers:添加参数解析器</li><li>addCorsMappings:添加跨域映射</li><li>addFormatters:添加格式化器</li><li>addInterceptors:添加拦截器</li><li>addResourceHandlers:添加资源处理器,处理静态资源规则</li><li>addReturnValueHandlers:添加返回值处理器</li><li>addViewControllers:添加视图控制器,指定某个请求路径跳转到指定页面</li><li>configureAsyncSupport:配置异步支持</li><li>configureContentNegotiation:配置内容协商</li><li>configureDefaultServletHandling:配置默认的处理,默认接收: &#x2F;</li><li>configureHandlerExceptionResolvers:配置异常解析器</li><li>configureMessageConverters:配置消息转化器</li><li>configurePathMatch:配置路径匹配</li><li>configureViewResolvers:配置视图解析器</li><li>extendHandlerExceptionResolvers:扩展处理异常解析器</li><li>extendMessageConverters扩展消息转换器</li><li>getMessageCodesResolver:获取消息编码解析器</li><li>getValidator:获取校验器</li></ul><h4 id="静态资源规则源码浅析"><a href="#静态资源规则源码浅析" class="headerlink" title="静态资源规则源码浅析"></a>静态资源规则源码浅析</h4><p>由上面分析,<code>addResourceHandlers</code>用来处理静态资源,源码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVLET_LOCATION=<span class="string">&quot;/&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add handlers to serve static resources such as images, js, and, css files from specific locations under web application root, the classpath,and others.</span></span><br><span class="line"><span class="comment"> * 即根据配置情况，添加不同的静态资源处理器，用于处理静态资源的访问请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否需要启用默认的资源处理。</span></span><br><span class="line">  <span class="comment">// 如果不需要启用，默认资源处理被禁用，同时输出调试信息，并直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">this</span>.resourceProperties.isAddMappings())&#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 需要启用默认资源处理,下面添加两种静态资源处理规则</span></span><br><span class="line">    <span class="comment">// private String webjarsPathPattern = &quot;/webjars/**&quot;;        </span></span><br><span class="line">    <span class="comment">// 访问路径:/webjars/**, 就去路径:classpath:/META-INF/resources/webjars/ 下面找对应资源</span></span><br><span class="line">    addResourceHandler(registry,<span class="built_in">this</span>.mvcProperties.getWebjarsPathPattern(),</span><br><span class="line">    <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    <span class="comment">// private String staticPathPattern = &quot;/**&quot;;</span></span><br><span class="line">    <span class="comment">// private String[] staticLocations = </span></span><br><span class="line">    <span class="comment">// &quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;</span></span><br><span class="line">    addResourceHandler(registry,<span class="built_in">this</span>.mvcProperties.getStaticPathPattern(),(registration)-&gt;&#123;</span><br><span class="line">    registration.addResourceLocations(<span class="built_in">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.servletContext!=<span class="literal">null</span>)&#123;</span><br><span class="line">       ServletContextResource resource=<span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(<span class="built_in">this</span>.servletContext,SERVLET_LOCATION);</span><br><span class="line">       registration.addResourceLocations(resource);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向资源处理器注册表中添加资源处理器,并根据配置文件和自定义函数设置资源处理器的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addResourceHandler</span><span class="params">(ResourceHandlerRegistry registry,String pattern,Consumer&lt;ResourceHandlerRegistration&gt; customizer)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否已经存在了指定的pattern</span></span><br><span class="line">    <span class="keyword">if</span>(registry.hasMappingForPattern(pattern))&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个资源处理器注册（ResourceHandlerRegistration）对象</span></span><br><span class="line">    ResourceHandlerRegistration registration=registry.addResourceHandler(pattern);</span><br><span class="line">    <span class="comment">// 将刚才创建的资源处理器注册对象作为参数，用于自定义资源处理器的属性</span></span><br><span class="line">    customizer.accept(registration);</span><br><span class="line">    <span class="comment">// 根据配置文件中的缓存时间设置资源处理器的缓存时间（cache period），以及缓存控制（cache control）策略</span></span><br><span class="line">   registration.setCachePeriod(getSeconds(<span class="built_in">this</span>.resourceProperties.getCache().getPeriod()));</span><br><span class="line">    registration.setCacheControl(<span class="built_in">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());</span><br><span class="line">    registration.setUseLastModified(<span class="built_in">this</span>.resourceProperties.getCache().isUseLastModified());</span><br><span class="line">    <span class="comment">// 进一步自定义资源处理器注册对象的属性</span></span><br><span class="line">    customizeResourceHandlerRegistration(registration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结一下:<br>静态资源访问规则如下:</p><ul><li>规则一 访问： <code>/webjars/**</code>路径就去<code>classpath:/META-INF/resources/webjars/</code>下找资源.</li><li>规则二 访问： <code>/**</code>路径就去 静态资源默认的四个位置找资源<ul><li><code>classpath:/META-INF/resources/</code></li><li><code>classpath:/resources/</code></li><li><code>classpath:/static/</code></li><li><code>classpath:/public/</code></li></ul></li><li>规则三 静态资源默认都有<strong>缓存规则</strong>的设置<ul><li>所有缓存的设置, 直接通过配置文件:<code>spring.web</code></li><li>cachePeriod: 缓存周期; 多久不用找服务器要新的, 默认没有，以秒为单位</li><li>cacheControl: <strong>HTTP缓存控制</strong>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching">查看文档</a></li><li>useLastModified：是否使用最后一次修改, 配合HTTP Cache规则, 如果浏览器访问了一个静态资源</li></ul></li></ul><blockquote><p>如果浏览器访问了一个静态资源 index.js，如果服务这个资源没有发生变化，下次访问的时候就可以直接让浏览器用自己缓存中的东西，而不用给服务器发请求</p></blockquote><h4 id="HTTP缓存实验"><a href="#HTTP缓存实验" class="headerlink" title="HTTP缓存实验"></a>HTTP缓存实验</h4><p>设置如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、spring.web：</span></span><br><span class="line"><span class="comment"># 1.配置国际化的区域信息(locale)</span></span><br><span class="line"><span class="comment"># 2.静态资源策略(开启、处理链、缓存)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">true</span> <span class="comment"># 开启静态资源映射规则,默认true</span></span><br><span class="line">      <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">period:</span> <span class="number">3600</span> <span class="comment"># 单位是 秒, 此为简要设置, 下面(cache-control)是详细配置,会覆盖period</span></span><br><span class="line">        <span class="attr">cache-control:</span></span><br><span class="line">          <span class="attr">max-age:</span> <span class="number">7200</span> <span class="comment"># 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span></span><br><span class="line">        <span class="attr">use-last-modified:</span> <span class="literal">true</span> <span class="comment"># 默认true, 使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304</span></span><br></pre></td></tr></table></figure><p>第一次请求:</p><img src="https://image.fu-jw.com/img/2023/07/01/649f850bd24ec.webp" alt="第一次请求"/><p>第二次请求:</p><img src="https://image.fu-jw.com/img/2023/07/01/649f85350e56a.webp" alt="第二次请求"/><h3 id="自定义静态资源"><a href="#自定义静态资源" class="headerlink" title="自定义静态资源"></a>自定义静态资源</h3><p>大体分为两种方式:</p><ul><li>配置文件的方式</li><li>代码的方式</li></ul><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, WebProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>, ServletContextAware &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与两个配置文件绑定<code>WebMvcProperties.class</code>和<code>WebProperties.class</code>,<br>即以<code>spring.web</code>和<code>spring.mvc</code>开头的配置</p><ul><li><code>spring.web</code>:可配置locale(国际化)和resources(静态资源相关),具体可查看<code>WebProperties.class</code></li><li><code>spring.mvc</code>:可配置内容很多,具体可查看<code>WebMvcProperties.class</code></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">true</span> <span class="comment"># 开启静态资源映射规则,默认true</span></span><br><span class="line">      <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">period:</span> <span class="number">3600</span> <span class="comment"># 单位是 秒, 此为简要设置, 下面(cache-control)是详细配置,会覆盖period</span></span><br><span class="line">        <span class="attr">cache-control:</span></span><br><span class="line">          <span class="attr">max-age:</span> <span class="number">7200</span> <span class="comment"># 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span></span><br><span class="line">        <span class="attr">use-last-modified:</span> <span class="literal">true</span> <span class="comment"># 默认true, 使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">classpath:/static/,classpath:/test/</span> <span class="comment"># 自定义静态资源目录,按顺序访问</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">webjars-path-pattern:</span> <span class="string">/webjars/**</span> <span class="comment"># 自定义webjars路径前缀,默认:/webjars/**</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/static/**</span> <span class="comment"># 静态资源访问路径前缀,默认:/**</span></span><br></pre></td></tr></table></figure><h4 id="代码方式"><a href="#代码方式" class="headerlink" title="代码方式"></a>代码方式</h4><p>就是在容器中放置组件:<code>WebMvcConfigurer</code>,来配置底层.</p><p>注意:</p><ul><li>默认配置仍有效</li><li>加上<code>@EnableWebMvc</code>会将默认配置失效</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span> &#123;<span class="comment">// 与下面代码一样效果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;/static&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123; <span class="comment">// 还可以上面写法,效果一样</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 保留默认配置</span></span><br><span class="line">    WebMvcConfigurer.<span class="built_in">super</span>.addResourceHandlers(registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义配置</span></span><br><span class="line">    registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>)<span class="comment">// 设置静态资源访问前缀,同配置文件中的spring.mvc.static-path-pattern:</span></span><br><span class="line">            .addResourceLocations(<span class="string">&quot;/static&quot;</span>);<span class="comment">// 设置静态资源获取路径,同配置文件中的spring.web.resources.static-locations: classpath:/static/</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details> <summary><strong><span style="color: red; ">为什么容器中含有WebMvcConfigurer组件,就能配置底层行为???</span></strong></summary><ol><li><code>WebMvcAutoConfiguration</code>是一个自动配置类, 它里面有一个<code>EnableWebMvcConfiguration</code></li><li><code>EnableWebMvcConfiguration</code>继承与<code>DelegatingWebMvcConfiguration</code>, 这两个都生效</li><li><code>DelegatingWebMvcConfiguration</code>利用<strong>DI</strong>把容器中所有<code>WebMvcConfigurer</code>注入进来</li><li>当调用<code>DelegatingWebMvcConfiguration</code>的方法配置底层规则, 而它调用所有<code>WebMvcConfigurer</code>的配置底层方法</li></ol></details>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了SpringBoot Web开发自动配置原理，包括web场景启动器的使用和自动装配功能，在web场景中添加特性如视图解析，静态资源处理，数据类型转换等。还有自定义静态资源的两种方式，通过配置文件或代码。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发2-路径匹配</title>
    <link href="http://fu-jw.com/posts/10ba68de.html"/>
    <id>http://fu-jw.com/posts/10ba68de.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍SpringBoot Web开发中的路径匹配技术。介绍了Spring5.3后的请求路径匹配策略，包括旧的AntPathMatcher策略和新的默认PathPatternParser策略。文章解释了如何在代码中选择和配置这两种策略</p></blockquote><h1 id="SpringBoot-Web开发2-路径匹配"><a href="#SpringBoot-Web开发2-路径匹配" class="headerlink" title="SpringBoot Web开发2-路径匹配"></a>SpringBoot Web开发2-路径匹配</h1><h2 id="路径匹配"><a href="#路径匹配" class="headerlink" title="路径匹配"></a>路径匹配</h2><p><strong>Spring5.3</strong>之后加入了更多的<strong>请求路径匹配</strong>的实现策略,</p><p>以前只支持<strong>AntPathMatcher</strong>策略,现在提供了<strong>PathPatternParser</strong>策略,<br>并且可以指定使用哪种策略</p><p>默认使用<strong>PathPatternParser</strong>策略</p><h3 id="AntPathMatcher策略"><a href="#AntPathMatcher策略" class="headerlink" title="AntPathMatcher策略"></a>AntPathMatcher策略</h3><p>Ant 风格的路径模式语法具有以下规则:</p><ul><li><em>：表示<strong>任意数量</strong>的*<em>字符</em></em>,0~n</li><li>?：表示<strong>任意一个</strong>字符,</li><li>*<em>：表示<strong>任意数量</strong>的*<em>目录</em></em></li><li>{}：表示一个命名的模式<strong>占位符</strong></li><li>[]：表示字符集合,例如[a-z]表示小写字母</li></ul><p>例如:</p><ul><li><strong>*.html</strong> 匹配任意名称,且扩展名为.html的文件</li><li><strong>&#x2F;folder1&#x2F;<em>&#x2F;</em>.java</strong> 匹配在folder1目录下的任意两级目录下的.java文件</li><li><strong>&#x2F;folder2&#x2F;**&#x2F;*.jsp</strong> 匹配在folder2目录下任意目录深度的.jsp文件</li><li><strong>&#x2F;{type}&#x2F;{id}.html</strong> 匹配任意文件名为{id}.html,在任意命名的{type}目录下的文件</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">注意：Ant 风格的路径模式语法中的特殊字符需要转义,如:</span><br><span class="line">1. 要匹配文件路径中的星号,则需要转义为\\*</span><br><span class="line">2. 要匹配文件路径中的问号,则需要转义为\\?</span><br></pre></td></tr></table></figure><p>代码测试:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AntPathController</span> &#123;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/a*/b?/&#123;p1:[a-f]+&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable(&quot;p1&quot;)</span> String path)</span> &#123;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;路径变量p1： &#123;&#125;&quot;</span>, path);</span><br><span class="line">    <span class="comment">//获取请求路径</span></span><br><span class="line">    <span class="keyword">return</span> request.getRequestURI();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问:<a href="http://localhost:8080/ads/bd/adf">http://localhost:8080/ads/bd/adf</a></p><img src="https://image.fu-jw.com/img/2023/07/01/649f847e483f9.webp" alt="AntPathMatcher策略"/><p>控制台打印:</p><blockquote><p>路径变量p1： adf</p></blockquote><h3 id="PathPatternParser策略"><a href="#PathPatternParser策略" class="headerlink" title="PathPatternParser策略"></a>PathPatternParser策略</h3><blockquote><ul><li>基准测试下,有<strong>6~8</strong>倍吞吐量提升,降低30%~40%空间分配率</li><li>兼容<strong>AntPathMatcher</strong>语法,并支持更多类型的路径模式</li></ul></blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">注意:&quot;**&quot; 多段匹配的支持仅允许在模式末尾使用</span><br></pre></td></tr></table></figure><h3 id="修改默认策略"><a href="#修改默认策略" class="headerlink" title="修改默认策略"></a>修改默认策略</h3><ul><li>配置文件:spring.mvc.pathmatch.matching-strategy&#x3D;ant_path_matcher</li><li>代码修改:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法可以修改路径匹配规则</span></span><br><span class="line"><span class="comment"> * 从spring5.3 开始,默认 PathPatternParser</span></span><br><span class="line"><span class="comment"> * 想要修改为 AntPathMatcher,则只需设置为空即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span>&#123;</span><br><span class="line">    configurer.setPatternParser(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><ul><li>使用默认的路径匹配规则(<code>PathPatternParser</code>)即可,性能高,兼容Ant风格</li><li>如果中间需要双星(**),只能换回Ant风格</li></ul><p>SpringBoot 底层匹配策略:<br>WebMvcAutoConfiguration.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span>&#123;</span><br><span class="line">  <span class="comment">// 只有 ANT_PATH_MATCHER 才条件成立,创建 new AntPathMatcher()</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.mvcProperties.getPathmatch().getMatchingStrategy()==WebMvcProperties.MatchingStrategy.ANT_PATH_MATCHER)&#123;</span><br><span class="line">    configurer.setPathMatcher(<span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>());</span><br><span class="line">    <span class="built_in">this</span>.dispatcherServletPath.ifAvailable((dispatcherPath)-&gt;&#123;</span><br><span class="line">      String servletUrlMapping=dispatcherPath.getServletUrlMapping();</span><br><span class="line">      <span class="keyword">if</span>(servletUrlMapping.equals(<span class="string">&quot;/&quot;</span>)&amp;&amp;singleDispatcherServlet())&#123;</span><br><span class="line">        UrlPathHelper urlPathHelper=<span class="keyword">new</span> <span class="title class_">UrlPathHelper</span>();</span><br><span class="line">        urlPathHelper.setAlwaysUseFullPath(<span class="literal">true</span>);</span><br><span class="line">        configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况,WebMvcProperties.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认情况是:PATH_PATTERN_PARSER</span></span><br><span class="line"><span class="keyword">private</span> MatchingStrategy matchingStrategy=MatchingStrategy.PATH_PATTERN_PARSER;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////</span></span><br><span class="line"><span class="comment">// MatchingStrategy 是枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">MatchingStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Use the &#123;<span class="doctag">@code</span> AntPathMatcher&#125; implementation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ANT_PATH_MATCHER,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Use the &#123;<span class="doctag">@code</span> PathPatternParser&#125; implementation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  PATH_PATTERN_PARSER</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍SpringBoot Web开发中的路径匹配技术。介绍了Spring5.3后的请求路径匹配策略，包括旧的AntPathMatcher策略和新的默认PathPatternParser策略。文章解释了如何在代码中选择和配</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发3-内容协商</title>
    <link href="http://fu-jw.com/posts/2ba4c64a.html"/>
    <id>http://fu-jw.com/posts/2ba4c64a.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了HTTP内容协商，包括服务端驱动型内容协商和代理驱动型内容协商，并分析了SpringMVC和SpringBoot的内容协商方式。文章还通过示例和图示说明了如何进行基于请求头和基于请求参数的内容协商，以及如何进行测试和配置。最后，探讨了内容协商的原理。</p></blockquote><h1 id="SpringBoot-Web开发3-内容协商"><a href="#SpringBoot-Web开发3-内容协商" class="headerlink" title="SpringBoot Web开发3-内容协商"></a>SpringBoot Web开发3-内容协商</h1><h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><h3 id="HTTP内容协商"><a href="#HTTP内容协商" class="headerlink" title="HTTP内容协商"></a>HTTP内容协商</h3><p>在<strong>HTTP</strong>协议中,<strong>内容协商</strong>是一种机制,用于为同一<strong>URI</strong>提供资源不同的表示形式,以帮助用户代理指定最适合用户的表示形式<br>例如,哪种文档语言,哪种图片格式或者哪种内容编码</p><p>内容协商通常有两种方式,服务端驱动型内容协商和代理驱动型内容协商</p><h4 id="服务端驱动型内容协商"><a href="#服务端驱动型内容协商" class="headerlink" title="服务端驱动型内容协商"></a>服务端驱动型内容协商</h4><p>在服务端驱动型内容协商或者主动内容协商中,浏览器（或者其他任何类型的用户代理）会随同 URL 发送一系列的 HTTP 标头.<br>这些标头描述了用户倾向的选择.服务器则以此为线索,通过内部算法来选择最佳方案提供给客户端.如果它不能提供一个合适的资源,<br>它可能使用 406（Not Acceptable）、415（Unsupported Media Type）进行响应并为其支持的媒体类型设置标头.<br>例如，分别对 POST 和 PATCH 请求使用 Accept-Post (en-US) 或 Accept-Patch 标头</p><img src="https://image.fu-jw.com/img/2023/07/01/649f8446e65eb.webp" alt="服务端驱动型内容协商"/><p>HTTP&#x2F;1.1 规范指定了一系列的标准标头用于启动服务端驱动型内容协商（Accept、Accept-Charset、Accept-Encoding、Accept-Language）</p><table><thead><tr><th>请求头</th><th>请求头说明</th><th>响应头</th><th>响应头说明</th></tr></thead><tbody><tr><td>Accept</td><td>告诉服务端需要的类型</td><td>Content-Type</td><td>告诉客户端响应的媒体类型</td></tr><tr><td>Accept-Language</td><td>告诉服务端需要的语言</td><td>Content-Language</td><td>告诉客户端响应的语言</td></tr><tr><td>Accept-Charset</td><td>告诉服务端需要的字符集</td><td>Content-Charset</td><td>告诉客户端响应的字符集</td></tr><tr><td>Accept-Encoding</td><td>告诉服务端需要的压缩方式</td><td>Content-Encoding</td><td>告诉客户端响应的压缩方式</td></tr></tbody></table><h4 id="代理驱动型内容协商"><a href="#代理驱动型内容协商" class="headerlink" title="代理驱动型内容协商"></a>代理驱动型内容协商</h4><p>从 HTTP 协议制定之初，该协议就准许另外一种协商机制：代理驱动型内容协商，或称为响应式协商。<br>在这种协商机制中，当面临不明确的请求时，服务器会返回一个页面，其中包含了可供选择的资源的链接。<br>资源呈现给用户，由用户做出选择.但是HTTP 标准没有明确指定提供可选资源链接的页面的格式，这阻碍了该过程的无痛自动化。<br>除了退回至服务端驱动型内容协商外，这种自动化方法几乎无一例外都是通过脚本技术来完成的，<br>尤其是 JavaScript 重定向技术：在检测了协商的条件之后，脚本会触发重定向动作。<br>另外一个问题是，为了获得实际的资源，需要额外发送一次请求，减慢了将资源呈现给用户的速度</p><h3 id="SpringMVC的内容协商"><a href="#SpringMVC的内容协商" class="headerlink" title="SpringMVC的内容协商"></a>SpringMVC的内容协商</h3><p>SpringMVC实现了HTTP内容协商的同时,又进行了扩展.<br>支持4种内容协商方式：HTTP首部Accept，扩展名，请求参数，或者固定类型</p><h3 id="SpringBoot的内容协商"><a href="#SpringBoot的内容协商" class="headerlink" title="SpringBoot的内容协商"></a>SpringBoot的内容协商</h3><p>由于SpringBoot的<code>web场景启动器</code>整合了SpringMVC,因此SpringBoot引入<code>web场景启动器</code>后即可拥有内容协商功能</p><p>SpringBoot有两种方式:基于请求头和基于请求参数的实现</p><ul><li>基于请求头内容协商:(默认开启)<ul><li>客户端向服务端发送请求，携带HTTP标准的<strong>Accept请求头</strong></li><li><strong>Accept</strong>: <code>application/json</code>、<code>text/xml</code>、<code>text/yaml</code></li><li>服务端根据客户端请求头期望的数据类型进行动态返回</li></ul></li><li>基于请求参数内容协商:(需要开启)<ul><li>发送请求: GET &#x2F;person?format&#x3D;json</li><li>匹配到 @GetMapping(“&#x2F;person”)</li><li>根据参数协商,优先返回<strong>json</strong>类型数据,(需要开启参数匹配设置)</li><li>发送请求 GET &#x2F;person?format&#x3D;xml,优先返回<strong>xml</strong>类型数据</li></ul></li></ul><img src="https://image.fu-jw.com/img/2023/07/01/649f841eacfa9.webp"/><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>默认情况,返回JSON</p><details> <summary><strong><span style="color: red; ">是因为???</span></strong></summary><strong>web场景</strong>依赖<strong>spring-boot-starter-json</strong><br/><strong>spring-boot-starter-json</strong>依赖<strong>jackson-databind</strong><br/><strong>jackson-databind</strong>可以将对象转为JSON</details><p>效果:<br><img src="https://image.fu-jw.com/img/2023/07/01/649f83f97a750.webp"/><br><img src="https://image.fu-jw.com/img/2023/07/01/649f83db815e5.webp"/></p><p>修改为XML格式:</p><ol><li>引依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>标注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JacksonXmlRootElement</span>  <span class="comment">// 可以写出为xml文档</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:</p><img src="https://image.fu-jw.com/img/2023/07/01/649f83a2b0c4e.webp"/><p>参数演示:</p><p>需要开启<strong>基于请求参数</strong>的内容协商</p><p>代码版:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内容协商的相关配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span>&#123;</span><br><span class="line">    <span class="comment">// 开启基于请求参数的内容协商功能</span></span><br><span class="line">    configurer.favorParameter(<span class="literal">true</span>);<span class="comment">// 默认:false</span></span><br><span class="line">    <span class="comment">// 自定义内容协商时使用的参数名</span></span><br><span class="line">    configurer.parameterName(<span class="string">&quot;type&quot;</span>);<span class="comment">// 默认:format</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件版:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启基于请求参数的内容协商功能。 默认参数名：format。 默认此功能不开启</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 指定内容协商时使用的参数名。默认是 format</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.parameter-name</span>=<span class="string">type</span></span><br></pre></td></tr></table></figure><img src="https://image.fu-jw.com/img/2023/07/01/649f8378aac51.webp"/><img src="https://image.fu-jw.com/img/2023/07/01/649f835b383d5.webp"/><img src="https://image.fu-jw.com/img/2023/07/01/649f8333bc364.webp"/><img src="https://image.fu-jw.com/img/2023/07/01/649f83010fe7d.webp"/><h3 id="内容协商原理浅析"><a href="#内容协商原理浅析" class="headerlink" title="内容协商原理浅析"></a>内容协商原理浅析</h3><blockquote><p>其实就是</p><ul><li>HttpMessageConverter 怎么工作？合适工作？</li><li>定制 HttpMessageConverter 来实现多端内容协商</li><li>编写WebMvcConfigurer提供的configureMessageConverters底层，修改底层的MessageConverter</li></ul></blockquote><h4 id="ResponseBody由HttpMessageConverter处理"><a href="#ResponseBody由HttpMessageConverter处理" class="headerlink" title="@ResponseBody由HttpMessageConverter处理"></a><code>@ResponseBody</code>由<strong>HttpMessageConverter</strong>处理</h4><blockquote><p>标注了<code>@ResponseBody</code>的返回值 将会由支持它的<strong>HttpMessageConverter</strong>写给浏览器</p></blockquote><ul><li><p>如果<strong>controller</strong>方法的返回值标注了<code>@ResponseBody</code>注解</p><ul><li>请求进来先来到<strong>DispatcherServlet</strong>的<code>doDispatch()</code>进行处理</li><li>找到一个<strong>HandlerAdapter</strong>适配器。利用适配器执行目标方法</li><li><code>RequestMappingHandlerAdapter</code>来执行，调用<code>invokeHandlerMethod()</code>来执行目标方法</li><li>目标方法执行之前，准备好两个东西<ul><li>HandlerMethodArgumentResolver：参数解析器，确定目标方法每个参数值</li><li>HandlerMethodReturnValueHandler：返回值处理器，确定目标方法的返回值改怎么处理</li></ul></li><li><code>RequestMappingHandlerAdapter</code>里面的<code>invokeAndHandle()</code>真正执行目标方法</li><li>目标方法执行完成，会返回<strong>返回值对象</strong></li><li>找到一个合适的返回值处理器<code>HandlerMethodReturnValueHandler</code></li><li>最终找到<code>RequestResponseBodyMethodProcessor</code>能处理 标注了<code>@ResponseBody</code>注解的方法</li><li><code>RequestResponseBodyMethodProcessor</code>调用<code>writeWithMessageConverters</code>,利用<code>MessageConverter</code>把返回值写出去</li></ul></li><li><p><code>HttpMessageConverter</code>会先进行内容协商</p><ul><li>遍历所有的<code>MessageConverter</code>看谁支持这种内容类型的数据</li><li>默认<code>MessageConverter</code>有以下:</li><li><img src="https://image.fu-jw.com/img/2023/07/01/649f825276881.webp"/></li><li>最终因为要<code>json</code>所以<code>MappingJackson2HttpMessageConverter</code>支持写出json</li><li>jackson用<code>ObjectMapper</code>把对象写出去</li></ul></li></ul><h4 id="WebMvcAutoConfiguration提供几种默认HttpMessageConverters"><a href="#WebMvcAutoConfiguration提供几种默认HttpMessageConverters" class="headerlink" title="WebMvcAutoConfiguration提供几种默认HttpMessageConverters"></a>WebMvcAutoConfiguration提供几种默认HttpMessageConverters</h4><p><code>EnableWebMvcConfiguration</code>通过<code>addDefaultHttpMessageConverters</code>添加了默认的<code>MessageConverter</code>;<br>如下:</p><ul><li><code>ByteArrayHttpMessageConverter</code>： 支持字节数据读写</li><li><code>StringHttpMessageConverter</code>: 支持字符串读写</li><li><code>ResourceHttpMessageConverter</code>: 支持资源读写</li><li><code>ResourceRegionHttpMessageConverter</code>: 支持分区资源写出</li><li><code>AllEncompassingFormHttpMessageConverter</code>: 支持表单xml&#x2F;json读写</li><li><code>MappingJackson2HttpMessageConverter</code>: 支持请求响应体Json读写</li></ul><blockquote><p>系统提供默认的MessageConverter 功能有限，仅用于json或者普通返回数据。<br>额外增加新的内容协商功能，必须增加新的HttpMessageConverter</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了HTTP内容协商，包括服务端驱动型内容协商和代理驱动型内容协商，并分析了SpringMVC和SpringBoot的内容协商方式。文章还通过示例和图示说明了如何进行基于请求头和基于请求参数的内容协商，以及如何进行测试</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发4-模板引擎</title>
    <link href="http://fu-jw.com/posts/3965340.html"/>
    <id>http://fu-jw.com/posts/3965340.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了SpringBoot Web开发中的模板引擎，包括SpringMVC所支持的多种模板技术，如Thymelaf、FreeMarker和JSP等，以及SpringBoot自动配置支持的模板引擎。同时还详细阐述了如何整合Thymeleaf。</p></blockquote><h1 id="SpringBoot-Web开发4-模板引擎"><a href="#SpringBoot-Web开发4-模板引擎" class="headerlink" title="SpringBoot Web开发4-模板引擎"></a>SpringBoot Web开发4-模板引擎</h1><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><blockquote><p>除了RESTWeb服务，您还可以使用SpringMVC来提供动态HTML内容。<br>SpringMVC支持多种模板技术，包括Thymelaf、FreeMarker和JSP。<br>此外，许多其他模板引擎也包含了它们自己的SpringMVC集成。</p></blockquote><p>SpringBoot自动配置支持的模板引擎有:</p><ul><li><a href="https://freemarker.apache.org/docs/">FreeMarker</a></li><li><a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine">Groovy</a></li><li><a href="https://www.thymeleaf.org/">Thymeleaf</a></li><li><a href="https://mustache.github.io/">Mustache</a></li></ul><h3 id="整合Thymeleaf"><a href="#整合Thymeleaf" class="headerlink" title="整合Thymeleaf"></a>整合Thymeleaf</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由自动配置原理知:</p><ol><li>开启了<code>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration</code>自动配置</li><li>属性绑定在<strong>ThymeleafProperties</strong>中，对应配置文件<code>spring.thymeleaf</code>内容</li><li>默认情况,模板页面在<code>classpath:/templates</code>文件夹下</li><li>默认情况,模板页面前缀<code>classpath:/templates/</code></li><li>默认情况,模板页面后缀<code>.html</code></li><li>达到效果: <code>classpath:/templates/</code> + 页面名 + <code>.html</code></li></ol><blockquote><p>目前大多数是前后分离开发,由专业的前端框架完成,模板引擎部分用处不大.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了SpringBoot Web开发中的模板引擎，包括SpringMVC所支持的多种模板技术，如Thymelaf、FreeMarker和JSP等，以及SpringBoot自动配置支持的模板引擎。同时还详细阐述了如何整合</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发5-错误处理</title>
    <link href="http://fu-jw.com/posts/41ac7873.html"/>
    <id>http://fu-jw.com/posts/41ac7873.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了SpringBoot Web中的错误处理机制，包括默认处理机制和SpringMVC的处理方式。并详细分析了SpringBoot错误原理以及它的配置类<code>ErrorMvcAutoConfiguration</code>，最后给出了最佳实践建议。</p></blockquote><h1 id="SpringBoot-Web开发5-错误处理"><a href="#SpringBoot-Web开发5-错误处理" class="headerlink" title="SpringBoot Web开发5-错误处理"></a>SpringBoot Web开发5-错误处理</h1><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="默认机制"><a href="#默认机制" class="headerlink" title="默认机制"></a>默认机制</h3><p>SpringBoot在<strong>web场景</strong>下,当应用程序发生错误或异常时,SpringBoot会自动应用<code>ErrorMvcAutoConfiguration</code>进行配置.</p><img src="https://image.fu-jw.com/img/2023/07/01/649f81ec7ae0a.webp"/><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Load before the main WebMvcAutoConfiguration so that the error View is available</span></span><br><span class="line"><span class="comment">// 在WebMvcAutoConfiguration自动装配之前</span></span><br><span class="line"><span class="meta">@AutoConfiguration(before = WebMvcAutoConfiguration.class)</span></span><br><span class="line"><span class="comment">// 条件:普通的servlet web类型</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="comment">// 条件:有Servlet和DispatcherServlet类</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class&#125;)</span></span><br><span class="line"><span class="comment">// 绑定配置文件:server.*和spring.mvc.*</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ServerProperties.class, WebMvcProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMvcAutoConfiguration</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两大处理机制:<br>机制一: <strong>SpringBoot</strong>会自适应处理错误,响应页面或<strong>JSON</strong>数据(内容协商)</p><img alt="同一请求-浏览器返回白页" src="https://image.fu-jw.com/img/2023/07/01/649ff3f00a98a.webp"/><img alt="同一请求-客户端返回JSON" src="https://image.fu-jw.com/img/2023/07/01/649ff431580c1.webp"/><img alt="同一请求-客户端也可设置返回XML" src="https://image.fu-jw.com/img/2023/07/01/649ff45dc52e3.webp"/><p>机制二: <strong>SpringMVC</strong>的错误处理机制依然保留,MVC处理不了,才会交给boot进行处理</p><img alt="SpringBoot错误处理机制" src="https://image.fu-jw.com/img/2023/07/03/64a22e201bcbb.webp"/><h3 id="SpringMVC处理错误"><a href="#SpringMVC处理错误" class="headerlink" title="SpringMVC处理错误"></a>SpringMVC处理错误</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试MVC的错误处理机制</span></span><br><span class="line"><span class="comment">   * 默认情况下--不处理错误:</span></span><br><span class="line"><span class="comment">   * 浏览器返回白页,因为请求头中: Accept:text/html</span></span><br><span class="line"><span class="comment">   * 移动端postman返回JSON.因为请求头中: (Accept:* 所有类型,优先JSON)</span></span><br><span class="line"><span class="comment">   * 自己处理错误: handleException()</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;testError&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">testError</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误出现</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;testError&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 自定义处理所有错误</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@ExceptionHandler</span> 可以标识一个方法, 默认只能处理这个类发生的指定错误</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@ControllerAdvice</span> AOP思想, 可以统一处理所有方法, 如 GlobalExceptionHandler.java</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;错误已发生,原因:&quot;</span> + e.getMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img alt="mvc处理错误" src="https://image.fu-jw.com/img/2023/07/03/64a232aac8fa8.png"/><p>统一错误处理:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span> <span class="comment">// 统一处理所有Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 自定义处理所有错误</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@ExceptionHandler</span> 可以标识一个方法, 默认只能处理这个类发生的指定错误</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@ControllerAdvice</span> AOP思想, 可以统一处理所有方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;统一处理,错误已发生,原因:&quot;</span> + e.getMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img alt="mvc统一处理错误" src="https://image.fu-jw.com/img/2023/07/03/64a232c9bbac2.png"/><h3 id="SpringBoot错误原理浅析"><a href="#SpringBoot错误原理浅析" class="headerlink" title="SpringBoot错误原理浅析"></a>SpringBoot错误原理浅析</h3><p>自动配置类<code>ErrorMvcAutoConfiguration</code>, 主要包含以下功能:</p><h4 id="注册组件-BasicErrorController"><a href="#注册组件-BasicErrorController" class="headerlink" title="注册组件: BasicErrorController"></a>注册组件: BasicErrorController</h4><p>这是一个默认的错误处理控制器,用于处理一般的错误请求.</p><p>可以在配置文件中配置:<code>server.error.path=/error</code>(默认值)<br>当发生错误以后,将SpringMVC不能处理的错误请求转发给<code>/error</code>进行处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">// 可以处理配置文件中:server.error.path 的映射</span></span><br><span class="line"><span class="comment">// 或者处理配置文件中:error.path 的映射</span></span><br><span class="line"><span class="comment">// 以上都没配置,就会将请求映射到: /error</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicErrorController</span> <span class="keyword">extends</span> <span class="title class_">AbstractErrorController</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会根据请求的<code>Accept</code>头部信息返回对应的错误响应,比如<strong>JSON</strong>,<strong>XML</strong>或<strong>HTML</strong>格式.<br><strong>内容协商机制</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;text/html&quot;</span></span><br><span class="line"><span class="comment">// 返回html页面</span></span><br><span class="line"><span class="meta">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">errorHtml</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求的状态码</span></span><br><span class="line">    HttpStatus status=getStatus(request);</span><br><span class="line">    Map&lt;String, Object&gt; model=Collections</span><br><span class="line">    .unmodifiableMap(getErrorAttributes(request,getErrorAttributeOptions(request,MediaType.TEXT_HTML)));</span><br><span class="line">    response.setStatus(status.value());</span><br><span class="line">    <span class="comment">// 得到解析的错误视图</span></span><br><span class="line">    ModelAndView modelAndView=resolveErrorView(request,response,status,model);</span><br><span class="line">    <span class="comment">// 返回上面解析的视图,或者新建一个error视图(SpringBoot默认有一个error页面,状态码999)</span></span><br><span class="line">    <span class="keyword">return</span>(modelAndView!=<span class="literal">null</span>)?modelAndView:<span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>,model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 ResponseEntity,即JSON数据</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt;error(HttpServletRequest request)&#123;</span><br><span class="line">    HttpStatus status=getStatus(request);</span><br><span class="line">    <span class="keyword">if</span>(status==HttpStatus.NO_CONTENT)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(status);</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; body=getErrorAttributes(request,getErrorAttributeOptions(request,MediaType.ALL));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(body,status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误视图解析:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、解析错误的自定义视图地址</span></span><br><span class="line">ModelAndView modelAndView=resolveErrorView(request,response,status,model);</span><br><span class="line"><span class="comment">//2、如果解析不到错误页面的地址，默认的错误页就是 error</span></span><br><span class="line"><span class="keyword">return</span>(modelAndView!=<span class="literal">null</span>)?modelAndView:<span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>,model);</span><br></pre></td></tr></table></figure><p><strong>1.解析错误视图:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">resolveErrorView</span><span class="params">(HttpServletRequest request,HttpServletResponse response,HttpStatus status,Map&lt;String, Object&gt; model)</span>&#123;</span><br><span class="line">  <span class="comment">// 遍历错误视图解析器:errorViewResolvers</span></span><br><span class="line">  <span class="keyword">for</span>(ErrorViewResolver resolver:<span class="built_in">this</span>.errorViewResolvers)&#123;</span><br><span class="line">    ModelAndView modelAndView=resolver.resolveErrorView(request,status,model);</span><br><span class="line">    <span class="keyword">if</span>(modelAndView!=<span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自动配置类,会将<strong>默认的错误视图解析器</strong>放在容器中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// 绑定配置文件中 web.* 和 web.mvc.*</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebProperties.class, WebMvcProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultErrorViewResolverConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Resources resources;</span><br><span class="line"></span><br><span class="line">  DefaultErrorViewResolverConfiguration(ApplicationContext applicationContext, WebProperties webProperties) &#123;</span><br><span class="line">    <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    <span class="built_in">this</span>.resources = webProperties.getResources();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnBean(DispatcherServlet.class)</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(ErrorViewResolver.class)</span></span><br><span class="line">  DefaultErrorViewResolver <span class="title function_">conventionErrorViewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在容器中放入默认错误视图解析器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultErrorViewResolver</span>(<span class="built_in">this</span>.applicationContext, <span class="built_in">this</span>.resources);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认的错误视图解析过程:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">resolveErrorView</span><span class="params">(HttpServletRequest request,HttpStatus status,Map&lt;String, Object&gt; model)</span>&#123;</span><br><span class="line">  <span class="comment">// 1. 获取状态码</span></span><br><span class="line">  <span class="comment">// 2. 根据状态码解析错误视图(如: 404 500 等)    </span></span><br><span class="line">  ModelAndView modelAndView=resolve(String.valueOf(status.value()),model);</span><br><span class="line">  <span class="comment">// 3. 状态码没有精确匹配,则模糊匹配(如:4xx 5xx, 注意只有这俩)</span></span><br><span class="line">  <span class="keyword">if</span>(modelAndView==<span class="literal">null</span>&amp;&amp;SERIES_VIEWS.containsKey(status.series()))&#123;</span><br><span class="line">    modelAndView=resolve(SERIES_VIEWS.get(status.series()),model);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的解析过程</span></span><br><span class="line"><span class="keyword">private</span> ModelAndView <span class="title function_">resolve</span><span class="params">(String viewName,Map&lt;String, Object&gt; model)</span>&#123;</span><br><span class="line">  <span class="comment">// 错误视图名: error/404 或 error/4xx    </span></span><br><span class="line">  String errorViewName=<span class="string">&quot;error/&quot;</span>+viewName;</span><br><span class="line">  TemplateAvailabilityProvider provider=<span class="built_in">this</span>.templateAvailabilityProviders.getProvider(errorViewName,<span class="built_in">this</span>.applicationContext);</span><br><span class="line">  <span class="keyword">if</span>(provider!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 有就返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(errorViewName,model);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有, 继续</span></span><br><span class="line">  <span class="keyword">return</span> resolveResource(errorViewName,model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续解析错误视图, 在静态资源目录下查找</span></span><br><span class="line"><span class="keyword">private</span> ModelAndView <span class="title function_">resolveResource</span><span class="params">(String viewName,Map&lt;String, Object&gt; model)</span>&#123;</span><br><span class="line">  <span class="comment">// 遍历四个静态资源目录:classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;,</span></span><br><span class="line">  <span class="comment">// &quot;classpath:/static/&quot;, &quot;classpath:/public/    </span></span><br><span class="line">  <span class="keyword">for</span>(String location:<span class="built_in">this</span>.resources.getStaticLocations())&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Resource resource=<span class="built_in">this</span>.applicationContext.getResource(location);</span><br><span class="line">      resource=resource.createRelative(viewName+<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(resource.exists())&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="keyword">new</span> <span class="title class_">HtmlResourceView</span>(resource),model);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.解析不到错误视图:</strong><br>精确状态码以及模糊状态码都没有匹配时,则映射到error视图</p><p>在template目录下创建<code>error.html</code>就会返回(注意:将上面统一错误处理注释)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">模板: error 页</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果:</p><img alt="error页" src="https://image.fu-jw.com/img/2023/07/03/64a259a289e8c.png"/><p><strong>如果error视图页没有:</strong></p><p>自动配置类<code>ErrorMvcAutoConfiguration</code>,在容器中放入了<code>error</code>组件,提供了默认白页功能:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;server.error.whitelabel&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@Conditional(ErrorTemplateMissingCondition.class)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WhitelabelErrorViewConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StaticView</span> <span class="variable">defaultErrorView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticView</span>();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(name = &quot;error&quot;)</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(name = &quot;error&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> View <span class="title function_">defaultErrorView</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultErrorView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the user adds @EnableWebMvc then the bean name view resolver from</span></span><br><span class="line">  <span class="comment">// WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment.</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> BeanNameViewResolver <span class="title function_">beanNameViewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BeanNameViewResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanNameViewResolver</span>();</span><br><span class="line">    resolver.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> resolver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建白页:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticView</span> <span class="keyword">implements</span> <span class="title class_">View</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MediaType</span> <span class="variable">TEXT_HTML_UTF8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaType</span>(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;html&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(StaticView.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">          <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> getMessage(model);</span><br><span class="line">      logger.error(message);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    response.setContentType(TEXT_HTML_UTF8.toString());</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">timestamp</span> <span class="operator">=</span> model.get(<span class="string">&quot;timestamp&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">message</span> <span class="operator">=</span> model.get(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">trace</span> <span class="operator">=</span> model.get(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (response.getContentType() == <span class="literal">null</span>) &#123;</span><br><span class="line">      response.setContentType(getContentType());</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&quot;</span>)</span><br><span class="line">            .append(<span class="string">&quot;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&quot;</span>)</span><br><span class="line">            .append(<span class="string">&quot;&lt;div id=&#x27;created&#x27;&gt;&quot;</span>)</span><br><span class="line">            .append(timestamp)</span><br><span class="line">            .append(<span class="string">&quot;&lt;/div&gt;&quot;</span>)</span><br><span class="line">            .append(<span class="string">&quot;&lt;div&gt;There was an unexpected error (type=&quot;</span>)</span><br><span class="line">            .append(htmlEscape(model.get(<span class="string">&quot;error&quot;</span>)))</span><br><span class="line">            .append(<span class="string">&quot;, status=&quot;</span>)</span><br><span class="line">            .append(htmlEscape(model.get(<span class="string">&quot;status&quot;</span>)))</span><br><span class="line">            .append(<span class="string">&quot;).&lt;/div&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (message != <span class="literal">null</span>) &#123;</span><br><span class="line">      builder.append(<span class="string">&quot;&lt;div&gt;&quot;</span>).append(htmlEscape(message)).append(<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (trace != <span class="literal">null</span>) &#123;</span><br><span class="line">      builder.append(<span class="string">&quot;&lt;div style=&#x27;white-space:pre-wrap;&#x27;&gt;&quot;</span>).append(htmlEscape(trace)).append(<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    response.getWriter().append(builder.toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><p>先尝试解析错误页, 解析失败则在静态资源目录下查找</p><ol><li><strong>解析</strong>一个错误页</li></ol><ul><li>如果发生了500、404、503、403 这些错误<ul><li>如果有模板引擎，默认在<code>classpath:/templates/error/精确码.html</code></li><li>如果没有模板引擎，在静态资源文件夹下找<code>精确码.html</code></li></ul></li><li>如果匹配不到<code>精确码.html</code>这些精确的错误页，就去找<code>5xx.html</code>, <code>4xx.html</code><strong>模糊匹配</strong><ul><li>如果有模板引擎，默认在<code>classpath:/templates/error/5xx.html</code></li><li>如果没有模板引擎，在静态资源文件夹下找<code>5xx.html</code></li></ul></li></ul><ol start="2"><li>如果模板引擎路径<code>templates</code>下有<code>error.html</code>页面, 就直接渲染</li></ol><h3 id="自定义错误响应"><a href="#自定义错误响应" class="headerlink" title="自定义错误响应"></a>自定义错误响应</h3><ul><li>自定义json响应<ul><li>使用@ControllerAdvice + @ExceptionHandler 进行统一异常处理</li></ul></li><li>自定义页面响应<ul><li>根据boot的错误页面规则，自定义页面模板</li></ul></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>前后分离<ul><li>后台发生的所有错误, <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>进行统一异常处理</li></ul></li><li>服务端页面渲染<ul><li>不可预知的错误,HTTP码表示的服务器端或客户端错误<ul><li>给<code>classpath:/templates/error/</code>下面，放常用精确的错误码页面。<code>500.html</code>，<code>404.html</code></li><li>给<code>classpath:/templates/error/</code>下面，放通用模糊匹配的错误码页面。 <code>5xx.html</code>，<code>4xx.html</code></li></ul></li><li>发生业务错误<ul><li><strong>核心业务</strong>, 每一种错误, 都应该代码控制, 跳转到自己<strong>定制的错误页</strong></li><li><strong>通用业务</strong>, <code>classpath:/templates/error.html</code>页面, 显示错误信息</li></ul></li></ul></li></ul><p>无论是返回页面或者JSON数据, 可用的<strong>Model</strong>数据都一样, 如下:<br><img alt="model" src="https://image.fu-jw.com/img/2023/07/03/64a2742fd9f6c.png"/></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了SpringBoot Web中的错误处理机制，包括默认处理机制和SpringMVC的处理方式。并详细分析了SpringBoot错误原理以及它的配置类&lt;code&gt;ErrorMvcAutoConfiguration&lt;/</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发6-嵌入式容器</title>
    <link href="http://fu-jw.com/posts/128d12a9.html"/>
    <id>http://fu-jw.com/posts/128d12a9.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了SpringBoot Web开发中的嵌入式容器。讲解了Servlet容器及其三大组件，介绍了嵌入式服务器Tomcat、Jetty、Undertow的自动配置原理及Tomcat容器创建的具体方法。最后，文章也示范了如何在项目中切换服务器。</p></blockquote><h1 id="SpringBoot-Web开发6-嵌入式容器"><a href="#SpringBoot-Web开发6-嵌入式容器" class="headerlink" title="SpringBoot Web开发6-嵌入式容器"></a>SpringBoot Web开发6-嵌入式容器</h1><h2 id="嵌入式容器"><a href="#嵌入式容器" class="headerlink" title="嵌入式容器"></a>嵌入式容器</h2><p>Servlet容器：管理、运行Servlet组件的环境，一般指服务器</p><p>Servlet三大组件:</p><ul><li>Servlet, 处理请求</li><li>Filter, 过滤请求</li><li>Listener, 监听请求</li></ul><h3 id="自动配置原理浅析"><a href="#自动配置原理浅析" class="headerlink" title="自动配置原理浅析"></a>自动配置原理浅析</h3><p>先从自动配置类开始</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration(after = SslAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="comment">// 生效条件:实现ServletRequest接口的Servlet请求</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRequest.class)</span></span><br><span class="line"><span class="comment">// 生效条件:是SERVLET类型的程序</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="comment">// 绑定配置文件, server.*</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span></span><br><span class="line"><span class="comment">// 批量导入一些嵌入式服务器类</span></span><br><span class="line"><span class="meta">@Import(&#123;ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span></span><br><span class="line"><span class="meta">        ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span></span><br><span class="line"><span class="meta">        ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span></span><br><span class="line"><span class="meta">        ServletWebServerFactoryConfiguration.EmbeddedUndertow.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryAutoConfiguration</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌入式的三大服务器:<code>Tomcat</code>、<code>Jetty</code>、<code>Undertow</code></p><ul><li>导入<code>Tomcat</code>、<code>Jetty</code>、<code>Undertow</code>都有条件注解(系统中有对应的类才行,导包即可)</li><li>默认<code>Tomcat</code>配置生效.<strong>web场景</strong>默认导入<code>spring-boot-starter-tomcat</code></li><li><code>Tomcat</code>配置生效后,会在容器中放入<code>TomcatServletWebServerFactory</code>组件,用于创建容器的工厂类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">  <span class="meta">@ConditionalOnClass(&#123;Servlet.class, Tomcat.class, UpgradeProtocol.class&#125;)</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmbeddedTomcat</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers)</span> &#123;</span><br><span class="line">      <span class="type">TomcatServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">      factory.getTomcatConnectorCustomizers().addAll(connectorCustomizers.orderedStream().toList());</span><br><span class="line">      factory.getTomcatContextCustomizers().addAll(contextCustomizers.orderedStream().toList());</span><br><span class="line">      factory.getTomcatProtocolHandlerCustomizers().addAll(protocolHandlerCustomizers.orderedStream().toList());</span><br><span class="line">      <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他容器...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>TomcatServletWebServerFactory</code>工厂类中,具体的创建方法:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 获取web服务器</span></span><br><span class="line"><span class="keyword">public</span> WebServer <span class="title function_">getWebServer</span><span class="params">(ServletContextInitializer...initializers)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.disableMBeanRegistry)&#123;</span><br><span class="line">  Registry.disableRegistry();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Tomcat容器</span></span><br><span class="line">Tomcat tomcat=<span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">File baseDir=(<span class="built_in">this</span>.baseDirectory!=<span class="literal">null</span>)?<span class="built_in">this</span>.baseDirectory:createTempDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line"><span class="keyword">for</span>(LifecycleListener listener:<span class="built_in">this</span>.serverLifecycleListeners)&#123;</span><br><span class="line">  tomcat.getServer().addLifecycleListener(listener);</span><br><span class="line">&#125;</span><br><span class="line">Connector connector=<span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="built_in">this</span>.protocol);</span><br><span class="line">connector.setThrowOnFailure(<span class="literal">true</span>);</span><br><span class="line">tomcat.getService().addConnector(connector);</span><br><span class="line">customizeConnector(connector);</span><br><span class="line">tomcat.setConnector(connector);</span><br><span class="line">tomcat.getHost().setAutoDeploy(<span class="literal">false</span>);</span><br><span class="line">configureEngine(tomcat.getEngine());</span><br><span class="line"><span class="keyword">for</span>(Connector additionalConnector:<span class="built_in">this</span>.additionalTomcatConnectors)&#123;</span><br><span class="line">  tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">&#125;</span><br><span class="line">prepareContext(tomcat.getHost(),initializers);</span><br><span class="line"><span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tomcat容器创建时机"><a href="#Tomcat容器创建时机" class="headerlink" title="Tomcat容器创建时机"></a>Tomcat容器创建时机</h3><p>SpringApplication.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String...args)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  refreshContext(context); <span class="comment">// 刷新上下文</span></span><br><span class="line">  afterRefresh(context,applicationArguments);</span><br><span class="line">  <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 刷新上下文</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.registerShutdownHook)&#123;</span><br><span class="line">    shutdownHook.registerApplicationContext(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新</span></span><br><span class="line">  refresh(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ConfigurableApplicationContext applicationContext)</span>&#123;</span><br><span class="line">  applicationContext.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>web场景</strong>下,<br>ServletWebServerApplicationContext.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span><span class="keyword">throws</span> BeansException,IllegalStateException&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 刷新</span></span><br><span class="line">    <span class="built_in">super</span>.refresh();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(RuntimeException ex)&#123;</span><br><span class="line">    WebServer webServer=<span class="built_in">this</span>.webServer;</span><br><span class="line">    <span class="keyword">if</span>(webServer!=<span class="literal">null</span>)&#123;</span><br><span class="line">      webServer.stop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 创建容器十二步</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span><span class="keyword">throws</span> BeansException,IllegalStateException&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor)&#123;</span><br><span class="line">    StartupStep contextRefresh=<span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备上下文内容</span></span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取刷新的bean工厂</span></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.准备上下文用到的bean工厂,如:类加载器,后置处理器</span></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 4.通过编程方式修改BeanFactory的配置，比如添加自定义的BeanDefinition，修改属性值，注册BeanPostProcessor等等。</span></span><br><span class="line">    <span class="comment">// 通过这种方式，开发人员可以对Spring容器进行更灵活和定制化的配置</span></span><br><span class="line">    <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">    postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.执行所有已注册的BeanFactoryPostProcessor的postProcessBeanFactory方法</span></span><br><span class="line">    StartupStep beanPostProcess=<span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">    <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.注册所有的BeanPostProcessor实例.</span></span><br><span class="line">    <span class="comment">// 允许开发人员在bean实例化和依赖注入的过程中对bean进行增强或定制</span></span><br><span class="line">    <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">    registerBeanPostProcessors(beanFactory);</span><br><span class="line">    beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.初始化上下文的消息资源</span></span><br><span class="line">    <span class="comment">// 消息资源用于国际化和本地化的目的，它可以根据不同的语言和区域设置，提供相应的文本消息</span></span><br><span class="line">    <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">    initMessageSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.初始化应用程序事件的多播器,使得应用程序能够对事件进行发布和监听</span></span><br><span class="line">    <span class="comment">// 事件机制是一种通信机制，用于在不同的组件之间传递消息和触发相应的处理逻辑</span></span><br><span class="line">    <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">    initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9.容器刷新过程中的一个回调方法，用于提供一个扩展点，让开发人员可以在容器刷新完成后执行一些自定义的逻辑</span></span><br><span class="line">    <span class="comment">// 可以在onRefresh方法中执行一些额外的初始化操作、启动定时任务、注册额外的bean等</span></span><br><span class="line">    <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">    onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10.向应用程序上下文注册事件监听器</span></span><br><span class="line">    <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">    registerListeners();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 11.在Bean工厂初始化的最后阶段，完成所有注册的Bean的初始化过程</span></span><br><span class="line">    <span class="comment">// Bean工厂中所有已注册的Bean的名称 --&gt;</span></span><br><span class="line">    <span class="comment">// 遍历所有的Bean名称获取对应的Bean定义 --&gt;</span></span><br><span class="line">    <span class="comment">// 根据Bean定义的信息，进行实例化、依赖注入、初始化等操作 --&gt;</span></span><br><span class="line">    <span class="comment">// 若Bean定义中有初始化方法（例如通过@PostConstruct注解标记的方法），则调用该方法进行额外的初始化逻辑</span></span><br><span class="line">    <span class="comment">// 若Bean定义中有销毁方法（例如通过@PreDestroy注解标记的方法），则在容器关闭时调用该方法进行资源释放等操作</span></span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12.容器刷新的最后阶段，执行一些额外的逻辑以完成刷新过程</span></span><br><span class="line">    <span class="comment">// 清理初始化过程中一系列操作使用到的资源缓存</span></span><br><span class="line">    <span class="comment">// 初始化LifecycleProcessor</span></span><br><span class="line">    <span class="comment">// 启动所有实现了Lifecycle接口的bean</span></span><br><span class="line">    <span class="comment">// 发布ContextRefreshedEvent事件</span></span><br><span class="line">    <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">    finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(BeansException ex)&#123;</span><br><span class="line">    <span class="keyword">if</span>(logger.isWarnEnabled())&#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span>+</span><br><span class="line">      <span class="string">&quot;cancelling refresh attempt: &quot;</span>+ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">    <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">    resetCommonCaches();</span><br><span class="line">    contextRefresh.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切换服务器"><a href="#切换服务器" class="headerlink" title="切换服务器"></a>切换服务器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Exclude the Tomcat dependency --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Use Jetty instead --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了SpringBoot Web开发中的嵌入式容器。讲解了Servlet容器及其三大组件，介绍了嵌入式服务器Tomcat、Jetty、Undertow的自动配置原理及Tomcat容器创建的具体方法。最后，文章也示范了如</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>AList+云盘+LskyPro 搭建大容量图床</title>
    <link href="http://fu-jw.com/posts/4140de30.html"/>
    <id>http://fu-jw.com/posts/4140de30.html</id>
    <published>2023-06-30T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了如何利用AList，云盘和LskyPro搭建大容量图床，避免了高额图床管理费，增加了访问速度，图片自我管理。提及了搭建过程，包括环境准备，AList和WebDAV服务的搭建，以及Lsky的安装和配置。</p></blockquote><h1 id="AList-云盘-LskyPro-搭建大容量图床"><a href="#AList-云盘-LskyPro-搭建大容量图床" class="headerlink" title="AList+云盘+LskyPro 搭建大容量图床"></a>AList+云盘+LskyPro 搭建大容量图床</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://www.lsky.pro/">兰空官网:</a></p><blockquote><p>兰空图床可以帮您保管大量无处安放的图片，数据可以自由选择储存驱动，支持主流第三方储存。<br>作为一个助手，它不仅可以将您把图片以指定规则存放在指定位置，还有更多强大的功能来帮助您处理这些图片。</p></blockquote><p><a href="https://alist.nn.ci/zh/">AList:</a></p><blockquote><p>一个支持多种存储，支持网页浏览和 WebDAV 的文件列表程序<br>支持多个存储提供商，包括本地存储、阿里云盘、OneDrive、Google Drive 等，且易于拓展<br>支持所有 WebDAV 存储，这是一种用于访问文件的标准</p></blockquote><p>云盘:<br>本文以<a href="https://cloud.189.cn/web/login.html">天翼云盘</a>为例, 免费 30 GB 的空间, 支持 WebDAV</p><p><a href="https://image.fu-jw.com/">自建图床</a><br><img src="https://image.fu-jw.com/img/2023/06/30/649ec9d66f54d.webp" alt="Snipaste_2023-06-30_19-51-10.png"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>无需缴高额图床管理费</li><li>访问速度取决于自建服务器的配置</li><li>图片自治, 自己管理图片, 不用担心图床跑路或被墙</li></ul><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><blockquote><p>前提:<br>需要公网服务器和已备案域名<br>服务器安装宝塔, Docker, Nginx</p></blockquote><h3 id="1-AList"><a href="#1-AList" class="headerlink" title="1. AList"></a>1. AList</h3><p>使用 Docker 安装</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=<span class="string">&quot;alist&quot;</span> xhofe/alist:latest</span><br></pre></td></tr></table></figure><blockquote><p>注意: 端口号是: 5244, 如果使用云服务器如阿里云, 腾讯云等, 记得开放此端口.</p></blockquote><h3 id="2-WebDAV-服务"><a href="#2-WebDAV-服务" class="headerlink" title="2. WebDAV 服务"></a>2. WebDAV 服务</h3><ul><li>注册登录<a href="https://cloud.189.cn/web/login.html">天翼云盘</a></li><li>在个人网盘中创建 <code>Pics</code> 文件夹</li><li>在 AList 中将该文件夹挂载到路径 <code>/image</code> (在 AList 显示的路径)</li></ul><img src=" https://image.fu-jw.com/img/2023/06/30/649ed7ee1dce7.webp"/><p>参考配置:<br><img src=" https://image.fu-jw.com/img/2023/06/30/649ed98c2c787.webp"/><br><img src=" https://image.fu-jw.com/img/2023/06/30/649edb3e4e9a2.webp"/></p><p><a href="https://alist.nn.ci/zh/guide/drivers/189.html">参考文档</a></p><h3 id="3-Lsky"><a href="#3-Lsky" class="headerlink" title="3. Lsky"></a>3. Lsky</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建容器并启动（宿主机4003端口可自行更改）  </span></span><br><span class="line">sudo docker run -d --name lskypro --restart unless-stopped -p 4003:80 -v /data/lskypro:/var/www/html coldpig/lskypro-docker:latest </span><br></pre></td></tr></table></figure><h4 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h4><p>注意: 如果在 Nginx 配置中开启了 HTTPS ，需要执行以下命令修改图床项目源码，否则前端页面布局将被打乱</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it lskypro sed -i <span class="string">&#x27;32 a \\\Illuminate\\Support\\Facades\\URL::forceScheme(&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;https&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;);&#x27;</span> /var/www/html/app/Providers/AppServiceProvider.php</span><br></pre></td></tr></table></figure><p>假设图床服务的域名为 <code>image.domain.com</code>，AList 部署在本地端口 <code>5244</code>，在 <code>nginx.conf</code> 中添加如下配置项：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">listen 443 ssl http2;</span><br><span class="line">    server_name image.domain.com;</span><br><span class="line">    index index.php index.html index.htm default.php default.htm default.html;</span><br><span class="line">    root /www/wwwroot/image.domain.com;</span><br><span class="line"></span><br><span class="line">    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则</span><br><span class="line">    #error_page 404/404.html;</span><br><span class="line">    ssl_certificate    /www/server/panel/vhost/cert/image.domain.com/fullchain.pem;</span><br><span class="line">    ssl_certificate_key    /www/server/panel/vhost/cert/image.domain.com/privkey.pem;</span><br><span class="line">    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    add_header Strict-Transport-Security &quot;max-age=31536000&quot;;</span><br><span class="line">    error_page 497  https://$host$request_uri;</span><br><span class="line"></span><br><span class="line">    #SSL-END</span><br><span class="line"></span><br><span class="line">    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改</span><br><span class="line">    #error_page 404 /404.html;</span><br><span class="line">    #error_page 502 /502.html;</span><br><span class="line">    #ERROR-PAGE-END</span><br><span class="line"></span><br><span class="line">    #PHP-INFO-START  PHP引用配置，可以注释或修改</span><br><span class="line">    include enable-php-00.conf;</span><br><span class="line">    #PHP-INFO-END</span><br><span class="line"></span><br><span class="line">    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效</span><br><span class="line">    include /www/server/panel/vhost/rewrite/image.domain.com.conf;</span><br><span class="line">    #REWRITE-END</span><br><span class="line"></span><br><span class="line">    #禁止访问的文件或目录</span><br><span class="line">    # 转发图床服务请求</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Range $http_range;</span><br><span class="line">      proxy_set_header If-Range $http_if_range;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        client_max_body_size 20000m;</span><br><span class="line">      # 转发端口 4003 与上面设定的宿主机端口保持一致</span><br><span class="line">        proxy_pass http://IP:4003;</span><br><span class="line">        proxy_read_timeout 600s;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    # 转发 AList 图片直链访问请求</span><br><span class="line">    location /img &#123;</span><br><span class="line">        proxy_pass http://IP:5244/d/image;</span><br><span class="line">        proxy_read_timeout 600s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #禁止在证书验证目录放入敏感文件</span><br><span class="line">    if ( $uri ~ &quot;^/\.well-known/.*\.(php|jsp|py|js|css|lua|ts|go|zip|tar\.gz|rar|7z|sql|bak)$&quot; ) &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line">    access_log  /www/wwwlogs/image.domain.com.log;</span><br><span class="line">    error_log  /www/wwwlogs/image.domain.com.error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lsky-数据库配置"><a href="#Lsky-数据库配置" class="headerlink" title="Lsky 数据库配置"></a>Lsky 数据库配置</h4><p>以上步骤完成后，浏览器访问图床服务域名可进入如下图所示的配置页面。配置页面将引导我们设置数据库服务，为了减轻工作量，我们直接使用本地 SQLite 数据库，数据库路径留空即可（将自动在服务根目录的 <code>database</code> 目录下创建 <code>database.sqlite</code> 文件），同时需要设定管理员邮箱和登录密码。<br><img src=" https://image.fu-jw.com/img/2023/06/30/649edebe28bcb.webp"/><br><img src=" https://image.fu-jw.com/img/2023/06/30/649edece60c02.webp"/></p><h4 id="设置存储策略"><a href="#设置存储策略" class="headerlink" title="设置存储策略"></a>设置存储策略</h4><img src=" https://image.fu-jw.com/img/2023/06/30/649edffb7426c.webp"/><p>参考配置:<br><img src=" https://image.fu-jw.com/img/2023/06/30/649ee183cdadf.webp"/></p><p>默认存储策略为本地存储，为了不占用服务器空间，我们这里使用 AList 提供的 WebDAV 服务创建一个新的存储策略，配置项如表所示，其中访问域名即为图片直链对应的域名和路径。</p><p>注意: 设置 WebDAV 为默认存储策略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了如何利用AList，云盘和LskyPro搭建大容量图床，避免了高额图床管理费，增加了访问速度，图片自我管理。提及了搭建过程，包括环境准备，AList和WebDAV服务的搭建，以及Lsky的安装和配置。&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    <category term="教程" scheme="http://fu-jw.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="图床" scheme="http://fu-jw.com/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot日志</title>
    <link href="http://fu-jw.com/posts/4275e528.html"/>
    <id>http://fu-jw.com/posts/4275e528.html</id>
    <published>2023-06-13T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了SpringBoot项目中日志的使用方法和操作步骤。包括默认日志的输出格式，如何修改默认格式，日志级别的设定，分组设定，文件输出及归档与切割。文章也提到日志系统的自定义配置以及如何切换日志组合，并且提供了日志使用的最佳实践。</p></blockquote><h1 id="SpringBoot日志"><a href="#SpringBoot日志" class="headerlink" title="SpringBoot日志"></a>SpringBoot日志</h1><blockquote><p>我的<a href="https://github.com/fu-jw/spring-tutorial">SpringBoot项目</a>第三个模块</p></blockquote><p>在前面<a href="https://blog.fu-jw.com/posts/4ccc97e8.html">SpringBoot快速入门</a>中我们知道,</p><p>每个SpringBoot项目都会依赖<strong>核心启动器</strong>:<code>spring-boot-starter</code>, 核心启动器会依赖:<code>spring-boot-starter-logging</code>实现日志功能</p><p><code>spring-boot-starter-logging</code>依赖<code>Logback</code>的日志实现和<code>SLF4J</code>桥接器,将其他日志实现桥接到<code>SLF4J</code></p><p>即<code>SLF4J</code>+<code>Logback</code>的日志组合.</p><!-- ![SpringBoot日志依赖](https://s2.loli.net/2023/06/15/Rtsyneul2bhIKNr.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7b539f42d.webp"/><details> <summary><strong><span style="color: red; ">为什么日志不用SpringBoot的自动配置???</span></strong></summary><strong>日志是系统启动就要使用</strong>,<strong>xxxAutoConfiguration</strong>是系统启动好了以后放好的组件,后来用的.<br>日志是利用<strong>监听器机制</strong>配置好的,<strong>ApplicationListener</strong></details><h2 id="默认日志"><a href="#默认日志" class="headerlink" title="默认日志"></a>默认日志</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2023-06-12T20:57:23.829+08:00  INFO 5232 --- [           main] com.fredo.Main                           : Starting Main using Java 17.0.2 with PID 5232</span><br><span class="line">2023-06-12T20:57:23.837+08:00  INFO 5232 --- [           main] com.fredo.Main                           : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2023-06-12T20:57:25.094+08:00  INFO 5232 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br></pre></td></tr></table></figure><p>默认输出格式：</p><ul><li>时间和日期：毫秒级精度</li><li>日志级别：ERROR, WARN, INFO, DEBUG, or TRACE.</li><li>进程 ID</li><li>—： 消息分割符</li><li>线程名： 使用[]包含</li><li>Logger 名： 通常是产生日志的类名</li><li>消息： 日志记录的内容</li></ul><!-- ![SpringBoot日志默认值](https://s2.loli.net/2023/06/16/EiSUmc3tWpYnea8.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7bc000895.webp"/><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;logging.pattern.console&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.String&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Appender pattern for output to the console. Supported only with the default Logback setup.&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.boot.context.logging.LoggingApplicationListener&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSXXX&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="修改格式"><a href="#修改格式" class="headerlink" title="修改格式"></a>修改格式</h2><p>在SpringBoot的配置文件<strong>application.properties</strong>中直接修改即可:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; ==== %msg%n</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2023-06-12 21:19:29.634 [main] INFO  com.fredo.Main ==== Starting Main using Java 17.0.2 with PID 11216</span><br><span class="line">2023-06-12 21:19:29.639 [main] INFO  com.fredo.Main ==== No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2023-06-12 21:19:30.922 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer ==== Tomcat initialized with port(s): 8080 (http)</span><br></pre></td></tr></table></figure><p><strong>简单方便</strong></p><p>也可以单独文件配置<code>logback</code>, <strong>优先级高于SpringBoot的配置</strong><br>默认在<strong>classpath</strong>中依次寻找<strong>logback-spring.xml, logback-spring.groovy, logback.groovy, logback.xml</strong>文件</p><p>还可以在SpringBoot配置文件中指定文件位置</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">logging.config=classpath:logback-bak.xml</span><br></pre></td></tr></table></figure><h2 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h2><p>在每个类中添加代码:<br><code>Logger log = LoggerFactory.getLogger(getClass());</code></p><p>或者添加<code>lombok</code>依赖, 在类上直接使用<code>@Slf4j</code>注解即可代替上面代码</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在想要打印日志的位置使用即可<br><code>log.info(&quot;...&quot;);</code></p><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>由低到高：</p><ul><li>ALL: 开启日志打印</li><li>TRACE: 可跟踪打印框架底层信息</li><li>DEBUG: 调试信息</li><li>INFO: 普通信息</li><li>WARN: 系统的告警信息</li><li>ERROR: 系统的错误信息,异常信息</li><li>FATAL: 可能导致系统崩溃的严重信息</li><li>OFF: 关闭日志打印</li></ul><p>注意：</p><ul><li><code>Logback</code>没有<code>FATAL</code>级别, 对应的是<code>ERROR</code></li><li><strong>高级别包含低级别的所有信息</strong></li><li>SpringBoot日志默认级别是<code>INFO</code></li></ul><blockquote><p>默认所有日志没有精确指定级别就使用<strong>root</strong>的默认级别:<br>logging.level.root&#x3D;info</br><br>精确调整某个包下的日志级别<br>logging.level.com.fredo.logging.controller&#x3D;debug<br>logging.level.com.fredo.logging.service&#x3D;debug</p></blockquote><h2 id="日志分组"><a href="#日志分组" class="headerlink" title="日志分组"></a>日志分组</h2><p>在给不同包下的类定义日志级别时,还可以自定义分组,以组为单位划分日志级别</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">logging.group.组名=包名</span><br><span class="line">logging.level.组名=日志级别</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">logging.group.tomcat=org.apache.catalina,org.apache.coyote,org.apache.tomcat</span><br><span class="line">logging.level.tomcat=trace</span><br></pre></td></tr></table></figure><p>SpringBoot 预定义两个组</p><table><thead><tr><th>Name</th><th>Loggers</th></tr></thead><tbody><tr><td>web</td><td>org.springframework.core.codec,</br> org.springframework.http,</br> org.springframework.web,</br> org.springframework.boot.actuate.endpoint.web,</br> org.springframework.boot.web.servlet.ServletContextInitializerBeans</td></tr><tr><td>sql</td><td>org.springframework.jdbc.core,</br> org.hibernate.SQL,</br> org.jooq.tools.LoggerListener</td></tr></tbody></table><h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p>SpringBoot默认只把日志写在控制台,如果想额外记录到文件,<br>可以在<code>application.properties</code>中添加<code>logging.file.name</code> or <code>logging.file.path</code>配置项</p><table><thead><tr><th>logging.file.name</th><th>logging.file.path</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td>-</td><td>-</td><td></td><td>仅控制台输出</td></tr><tr><td>指定</td><td>-</td><td>my.log</td><td>写入指定文件。可以加路径</td></tr><tr><td>-</td><td>指定</td><td>&#x2F;var&#x2F;log</td><td>写入指定目录，文件名为<code>spring.log</code></td></tr><tr><td>指定</td><td>指定</td><td></td><td>以<code>logging.file.name</code>为准(path无效)</td></tr></tbody></table><h3 id="归档与切割"><a href="#归档与切割" class="headerlink" title="归档与切割"></a>归档与切割</h3><blockquote><p>归档：每天的日志单独存到一个文档中<br>切割：每个文件10MB,超过大小切割成另外一个文件</p></blockquote><p>每天的日志应该独立分割出来存档.如果使用<code>Logback</code>(SpringBoot默认日志实现),<br>可以通过<code>application.properties/yaml</code>文件指定日志滚动规则</p><p>如果是其他日志系统,需要自行配置(添加<code>log4j2.xml</code>或<code>log4j2-spring.xml</code>)</p><p>滚动规则设置如下:</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td><strong>logging.logback.rollingpolicy.file-name-pattern</strong></td><td>日志存档的文件名格式（默认值：<strong>${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz</strong> ）</td></tr><tr><td><strong>logging.logback.rollingpolicy.clean-history-on-start</strong></td><td>应用启动时是否清除以前存档（默认值：<strong>false</strong>）</td></tr><tr><td><strong>logging.logback.rollingpolicy.max-file-size</strong></td><td>存档前，每个日志文件的最大大小（默认值：<strong>10MB</strong></td></tr><tr><td><strong>logging.logback.rollingpolicy.total-size-cap</strong></td><td>日志文件被删除之前，可以容纳的最大大小（默认值：0B）。设置<strong>1GB</strong>则磁盘存储超过<strong>1GB</strong>日志后就会删除旧日志文件</td></tr><tr><td><strong>logging.logback.rollingpolicy.max-history</strong></td><td>日志文件保存的最大天数(默认值：<strong>7</strong>)</td></tr></tbody></table><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>通常配置<code>application.properties</code>就够了.当然也可以自定义. 比如:</p><table><thead><tr><th>日志系统</th><th>自定义文件</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy</td></tr><tr><td>Log4j2</td><td>log4j2-spring.xml or log4j2.xml</td></tr><tr><td>JUL</td><td>logging.properties</td></tr></tbody></table><p>建议在日志配置中使用<code>-spring</code>变量(比如<code>logback-spring.xml</code>而不是<code>logback.xml</code>).<br>如果使用标准配置文件, <code>spring</code>无法完全控制日志初始化</p><h2 id="切换日志组合"><a href="#切换日志组合" class="headerlink" title="切换日志组合"></a>切换日志组合</h2><p>需要排除SpringBoot自带的日志</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>log4j2</code>支持<code>yaml</code>和<code>json</code>格式的配置文件</p><table><thead><tr><th>格式</th><th>依赖</th><th>文件名</th></tr></thead><tbody><tr><td>YAML</td><td>com.fasterxml.jackson.core:jackson-databind + com.fasterxml.jackson.dataformat:jackson-dataformat-yaml</td><td>log4j2.yaml + log4j2.yml</td></tr><tr><td>JSON</td><td>com.fasterxml.jackson.core:jackson-databind</td><td>log4j2.json + log4j2.jsn</td></tr></tbody></table><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>导入任何第三方框架,先排除它的日志包,因为SpringBoot底层控制好了日志</li><li>修改<code>application.properties</code>配置文件,就可以调整日志的所有行为.如果不够,可以编写日志框架自己的配置文件放在类路径下就行,比如<code>logback-spring.xml</code>,<code>log4j2-spring.xml</code></li><li>如需<strong>对接专业日志系统</strong>,也只需要把<code>logback</code>记录的日志配置文件导入<code>kafka</code>之类的中间件即可,这和SpringBoot没关系,都是日志框架自己的配置,修改配置文件即可</li><li>业务中使用slf4j-api记录日志</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了SpringBoot项目中日志的使用方法和操作步骤。包括默认日志的输出格式，如何修改默认格式，日志级别的设定，分组设定，文件输出及归档与切割。文章也提到日志系统的自定义配置以及如何切换日志组合，并且提供了日志使用的</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java日志体系</title>
    <link href="http://fu-jw.com/posts/c3b98719.html"/>
    <id>http://fu-jw.com/posts/c3b98719.html</id>
    <published>2023-06-12T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了Java的日志体系，包括日志的含义、用途和重要性。涵盖了几种常见的日志框架如Log4j、JUL、JCL、SLF4J、Logback和Log4j2的详细介绍，包括它们的优势、劣势和工作机制。推荐使用SLF4J做日志门面，配合Logback或Log4j2做日志实现。</p></blockquote><h1 id="Java日志体系"><a href="#Java日志体系" class="headerlink" title="Java日志体系"></a>Java日志体系</h1><p>日志记录了系统行为的时间, 地点, 状态等相关信息, 能够帮助我们了解并监控系统状态,<br>在发生错误或者接近某种危险状态时能及时提醒我们处理, 同时在系统产生问题, 能够帮助我们快速定位, 诊断问题.</p><p>在生产环境中日志可能是我们<strong>了解系统运行状况的唯一方式</strong>, 其重要性无需赘述<br>总结如下优点:</p><ul><li>记录系统行为</li><li>监控系统状态</li><li>提示系统风险</li><li>定位系统问题</li></ul><h2 id="System-out"><a href="#System-out" class="headerlink" title="System.out"></a>System.out</h2><p>同样可以打印信息, 为什么不用<code>System.out.print(&quot;&quot;)</code>?</p><ol><li>难定位<br><code>System.out.print</code>输出的日志只打印在控制台, 没有存储到一个日志文件中, 且格式不统一, 在生产环境这样打印出来很难定位信息, 意义不大.</li><li>性能弱<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    write(String.valueOf(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            textOut.write(s);</span><br><span class="line">            textOut.flushBuffer();</span><br><span class="line">            charOut.flushBuffer();</span><br><span class="line">            <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">&#x27;\n&#x27;</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>由上面的源码可以看出<code>print</code>的方法实现是由<code>synchronized</code>包裹的同步代码块<br>不能异步打印日志, 在<strong>高并发</strong>的情况下, 会严重<strong>影响性能</strong></li></ol><p><strong>阿里巴巴Java开发手册:</strong></p><blockquote><p>【强制】 应用中不可直接使用日志系统（ Log4j、 Logback） 中的 API，而应依赖使用日志框架（ SLF4J、 JCL–Jakarta Commons Logging） 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一<br>【强制】 生产环境禁止直接使用 System.out 或 System.err 输出日志或使用e.printStackTrace()打印异常堆栈<br>【强制】 在日志输出时，字符串变量之间的拼接使用占位符的方式<br>【强制】 对于 trace&#x2F;debug&#x2F;info 级别的日志输出，必须进行日志级别的开关判断</p></blockquote><h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><p>Log for Java</p><p>Ceki Gülcü于2001年发布了Log4j, 并将其捐献给Apache软件基金会, 成为Apache基金会的顶级项目.<br>Apache基金会最早实现的一套日志框架, 通过使用<code>Log4j</code></p><ul><li>可以<strong>控制日志信息输送的目的地</strong>是控制台, 文件等</li><li>可以控制每一条日志的<strong>输出格式</strong></li><li>通过定义每一条<strong>日志信息的级别</strong>, 我们能够更加细致地控制日志的生成过程</li><li>可以通过一个<strong>配置文件</strong>来灵活地进行配置, 而不需要修改应用的代码 ☆☆</li></ul><p><code>Log4j</code>主要由<code>Loggers</code>(日志记录器), <code>Appenders</code>(输出端), <code>Layout</code>(格式化).</p><ul><li><code>Loggers</code>控制日志输出级别与日志是否输出</li><li><code>Appenders</code>指定日志的输出方式(输出到控制台或文件等)</li><li><code>Layout</code>控制日志的输出格式</li></ul><blockquote><p>2015年9月, Apache软件基金业宣布, Log4j不再维护, 建议所有相关项目升级到Log4j2.</p></blockquote><h2 id="JUL"><a href="#JUL" class="headerlink" title="JUL"></a>JUL</h2><p>Java Util Logging</p><p>SUN公司在JDK1.4发布的Java原生的日志框架, 使用时不需要另外引用第三方的类库, 相对其他的框架使用方便</p><ol><li>初始化<code>LogManager</code><ol><li><code>LogManager</code>加载logging.properties配置</li><li>添加<code>Logger</code>到<code>LogManager</code></li></ol></li><li>从<code>LogManager</code>中获取<code>Logger</code></li><li>设置级别<code>Level</code>, 并指定日志记录<code>LogRecord</code></li><li><code>Filter</code>提供日志级别之外更细粒度的控制</li><li><code>Handler</code>是用来处理日志输出位置</li><li><code>Formatter</code>用来格式化LogRecord</li></ol><!-- ![JUL流程](https://s2.loli.net/2023/06/13/bCoUrAMwVqHFGz7.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f79a49ed5f.webp"/><h2 id="JCL"><a href="#JCL" class="headerlink" title="JCL"></a>JCL</h2><p>Jakarta Commons Logging</p><blockquote><p>JUL的api与log4j是完全不同的(参数只接受string).由于日志系统没有互相关联,彼此没有约定,不同人的代码使用不同日志,替换和统一也就变成了一件非常棘手的事情.<br>那我们该如何解决这个问题呢?<br>抽象出一个接口层,对每个日志实现都适配或者转接,这样这些提供给别人的库都直接使用抽象层即可,以后需要调用的时候,就调用这些接口.</p></blockquote><p>Apache基金下Jakarta小组开发的通用日志API</p><p>主要功能是给<strong>所有的日志实现</strong>提供一个<strong>统一接口</strong>, 本身也提供日志实现(SimpleLog),但是很弱一般不用.<br>常见的日志实现如:最早的<strong>Log4j</strong>以及JDK自带的<strong>JUL</strong>等</p><!-- ![JCL](https://s2.loli.net/2023/06/13/EZ62fIKGMwTsRDn.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f79de6b8b2.webp"/><p>日志门面的好处:</p><ul><li><strong>面向接口编程</strong>  解耦合</li><li>可灵活切换日志框架</li><li>统一日志API方便使用</li><li>统一日志配置和管理</li></ul><blockquote><p>由于设计缺陷,只支持当时主流的几个日志实现,不利于其他日志的使用(需修改源码),现已淘汰!!!</p></blockquote><h2 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h2><blockquote><p><code>Log4j</code>的作者觉得<code>JCL</code>不好用,自己又写了一个新的接口api,就是<code>SLF4J</code>,<br>并且为了追求更极致的性能,新增了一套日志的实现,就是<code>logback</code></p></blockquote><p>Simple Logging Facade For Java</p><p><code>SLF4J</code>主要给Java日志访问提供一套标准,规范的API框架.</p><p>目前市面最流行的日志门面,主要功能:</p><ul><li>日志框架的绑定</li><li>日志框架的桥接</li></ul><h3 id="SLF4J的各种组合"><a href="#SLF4J的各种组合" class="headerlink" title="SLF4J的各种组合"></a>SLF4J的各种组合</h3><!-- ![SLF4J](https://s2.loli.net/2023/06/14/q1GbgIwUevMZ8WA.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7a7907f73.webp"/>需对应的适配器<ul><li><p>SLF4J unbound:没有绑定实现,则只有接口,没有日志功能</p></li><li><p>SLF4J bound to logback:logback是后出现的日志实现,实现了SLF4J接口,可直接搭配使用</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SLF4J + logback 组合结果(黑色字体):</span><br><span class="line">20:24:32.167 [main] ERROR com.fredo.slf4j.SLF4JTest -- error</span><br><span class="line">20:24:32.172 [main] WARN com.fredo.slf4j.SLF4JTest -- warn</span><br><span class="line">20:24:32.172 [main] INFO com.fredo.slf4j.SLF4JTest -- info</span><br><span class="line">20:24:32.172 [main] ERROR com.fredo.slf4j.SLF4JTest -- 出现异常:java.lang.ArithmeticException: / by zero</span><br><span class="line"></span><br><span class="line">注意:注释slf4j-simple, 并且不要排除SpringBoot内置的日志实现:logback</span><br></pre></td></tr></table></figure></li><li><p>SLF4J bound to reload4j:reload4j是先出现的日志实现,没有实现了SLF4J接口,需配合适配器使用</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SLF4J + log4j 组合结果:</span><br><span class="line"> 2023-06-11 20:38:19.738 error</span><br><span class="line"> 2023-06-11 20:38:19.739 warn</span><br><span class="line"> 2023-06-11 20:38:19.739 info</span><br><span class="line"> 2023-06-11 20:38:19.739 debug</span><br><span class="line"> 2023-06-11 20:38:19.740 trace</span><br><span class="line"> 2023-06-11 20:38:19.741 出现异常:java.lang.ArithmeticException: / by zero</span><br><span class="line"></span><br><span class="line"> 注意:需要适配器:slf4j-log4j12以及log4j对应的配置文件</span><br></pre></td></tr></table></figure></li><li><p>SLF4J bound to JUL:JUL是先出现的日志实现,没有实现了SLF4J接口,需适配器使用</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SLF4J + JUL 组合结果(红色字体):</span><br><span class="line"> 6月 11, 2023 20:42:46 上午 com.fredo.slf4j.SLF4JTest test01</span><br><span class="line"> SEVERE: error</span><br><span class="line"> 6月 11, 2023 20:42:46 上午 com.fredo.slf4j.SLF4JTest test01</span><br><span class="line"> WARNING: warn</span><br><span class="line"> 6月 11, 2023 20:42:46 上午 com.fredo.slf4j.SLF4JTest test01</span><br><span class="line"> INFO: info</span><br><span class="line"> 6月 11, 2023 20:42:46 上午 com.fredo.slf4j.SLF4JTest test01</span><br><span class="line"> SEVERE: 出现异常:java.lang.ArithmeticException: / by zero</span><br><span class="line"></span><br><span class="line"> 注意:JDK默认自带无需依赖,但需要对应的适配器:slf4j-jdk14</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SLF4J bound to simple:simple是后出现的日志实现,实现了SLF4J接口,可直接搭配使用</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SLF4J + SLF4J-Simple 组合结果(红色字体):</span><br><span class="line"> [main] ERROR com.fredo.slf4j.SLF4JTest - error</span><br><span class="line"> [main] WARN com.fredo.slf4j.SLF4JTest - warn</span><br><span class="line"> [main] INFO com.fredo.slf4j.SLF4JTest - info</span><br><span class="line"> [main] ERROR com.fredo.slf4j.SLF4JTest - 出现异常:java.lang.ArithmeticException: / by zero</span><br><span class="line"></span><br><span class="line"> 注意:需要提前排除:logback.SpringBoot默认的日志实现</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">     &lt;exclusions&gt;</span><br><span class="line">         &lt;exclusion&gt;</span><br><span class="line">             &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">             &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">         &lt;/exclusion&gt;</span><br><span class="line">     &lt;/exclusions&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>SLF4J bound to nop:nop是日志开关,关闭日志实现,不打印日志</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SLF4J + slf4j-nop 组合结果:</span><br><span class="line"> 无任何打印(slf4j-nop关闭了日志打印)</span><br><span class="line"></span><br><span class="line"> 注意:提前排除SpringBoot默认自带的logback日志实现.</span><br></pre></td></tr></table></figure></li></ul><p>小结一下:</p><ul><li>添加依赖:<code>slf4j-api</code>,使用<code>sl4j</code>的API在项目中进行统一日志记录</li><li>绑定具体的日志实现<ul><li>对于已经实现了<code>sl4j</code>API的日志实现,直接添加对应的依赖即可</li><li>对于没有实现<code>sl4j</code>API的日志实现,需要先添加对应的日志<strong>适配器</strong>,再添加对应的依赖</li></ul></li><li><code>sl4j</code>有且仅有一个日志实现的绑定,出现多个时默认使用第一个</li></ul><h3 id="SLF4J桥接器"><a href="#SLF4J桥接器" class="headerlink" title="SLF4J桥接器"></a>SLF4J桥接器</h3><blockquote><p>以上都是SLF4J和不同的日志组合实现,可以发现不同的日志框架打印的日志格式不一!!!<br>这是因为SLF4J为了适配不同的日志框架提供了不同的<strong>适配器</strong>,具体的日志记录还是交给对应的日志框架实现的</br><br>SLF4J还提供了<strong>桥接器</strong>!!!<br>桥接器则是由SLF4J实现一套对应的日志框架的API,日志的记录打印完全由这套API实现,可以做到格式统一,且旧代码无需任何更改.</p></blockquote><p><strong>桥接器</strong>解决的是项目中日志的遗留问题,当系统中存在之前的日志API可以通过桥接转换到SLF4J的实现</p><ol><li>移除旧日志框架的依赖–此时旧代码会报错(没有依赖了)</li><li>添加SLF4J提供的对应的桥接组件–SLF4J自己提供一套API,旧代码不再报错</li><li>为项目添加SLF4J的具体实现–就是新的日志实现(SLF4J作为日志门面,还需要具体的日志实现)</li></ol><!-- ![SLF4J桥接](https://s2.loli.net/2023/06/14/YI3nCNavq5oZFbU.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7a9bba159.webp"/><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>pom.xml部分内容:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">假设以前使用了log4j的日志框架,但后续想要改用其他日志框架,如logback</span></span><br><span class="line"><span class="comment">原来的代码由于使用的log4j,依赖也是log4j的API,现在没有了log4j的依赖则会报错</span></span><br><span class="line"><span class="comment">当有了桥接器则只需要引入对应的桥接器即可,旧代码无任何改动</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;log4j&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;log4j&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;1.2.17&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--log4j和slf4j的桥接器--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将log4j桥接到slf4j,slf4j再去使用logback记录日志--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接器演示</span></span><br><span class="line"><span class="comment"> *  假设以前使用的日志是:Log4j</span></span><br><span class="line"><span class="comment"> *  现在要换成Logback(SpringBoot 默认自带,无需引入依赖)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log4jTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(Log4jTest.class);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;Hello Log4j&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用log4j时,打印信息:</span></span><br><span class="line"><span class="comment">     *  2023-06-11 21:52:29.039 Hello Log4j</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用log4j和slf4j的桥接器时,打印信息:</span></span><br><span class="line"><span class="comment">     *  22:10:38.352 [main] INFO com.fredo.slf4j.Log4jTest -- Hello Log4j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:**适配器和桥接器不要同时出现!!!**否则可能出现<code>StackOverflowError</code>异常(我没演示出来~~~)</p><h2 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h2><p>是<code>Log4j</code>的创始人设计的另一个开源日志组件,性能比<code>Log4j</code>好.</p><p>logback分为三个模块:</p><ul><li>logback-core:其他两个模块的核心</li><li>logback-classic:兼容<code>log4j 1.x</code>和<code>JUL</code>,并进行了改进</li><li>logback-access:与Servlet容器(如Tomcat和Jetty)集成,以提供<code>HTTP</code>访问日志功能</li></ul><h2 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h2><p>Apache <code>Log4j2</code>是对<code>Log4j</code>的重大升级,并参考了<code>logback</code>的一些优秀设计,主要特点:</p><ul><li>异常处理机制: 在<code>logback</code>中,<code>Appender</code>中的异常不会被感知到,但在<code>log4j2</code>中提供了异常处理机制</li><li>性能提升: 相较<code>log4j</code>和<code>logback</code>都有明显性能提升</li><li>自动重载配置: 参考<code>logback</code>的设计,自动刷新参数配置,生产环境可动态修改日志配置</li><li>无垃圾机制: 避免频繁的日志收集导致JVM的GC.</li></ul><p>注意:<code>Log4j2</code>既是日志门面又是日志实现,但<code>SLF4J</code>日志门面更早出现更流行,所以市面上主流的搭配还是<code>SLF4J</code>+<code>Logback</code>&#x2F;<code>Log4J2</code></p><ul><li>log4j-api: 是日志门面</li><li>log4j-core: 是日志实现</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>市面上的日志框架可分成两类:日志门面和日志实现</p><!-- ![日志分类](https://s2.loli.net/2023/06/16/6ApzJit1ovaQ9w5.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7acd02dad.webp"/><p>项目中会选一个日志门面和一个日志实现组合</p><ul><li>日志门面一般选<code>SLF4J</code>,相比<code>JCL</code>更简单好用</li><li>日志实现一般选<code>Logback</code>.<code>SLF4J</code>和<code>Logback</code>&#x2F;<code>Log4j</code>是同一个作者更易搭配,且<code>Logback</code>是<code>Log4j</code>的升级版</li></ul><p>市面上常见搭配是:<code>SLF4J</code>+<code>Logback</code>(也是SpringBoot的默认)</p><p>而Apache基金新推出的<code>Log4j2</code>比<code>Logback</code>性能更好,<code>SLF4J</code>+<code>Log4j2</code>也是大势所趋.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了Java的日志体系，包括日志的含义、用途和重要性。涵盖了几种常见的日志框架如Log4j、JUL、JCL、SLF4J、Logback和Log4j2的详细介绍，包括它们的优势、劣势和工作机制。推荐使用SLF4J做日志门</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="http://fu-jw.com/tags/Java/"/>
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置原理浅析</title>
    <link href="http://fu-jw.com/posts/ab942f3d.html"/>
    <id>http://fu-jw.com/posts/ab942f3d.html</id>
    <published>2023-06-03T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了SpringBoot自动配置的原理, 包括自动配置流程，核心配置流程以及如何实施自动配置。首先导入’starter’以获得来自’autoconfigure’包的配置, 然后使用‘@EnableAutoConfiguration’自动载入所有自动配置类。根据条件选择需要的配置类后，上述类将使用由配置文件中的特定前缀属性值提取而成的组件，从而实现自动配置。</p></blockquote><h1 id="SpringBoot自动配置原理浅析"><a href="#SpringBoot自动配置原理浅析" class="headerlink" title="SpringBoot自动配置原理浅析"></a>SpringBoot自动配置原理浅析</h1><blockquote><p>我的<a href="https://github.com/fu-jw/spring-tutorial">SpringBoot项目</a>第二个模块</p></blockquote><p>在日常开发中, 通常我们只需要引入某个<code>场景启动器</code>, 再加上一些相应的配置即可, 无需费心复杂的整合操作, 这也是 SpringBoot 的强大之处.</p><p>SpringBoot 是如何省去繁杂的整合过程的呢?</p><p>接下来按照流程一步一步分析.</p><h2 id="SpringBoot自动配置流程"><a href="#SpringBoot自动配置流程" class="headerlink" title="SpringBoot自动配置流程"></a>SpringBoot自动配置流程</h2><h3 id="1-导入starter"><a href="#1-导入starter" class="headerlink" title="1.导入starter"></a>1.导入<code>starter</code></h3><p>以<code>web场景</code>为例, 导入了web开发场景</p><ol><li>场景启动器导入了相关场景的所有依赖, 如下:<ul><li><code>starter-json</code>,<code>starter-tomcat</code>,<code>springMVC</code></li></ul></li><li>每个场景启动器都引入了一个<code>spring-boot-starter</code>, <strong>核心场景启动器</strong></li><li><strong>核心场景启动器</strong>引入了<code>spring-boot-autoconfigure</code>包</li><li><code>spring-boot-autoconfigure</code>里面囊括了所有场景的所有配置</li><li>只要这个包下的所有类都能生效, 那么相当于SpringBoot官方写好的整合功能就生效了</li><li>SpringBoot默认却扫描不到<code>spring-boot-autoconfigure</code>下写好的所有<strong>配置类</strong>.<ul><li>这些<strong>配置类</strong>给我们做了整合操作,默认只扫描主程序所在的包</li></ul></li></ol><h3 id="2-主程序：-SpringBootApplication"><a href="#2-主程序：-SpringBootApplication" class="headerlink" title="2.主程序：@SpringBootApplication"></a>2.主程序：@SpringBootApplication</h3><p>为什么引入场景,无需配置就已经整合完成了?一切都要从<code>@SpringBootApplication</code>开始</p><p><code>@SpringBootApplication</code>由三个注解组成<code>@SpringBootConfiguration</code>,<code>@EnableAutoConfiguration</code>,<code>@ComponentScan</code></p><ul><li><code>@SpringBootConfiguration</code> 其实就是<code>@Configuration</code>, 声明主程序类是一个<strong>配置类</strong></li><li><code>@ComponentScan</code> SpringBoot默认只能扫描自己主程序所在的包及其下面的子包, 扫描不到<code>spring-boot-autoconfigure</code>包中官方写好的<strong>配置类</strong></li><li><code>@EnableAutoConfiguration</code>就是SpringBoot开启<strong>自动配置</strong>的核心</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong><code>@Import(AutoConfigurationImportSelector.class)</code> 可以批量给容器中导入组件</strong></li><li><a href="mailto:&#83;&#112;&#x72;&#105;&#110;&#103;&#66;&#111;&#111;&#x74;&#x40;&#51;&#x2e;&#x31;&#x2e;&#48;">&#83;&#112;&#x72;&#105;&#110;&#103;&#66;&#111;&#111;&#x74;&#x40;&#51;&#x2e;&#x31;&#x2e;&#48;</a> 会批量导入146个<strong>自动配置类</strong>(<code>xxxAutoConfiguration</code>)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware,</span><br><span class="line">ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 批量获取候选配置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>    annotationMetadata 注解元信息(主程序全类名,本项目为:com.fredo.Main)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   候选配置的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">         <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取自动配置节点</span></span><br><span class="line">      <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">      <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取自动配置节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">         <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回注解属性, 类型:LinkedHashMap, 值(exclude-&gt;[],excludeName-&gt;[])</span></span><br><span class="line">      <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">      <span class="comment">// 获取候选配置类 值(146个自动配置类的全类名)</span></span><br><span class="line">      List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">      <span class="comment">// 去重, 移除重复项</span></span><br><span class="line">      configurations = removeDuplicates(configurations);</span><br><span class="line">      <span class="comment">// 获取排除项</span></span><br><span class="line">      Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">      checkExcludedClasses(configurations, exclusions);</span><br><span class="line">      <span class="comment">// 移除要排除的配置项</span></span><br><span class="line">      configurations.removeAll(exclusions);</span><br><span class="line">      configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">      fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取候选配置类</span></span><br><span class="line"><span class="comment">     * 位置:META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">        List&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())</span><br><span class="line">                .getCandidates();</span><br><span class="line">        Assert.notEmpty(configurations,</span><br><span class="line">                <span class="string">&quot;No auto configuration classes found in &quot;</span></span><br><span class="line">                        + <span class="string">&quot;META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you &quot;</span></span><br><span class="line">                        + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>按需生效</strong><ul><li>虽然导入了146个<strong>自动配置类</strong>, 并不是都能生效</li><li>每一个<strong>自动配置类</strong>, 都有条件注解<code>@ConditionalOnxxx</code>, 只有条件成立, 才能生效 </li><li>导入对应的依赖包, 即满足条件, 该自动配置类就会生效</li></ul></li></ul><h3 id="3-xxxAutoConfiguration自动配置类"><a href="#3-xxxAutoConfiguration自动配置类" class="headerlink" title="3.xxxAutoConfiguration自动配置类"></a>3.<code>xxxAutoConfiguration</code>自动配置类</h3><ol><li>每个<code>xxxAutoConfiguration</code>自动配置类,都需要满足某个条件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(Xxx.class)</span> <span class="comment">// 条件就是需要引入依赖包含 Xxx.class</span></span><br><span class="line"><span class="meta">@Conditional(XxxCondition.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(XxxProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxxAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>条件满足, <strong>自动配置类</strong>就会给容器中使用<code>@Bean</code>放一堆组件</p></li><li><p>每个<strong>自动配置类</strong>都可能有这个注解<code>@EnableConfigurationProperties(XxxProperties.class)</code></p><ul><li>用来把配置文件中配的<strong>指定前缀</strong>的属性值封装到<code>XxxProperties</code><strong>属性类</strong>中</li></ul></li><li><p>以<strong>Tomcat</strong>为例：把服务器的所有配置都是以<code>server</code>开头的。配置都封装到了属性类中</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerProperties</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot核心配置流程"><a href="#SpringBoot核心配置流程" class="headerlink" title="SpringBoot核心配置流程"></a>SpringBoot核心配置流程</h2><ol><li>导入<code>starter</code>, 就会导入<code>autoconfigure</code>包</li><li><code>autoconfigure</code>包里有文件:<strong>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports</strong>,里面指定的所有启动要加载的<strong>自动配置类</strong></li><li><code>@EnableAutoConfiguration</code>会自动的把上面文件里所有<strong>自动配置类</strong>都导入进来. <code>XxxAutoConfiguration</code>是有<strong>条件注解进行按需加载</strong></li><li><code>XxxAutoConfiguration</code>给容器中导入一堆组件, 组件都是从<code>xxxProperties</code>中提取属性值</li><li><code>XxxProperties</code>又和<strong>配置文件</strong>进行绑定</li></ol><p>达到的效果:导入<code>starter</code> –&gt; 修改配置文件, 就能修改底层行为</p><!-- ![SpringBoot自动装配](https://s2.loli.net/2023/06/11/ZGxL4F7YPrOqQcy.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f785fe3f3d.webp"/><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>接下来检验下SpringBoot自动配置原理的理解, 尝试回答如下问题:</p><details> <summary><strong><span style="color: red; ">为什么项目启动后默认端口号是8080, 以及如何修改???</span></strong></summary><ol><li>引入<code>web场景</code></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自动引入了<code>spring-boot-starter</code>和<code>spring-boot-starter-tomcat</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-boot-starter</code>自动引入依赖<code>spring-boot-autoconfigure</code>包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-boot-autoconfigure</code>包里有文件:</p><ul><li><strong>additional-spring-configuration-metadata.json</strong>, 里面包含了所有的默认值</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;server.port&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="number">8080</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports</strong>,里面指定的所有启动要加载的<strong>自动配置类</strong></li></ul><!-- ![spring-boot-autoconfigure包](https://s2.loli.net/2023/06/11/ArMcsINnLb5pZ7t.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f78f673876.webp"/><ol start="2"><li>合成注解<code>@SpringBootApplication</code>中的<code>@EnableAutoConfiguration</code><br>自动的把上面文件里所有<strong>自动配置类</strong>都导入进来. <code>XxxAutoConfiguration</code>是有<strong>条件注解进行按需加载</strong></li></ol><p>其中就包括<code>ServletWebServerFactoryAutoConfiguration.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration(after = SslAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRequest.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span></span><br><span class="line"><span class="meta">ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span></span><br><span class="line"><span class="meta">ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span></span><br><span class="line"><span class="meta">ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定了属性文件<code>ServerProperties</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要在自己的配置文件中自定义<code>server.port</code>的值</p><p>SpringBoot启动时就会去resources路径下加载符合要求的文件, 从该文件中查找配置来覆盖默认配置,<br>即完成了配置自定义</p><p><code>spring-boot-starter-parent-3.1.0.pom</code>文件:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></details><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了SpringBoot自动配置的原理, 包括自动配置流程，核心配置流程以及如何实施自动配置。首先导入’starter’以获得来自’autoconfigure’包的配置, 然后使用‘@EnableAutoConfigu</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中常见注解</title>
    <link href="http://fu-jw.com/posts/f026602.html"/>
    <id>http://fu-jw.com/posts/f026602.html</id>
    <published>2023-06-02T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了SpringBoot中的常见注解，包括基于XML的配置方式和注解方式. 详解了常见注解，如：@Component及其衍生组件、@Configuration和@Bean、@ComponentScan和@ComponentScan.Filter、@Scope和@Lazy等，还单独阐述了条件注解和属性绑定的使用。</p></blockquote><h1 id="SpringBoot中常见注解"><a href="#SpringBoot中常见注解" class="headerlink" title="SpringBoot中常见注解"></a>SpringBoot中常见注解</h1><p>Spring 开始是使用的XML的配置方式, 但随着配置内容的增加, 编写XML配置文件的方式不仅繁琐, 而且还很容易出错.<br>另外，每个项目都编写大量的XML文件来配置Spring, 也大大增加了项目维护的复杂度.<br>往往很多个项目的Spring XML文件的配置大部分是相同的, 只有很少量的配置不同, 这也造成了配置文件上的冗余<br>Spring注解驱动来开发, 你会发现以上这些问题都将不存在.<br>SpringBoot 则从一开始就改为全注解驱动.</p><h2 id="基于XML配置方式"><a href="#基于XML配置方式" class="headerlink" title="基于XML配置方式"></a>基于XML配置方式</h2><ol><li>resources&#x2F;ioc.xml</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.fredo.bean.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;fredo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.fredo.bean.Cat&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tom&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Main.java</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XML 的方式</span></span><br><span class="line"><span class="type">var</span> <span class="variable">ioc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;ioc.xml&quot;</span>);</span><br><span class="line">String[] names = ioc.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中的Bean:&quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.output</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">容器中的Bean:person</span><br><span class="line">容器中的Bean:cat</span><br></pre></td></tr></table></figure><h2 id="注解的方式"><a href="#注解的方式" class="headerlink" title="注解的方式"></a>注解的方式</h2><p>在代码中使用<code>@Configuration</code>和<code>@Bean</code>两个注解, 即可替代以前复杂的xml配置</p><p>config&#x2F;AppConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 这是一个配置类, 替代以前的xml配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 替代以前xml中的bean标签</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setId(<span class="number">1</span>);</span><br><span class="line">        person.setName(<span class="string">&quot;fred0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setId(<span class="number">1</span>);</span><br><span class="line">        cat.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><h3 id="Component及其衍生组件-Repository-Controller-Service-Configuration"><a href="#Component及其衍生组件-Repository-Controller-Service-Configuration" class="headerlink" title="@Component及其衍生组件(@Repository, @Controller, @Service, @Configuration)"></a>@Component及其衍生组件(@Repository, @Controller, @Service, @Configuration)</h3><ul><li>@Component 是通用组件</li><li>@Repository 用于持久层</li><li>@Controller 用于表现层</li><li>@Service 用于业务逻辑层</li><li>@Configuration 用于配置文件</li></ul><h3 id="Configuration和-Bean"><a href="#Configuration和-Bean" class="headerlink" title="@Configuration和@Bean"></a>@Configuration和@Bean</h3><ul><li><code>@Configuration</code> 标注在<strong>类</strong>上, 声明这个类是一个配置类, 加入ioc容器中, 相当于以前的xml配置文件</li><li><code>@Bean</code> 标注在<strong>方法</strong>上, 该方法的输出结果就是一个 JavaBean</li></ul><p><code>@Configuration</code>和<code>@Bean</code>配合使用就可完全替代XML的配置文件</p><p><code>@SpringBootConfiguration</code>是 SpringBoot 中的特有注解, <code>@Configuration</code>是通用版注解, 功能一样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"><span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>bean的名称, 默认是方法名</li><li>可以修改, <code>@Bean(&quot;newName&quot;)</code></li></ul><details> <summary>已经有`@Component`及其衍生组件,为什么还要`@Bean`注解?</summary><ul><li>类似<code>@Component</code>,<code>@Repository</code>,<code>@Controller</code>,<code>@Service</code>这些注册Bean的注解存在局限性:只能作用于自己编写的类, 不能导入第三方jar包, 但是<code>@Bean</code>就可以做到这一点！</li><li>能够动态获取一个Bean对象，能够根据环境不同得到不同的Bean对象</details></li></ul><h3 id="Component和-ComponentScan"><a href="#Component和-ComponentScan" class="headerlink" title="@Component和@ComponentScan"></a>@Component和@ComponentScan</h3><p>在实际项目中, 我们更多的是使用 Spring 的包扫描功能对项目中的包进行扫描,<br>凡是在指定的包或其子包中的类上标注了<code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>, <code>@Component</code>注解的类都会被扫描到, 并将这个类注入到 Spring 容器中</p><p>Spring 包扫描功能可以使用XML配置文件进行配置, 也可以直接使用<code>@ComponentScan</code>注解进行设置, 使用<code>@ComponentScan</code>注解进行设置比使用XML配置文件来配置要简单的多</p><p>XML方式</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包扫描：只要是标注了我们熟悉的@Controller、@Service、@Repository、@Component这四个注解中的任何一个的组件，它就会被自动扫描，并加进容器中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.fredo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@ComponentScan</code>方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;)</span> <span class="comment">// value指定要扫描的包</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 这是一个配置类, 替代以前的xml配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ol start="0"><li>主程序标注了<code>@SpringBootApplication</code>, 就会默认扫描主程序所在的包及其子包; </li><li>如果设置了<code>@ComponentScan(&quot;...&quot;)</code>, 则以设置的扫描路径为主, 默认值不再生效</li><li><code>@ComponentScan</code>还可以设置包含某些组件(<code>includeFilters()</code>)或者排除某些组件(<code>excludeFilters()</code>)</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, excludeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     * classes：除了@Controller和@Service标注的组件之外，IOC容器中剩下的组件我都要，即相当于是我要排除@Controller和@Service这俩注解标注的组件。</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Controller.class, Service.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>@ComponentScan</code>是可重复注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     * classes：我们需要Spring在扫描时，只包含@Controller注解标注的类</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Controller.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     * classes：我们需要Spring在扫描时，只包含@Service注解标注的类</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Service.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure><p>小结一下:</p><ul><li><code>@Component</code> 声明 Bean, 告诉 Spring 这是一个 Bean</li><li><code>@ComponentScan</code> 设置扫描路径, 告诉 Spring 到哪里找到这些 Bean</li></ul><h3 id="ComponentScan-Filter"><a href="#ComponentScan-Filter" class="headerlink" title="@ComponentScan.Filter"></a>@ComponentScan.Filter</h3><p>Spring 的强大之处不仅仅是提供了 IOC 容器,<br>可以设置包含某些组件(<code>includeFilters()</code>)或者排除某些组件(<code>excludeFilters()</code>), 它还能够通过自定义<code>TypeFilter</code>来指定过滤规则. </p><p><code>FilterType</code>中常用的规则如下: </p><ol><li>ANNOTATION：按照注解进行包含或者排除</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     * classes：我们需要Spring在扫描时，只包含@Controller注解标注的类</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Controller.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure><ol start="2"><li>ASSIGNABLE_TYPE：按照给定的类型进行包含或者排除</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    // 只要是BookService这种类型的组件都会被加载到容器中，不管是它的子类还是什么它的实现类。记住，只要是BookService这种类型的</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ASSIGNABLE_TYPE, classes=&#123;BookService.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure><ol start="3"><li>ASPECTJ：使用表达式来挑选复杂的类子集</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ASPECTJ, classes=&#123;AspectJTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure><ol start="4"><li>REGEX：按照正则表达式进行包含或者排除</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.REGEX, classes=&#123;RegexPatternTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure><ol start="5"><li>CUSTOM：按照自定义规则进行包含或者排除</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    // 指定新的过滤规则，这个过滤规则是我们自个自定义的，过滤规则就是由我们这个自定义的MyTypeFilter类返回true或者false来代表匹配还是没匹配</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.CUSTOM, classes=&#123;MyTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure><p>MyTypeFilter.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title class_">TypeFilter</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数：</span></span><br><span class="line"><span class="comment">     * metadataReader：读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment">     * metadataReaderFactory：可以获取到其他任何类的信息的（工厂）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 返回值:</span></span><br><span class="line"><span class="comment">     * 当返回true时，表示符合规则，会包含在Spring容器中；</span></span><br><span class="line"><span class="comment">     * 当返回false时，表示不符合规则，就不会被包含在Spring容器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 自定义过滤规则</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性值:</p><ul><li>type: 要排除的方式:<code>FilterType</code></li><li>value: 要排除的类型, 同 <code>classes</code></li><li>classes: 同 <code>value</code></li><li>pattern: 正则表达式</li></ul><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>用于设置组件的<strong>作用域</strong>, 默认值是<code>singleton</code>单例</p><p>作用域取值:</p><ul><li>singleton: 单例, 默认值, 容器启动就会调用方法创建对象到ioc容器中</li><li>prototype: 多例, 容器启动时并不会调用方法创建对象, 每次获取时才会调用方法创建对象</li><li>request: web 环境中, 同一个请求只创建一个对象</li><li>session: web 环境中, 同一个 session 只创建一个对象</li><li>application: web 环境中, 一个应用程序只创建一个对象, 全局</li></ul><h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>懒加载就是Spring容器启动的时候, 先不创建对象, 在第一次使用(获取)bean的时候再来创建对象, 并进行一些初始化</p><p>注意: 懒加载, 仅针对单例bean生效</p><h3 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h3><p>@ConditionalOnXxx 注解指定的<strong>条件成立</strong>, 则触发指定行为</p><ul><li>@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为</li><li>@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为</li><li>@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为</li><li>@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为</li><li>…</li></ul><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><p>将容器中任意组件(Bean)的<strong>属性值和配置文件</strong>的配置项的值进行绑定</p><ol><li>给容器中注册组件(<code>@Component</code>, <code>@Bean</code>)</li><li>使用<code>@ConfigurationProperties</code>声明组件和配置文件的哪些配置项进行绑定</li></ol><p><code>@EnableConfigurationProperties</code> 快速注册注解</p><ul><li>SpringBoot 默认只扫描自己主程序所在的包. 如果导入第三方包, 即使组件上标注了<code>@Component</code>, <code>@ConfigurationProperties</code>注解, 也没用.</li><li>因为组件都扫描不进来, 此时使用这个注解就可以快速进行属性绑定并把组件注册进容器</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了SpringBoot中的常见注解，包括基于XML的配置方式和注解方式. 详解了常见注解，如：@Component及其衍生组件、@Configuration和@Bean、@ComponentScan和@Compone</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot快速入门</title>
    <link href="http://fu-jw.com/posts/4ccc97e8.html"/>
    <id>http://fu-jw.com/posts/4ccc97e8.html</id>
    <published>2023-06-01T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了SpringBoot的快速开发流程、遇到问题的解决办法、特点和应用分析，主要包括依赖管理机制、自动装配机制，以及自动配置流程细节梳理。同时，详细解析了SpringBoot中各种配置和注解的使用。</p></blockquote><h1 id="SpringBoot快速入门"><a href="#SpringBoot快速入门" class="headerlink" title="SpringBoot快速入门"></a>SpringBoot快速入门</h1><blockquote><p>我的<a href="https://github.com/fu-jw/spring-tutorial">SpringBoot项目</a>第一个模块</p></blockquote><h2 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h2><p>按照官网一步一步操作即可:<br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.first-application">https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.first-application</a></p><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><h4 id="pom-xml中出现Provides-transitive-vulnerable-dependency-maven-org-yaml-snakeyaml-1-33警告"><a href="#pom-xml中出现Provides-transitive-vulnerable-dependency-maven-org-yaml-snakeyaml-1-33警告" class="headerlink" title="pom.xml中出现Provides transitive vulnerable dependency maven:org.yaml:snakeyaml:1.33警告"></a>pom.xml中出现Provides transitive vulnerable dependency maven:org.yaml:snakeyaml:1.33警告</h4><ul><li>告警原因:Maven项目中使用了一个被认为是有漏洞的依赖项，并且这个依赖项也被其他依赖项所传递<ul><li>org.yaml:snakeyaml:1.33这个库是存在漏洞</li></ul></li><li>解决警告:升级依赖项<ul><li>在中央仓库搜索无告警版本: <a href="https://mvnrepository.com/">https://mvnrepository.com/</a></li><li>在Maven项目中，可以使用dependencyManagement标签来管理依赖项</li><li>这个标签中，可以指定一个特定版本，以便所有依赖项都将使用这个版本</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;dependencyManagement&gt;</span></span><br><span class="line">    <span class="string">&lt;dependencies&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.yaml&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="string">&lt;version&gt;2.0&lt;/version&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;/dependencies&gt;</span></span><br><span class="line"><span class="string">&lt;/dependencyManagement&gt;</span></span><br></pre></td></tr></table></figure><ul><li>解决警告:移除依赖项<ul><li>如果这个库不是必须的，可以考虑从项目中移除它; 或者idea中设置忽略(眼不见心不烦)</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span></span><br><span class="line">    <span class="string">&lt;exclusions&gt;</span></span><br><span class="line">        <span class="string">&lt;exclusion&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.yaml&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/exclusion&gt;</span></span><br><span class="line">    <span class="string">&lt;/exclusions&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><h4 id="项目启动报错：An-incompatible-version-1-1-29-of-the-Apache-Tomcat-Native-library-is-installed-while-Tomcat-requires-version-1-2-34"><a href="#项目启动报错：An-incompatible-version-1-1-29-of-the-Apache-Tomcat-Native-library-is-installed-while-Tomcat-requires-version-1-2-34" class="headerlink" title="项目启动报错：An incompatible version [1.1.29] of the Apache Tomcat Native library is installed, while Tomcat requires version [1.2.34]"></a>项目启动报错：An incompatible version [1.1.29] of the Apache Tomcat Native library is installed, while Tomcat requires version [1.2.34]</h4><ul><li>打开网页 <a href="http://archive.apache.org/dist/tomcat/tomcat-connectors/native/">http://archive.apache.org/dist/tomcat/tomcat-connectors/native/</a></li><li>查找对应版本文件: <a href="http://archive.apache.org/dist/tomcat/tomcat-connectors/native/1.2.34/binaries/">http://archive.apache.org/dist/tomcat/tomcat-connectors/native/1.2.34/binaries/</a></li><li>下载对应的zip文件</li><li>解压文件,里面有32位和64位的 tcnative-1.dll 文件</li><li>根据自己的jdk和tomcat版本选择一个，复制到 jdk 的bin目录下即可</li><li>重启 spring boot项目</li></ul><h2 id="模块小结"><a href="#模块小结" class="headerlink" title="模块小结"></a>模块小结</h2><h3 id="SpringBoot-是什么"><a href="#SpringBoot-是什么" class="headerlink" title="SpringBoot 是什么"></a>SpringBoot 是什么</h3><p>SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 Spring 应用（说明：SpringBoot底层是Spring）</p><p>大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>简化整合<ul><li>SpringBoot提出<code>场景启动器</code>的概念</li><li>导入相关的场景，即拥有相关的功能。</li><li>默认支持的所有场景：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters</a><ul><li>官方提供的场景：命名为：spring-boot-starter-*</li><li>第三方提供场景：命名为：*-spring-boot-starter</li></ul></li><li>场景一导入，万物皆就绪</li></ul></li><li>简化开发<ul><li>无需编写任何配置，直接开发业务</li></ul></li><li>简化配置<ul><li>application.properties：</li><li>集中式管理配置。只需要修改这个文件就行 。</li><li>配置基本都有默认值</li><li>能写的所有配置都在： <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties</a></li></ul></li><li>简化部署<ul><li>打包为可执行的jar包。</li><li>linux服务器上有java环境。</li></ul></li><li>简化运维<ul><li>修改配置（外部放一个application.properties文件）、监控、健康检查。</li></ul></li></ol><h2 id="应用分析"><a href="#应用分析" class="headerlink" title="应用分析"></a>应用分析</h2><h3 id="依赖管理机制"><a href="#依赖管理机制" class="headerlink" title="依赖管理机制"></a>依赖管理机制</h3><ol><li><p>为什么导入<code>场景启动器</code>所有的依赖就都导入进来了?</p><ul><li>根据<code>maven</code>的依赖传递原则, A依赖B,B依赖C;则A同时依赖B C</li><li>以<code>web场景启动器</code>为例,引入<code>spring-boot-starter-web</code></li><li><code>spring-boot-starter-web</code> 会有很多依赖,包括其他<code>场景启动器</code><br>如<code>spring-boot-starter-tomcat</code>,<code>spring-web</code>,<code>spring-webmvc</code>等</li><li><strong>小结一下</strong>: 该<code>场景启动器</code>会将所有的依赖提前准备好,根据<code>maven</code>的依赖传递原则就可全部引入</li></ul></li><li><p>为什么版本号不用写?</p><ul><li>每个boot项目都有一个父项目<code>spring-boot-starter-parent</code></li><li>parent的父项目是<code>spring-boot-dependencies</code></li><li>也称<code>版本仲裁中心</code>,使用<code>dependencyManagement</code>标签已将所有常见的依赖版本号提前声明好</li></ul></li><li><p>自定义版本号</p><ul><li>根据<code>maven</code>的就近原则</li><li>直接在当前项目<code>properties</code>标签中修改版本号</li><li>或者直接在导入依赖的时候声明版本</li></ul></li><li><p>第三方的jar包</p><ul><li>boot 父项目没有管理的需要自行声明好</li></ul></li></ol><img alt="SpringBoot依赖管理" src="https://image.fu-jw.com/img/2023/07/01/649f7705d495d.webp"/><h3 id="自动装配机制"><a href="#自动装配机制" class="headerlink" title="自动装配机制"></a>自动装配机制</h3><h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>不用 SpringBoot 时, 要整合 SpringMVC 就需要自己手动配置:</p><ul><li><code>DispatcherServlet</code>: 拦截请求的组件</li><li><code>ViewResolver</code>: 视图解析组件</li><li><code>CharacterEncodingFilter</code>: 处理字符编码的组件</li><li>…</li></ul><p>现在有了 SpringBoot 以上组件都不用再自己手动配置了, 直接引入<code>web场景启动器</code>即可</p><h4 id="默认包扫描规则"><a href="#默认包扫描规则" class="headerlink" title="默认包扫描规则"></a>默认包扫描规则</h4><ul><li><code>@SpringBootApplication</code> 标注的类就是主程序类</li><li>SpringBoot 会默认扫描主程序所在的包及其子包, 即自动的 <strong>component-scan</strong> 功能</li><li>可自定义扫描路径<ul><li>@SpringBootApplication(scanBasePackages &#x3D; “com.fredo”)</li><li>@ComponentScan(“com.fredo”) 直接指定扫描的路径</li></ul></li></ul><h4 id="配置默认值"><a href="#配置默认值" class="headerlink" title="配置默认值"></a>配置默认值</h4><ul><li><strong>配置文件</strong>的所有配置项和某个类的对象值进行一一绑定</li><li>绑定了配置文件中每一项值的类称为: <strong>属性类</strong></li><li>参照<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html">官方文档</a>：或者参照绑定的<strong>属性类</strong></li></ul><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><ul><li><code>场景启动器</code>除了导入相关功能依赖, 还会导入一个<code>spring-boot-starter</code></li><li><code>spring-boot-starter</code>, 是所有<strong>starter</strong>的<strong>starter</strong>, 基础核心starter</li><li><code>spring-boot-starter</code>会导入包<code>spring-boot-autoconfigure</code>. 包里面都是全场景的 AutoConfiguration 自动配置类</li><li>虽然全场景的自动配置都在包:<code>spring-boot-autoconfigure</code>, 但并不会全都开启<ul><li>根据条件开启</li><li><code>@ConditionalOnXxx</code></li><li><code>@ConditionalOnMissingXxx</code></li></ul></li></ul><p>小结一下: 导入<code>场景启动器</code>, 触发<code>spring-boot-autoconfigure</code>这个包的自动配置生效, 容器中就会具有相关场景的功能</p><h4 id="自动配置流程细节梳理"><a href="#自动配置流程细节梳理" class="headerlink" title="自动配置流程细节梳理"></a>自动配置流程细节梳理</h4><ol><li>导入<code>场景启动器</code>, 以<code>spring-boot-starter-web</code>为例<ul><li>场景启动器就会导入相关场景的所有依赖, 如<code>starter-json</code>,<code>starter-tomcat</code>, <code>springmvc</code></li><li>每个场景启动器都会引入一个<code>spring-boot-starter</code>, 核心场景启动器</li><li><strong>核心场景启动器</strong>会引入包:<code>spring-boot-autoconfigure</code></li><li><code>spring-boot-autoconfigure</code>里面包含所有场景的所有配置</li><li>只要这个包下的所有类都能生效, 那么SpringBoot官方的整合功能就能生效</li><li>SpringBoot 默认扫描不到<code>spring-boot-autoconfigure</code>下的所有配置类(这些配置类给我们做了整合操作), 默认只扫描主程序所在的包</li></ul></li><li>主程序：@SpringBootApplication<ul><li><code>@SpringBootApplication</code>由三个注解组成: <code>@SpringBootConfiguration</code>, <code>@EnableAutoConfiguratio</code>, <code>@ComponentScan</code></li><li>SpringBoot 默认只扫描主程序所在的包及其下子包, 扫描不到<code>spring-boot-autoconfigure</code>包中的<strong>配置类</strong></li><li><code>@EnableAutoConfiguration</code>: SpringBoot 开启自动配置的核心<ul><li>是由<code>@Import(AutoConfigurationImportSelector.class)</code>提供功能：批量给容器中导入组件</li><li>SpringBoot 默认加载所有的配置类(SpringBoot3.1.0有146个)</li><li>这146个配置类来自于<code>spring-boot-autoconfigure</code>下 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件指定</li><li>项目启动的时候利用 @Import 批量导入组件机制, 把 autoconfigure 包下的<strong>自动配置类</strong>: xxxAutoConfiguration 导入进来</li></ul></li><li>按需生效<ul><li>这146个自动配置类并不全都生效</li><li>每个自动配置类都有条件注解<code>@ConditionalOnXxx</code>, 只有条件成立, 才能生效</li></ul></li></ul></li><li><code>xxxAutoConfiguration</code>自动配置类<ul><li>给容器中使用<code>@Bean</code>放一堆组件</li><li>每个自动配置类都可能有这个注解<code>@EnableConfigurationProperties(XxxProperties.class)</code>, 用来把配置文件中配的指定前缀的属性值封装到<code>xxxProperties</code>属性类中</li><li>以<code>Tomcat</code>为例: 把服务器的所有配置都是以<code>server</code>开头. 配置都封装到了属性类中</li><li>给容器中放的所有组件的一些核心参数, 都来自于<code>XxxProperties</code>. <code>XxxProperties</code>都是和配置文件绑定</li><li><strong>只需要改配置文件的值, 核心组件的底层参数都能修改</strong></li></ul></li><li>只需关注业务, 全程无需关心各种整合(底层这些已经整合完成)</li></ol><p>小结一下:</p><ol><li>导入<code>starter</code>, 就会导入<code>autoconfigure</code>包</li><li><code>autoconfigure</code>包里有文件: META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports, 里面指定了所有启动要加载的<strong>自动配置类</strong></li><li><code>@EnableAutoConfiguration</code>会自动的把上面文件里面写的所有<strong>自动配置类</strong>都导入进来</li><li><code>xxxAutoConfiguration</code>是有条件注解进行按需加载</li><li><code>xxxAutoConfiguration</code>给容器中导入许多组件, 组件都是从<code>xxxProperties</code>中提取属性值</li><li><code>xxxProperties</code>又和<strong>配置文件</strong>进行了绑定</li></ol><p>达到的效果: 导入<code>starter</code>, 修改配置文件, 就能修改底层行为</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了SpringBoot的快速开发流程、遇到问题的解决办法、特点和应用分析，主要包括依赖管理机制、自动装配机制，以及自动配置流程细节梳理。同时，详细解析了SpringBoot中各种配置和注解的使用。&lt;/p&gt;
&lt;/blo</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 中的数学公式</title>
    <link href="http://fu-jw.com/posts/63166764.html"/>
    <id>http://fu-jw.com/posts/63166764.html</id>
    <published>2022-12-30T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了各种LaTex代码和其对应的数学表达式，包括希腊字母表，常见符号，箭头，常见数学公式以及复杂表达式如矩阵和方程组等。</p></blockquote><h2 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\alpha</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\alpha$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\beta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\beta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\chi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\chi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\delta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\delta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Delta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Delta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\epsilon</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\epsilon$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\eta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\eta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Gamma</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Gamma$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\iota</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\iota$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\kappa</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\kappa$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lambda</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lambda$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Lambda</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Lambda$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\mu</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\mu$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nabla</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nabla$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nu</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nu$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\omega</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\omega$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Omega</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Omega$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\phi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\phi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Phi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Phi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\pi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\pi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Pi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Pi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\psi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\psi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Psi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Psi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rho</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rho$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sigma</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\sigma$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Sigma</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Sigma$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\tau</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\tau$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\theta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\theta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Theta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Theta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\upsilon</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\upsilon$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\varepsilon</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\varepsilon$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\varsigma</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\varsigma$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\vartheta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\vartheta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\xi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\xi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\zeta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\zeta$</p><h2 id="公式中的常见符号"><a href="#公式中的常见符号" class="headerlink" title="公式中的常见符号"></a>公式中的常见符号</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\cdot</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\cdot$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\colon</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\colon$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\vdots</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\vdots$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dotsm</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\dotsm$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dotso</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\dotso$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\ddots</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\ddots$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\check</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\check{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\grave</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\grave{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\breve</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\breve{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\acute</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\acute{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\tilde</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\tilde{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bar</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bar{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\hat</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\hat{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dot</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\dot{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\ddot</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\ddot{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\widehat</span>&#123;xxx&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\widehat{xxx}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\times</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\times$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\div</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\div$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\neq</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\neq$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\vec</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\vec{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dddot</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\dddot{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\widetilde</span>&#123;xxx&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\widetilde{xxx}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\backslash</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\backslash$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>/<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $&#x2F;$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bracevert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bracevert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\smallsetminus</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\smallsetminus$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lbrace</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lbrace$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rbrace</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rbrace$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\arrowvert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\arrowvert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lVert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lVert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rVert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rVert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lgroup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lgroup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rgroup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rgroup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\langle</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\langle$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rangle</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rangle$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lvert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lvert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rvert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rvert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>[<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $[$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lmoustache</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lmoustache$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rmoustache</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rmoustache$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lceil</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lceil$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rceil</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rceil$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lfloor</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lfloor$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rfloor</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rfloor$</p><h2 id="公式中常见的箭头"><a href="#公式中常见的箭头" class="headerlink" title="公式中常见的箭头"></a>公式中常见的箭头</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\uparrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果:  $\uparrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\downarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\downarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\longleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\longleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\longrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\longrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\longleftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\longleftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nwarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nwarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nearrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nearrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\swarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\swarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\searrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\searrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\upuparrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\upuparrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\downdownarrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\downdownarrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\updownarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\updownarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nleftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nleftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\upharpoonleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\upharpoonleft$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\upharpoonright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\upharpoonright$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\downharpoonleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\downharpoonleft$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\downharpoonright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\downharpoonright$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftharpoondown</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftharpoondown$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftharpoonup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftharpoonup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightharpoonup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightharpoonup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightharpoondown</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightharpoondown$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Uparrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Uparrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Downarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Downarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Leftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Leftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Rightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Rightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nLeftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nLeftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nRightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nRightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Leftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Leftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nLeftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nLeftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Updownarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Updownarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\mapsto</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\mapsto$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftleftarrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftleftarrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightrightarrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightrightarrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftrightarrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftrightarrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightleftarrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightleftarrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\hookleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\hookleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\hookrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\hookrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\curvearrowleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\curvearrowleft$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\curvearrowright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\curvearrowright$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\circlearrowleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\circlearrowleft$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\circlearrowright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\circlearrowright$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftrightharpoons</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftrightharpoons$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightleftharpoons</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightleftharpoons$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftrightharpoons</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftrightharpoons$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Longleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Longleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Longrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Longrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Longleftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Longleftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Lleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Lleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Rrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Rrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\looparrowleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\looparrowleft$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\looparrowright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\looparrowright$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightsquigarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightsquigarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\longmapsto</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\longmapsto$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Lsh</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Lsh$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Rsh</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Rsh$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftarrowtail</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftarrowtail$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightarrowtail</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightarrowtail$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\multimap</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\multimap$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\twoheadleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\twoheadleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\twoheadrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\twoheadrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftrightsquigarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftrightsquigarrow$</p><h2 id="常见的数学公式"><a href="#常见的数学公式" class="headerlink" title="常见的数学公式"></a>常见的数学公式</h2><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;ab&#125;&#123;cd&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\frac{ab}{cd}$</p><h3 id="开根号"><a href="#开根号" class="headerlink" title="开根号"></a>开根号</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>[x]&#123;y&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\sqrt[x]{y}$  </p><h3 id="对数-log"><a href="#对数-log" class="headerlink" title="对数-log"></a>对数-log</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\log</span><span class="built_in">_</span>&#123;a&#125;&#123;b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\log_{a}{b}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lg</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果:  $\lg{ab}$</p><h3 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>&#123;ab&#125;<span class="built_in">^</span>&#123;cd&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: ${ab}^{cd}$</p><h3 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>&#123;a&#125;<span class="built_in">_</span>&#123;bc&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: ${a}_{bc}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>x<span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $x_a^b$</p><h3 id="连加"><a href="#连加" class="headerlink" title="连加"></a>连加</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\sum$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\sum_a^b$</p><h3 id="连乘"><a href="#连乘" class="headerlink" title="连乘"></a>连乘</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\prod$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\prod_a^b$</p><h3 id="副积"><a href="#副积" class="headerlink" title="副积"></a>副积</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\coprod</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\coprod$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\coprod</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\coprod_a^b$</p><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\int$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">_</span>&#123;a&#125;<span class="built_in">^</span>&#123;b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\int_{a}^{b}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\oint</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\oint$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\oint</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\oint_a^b$</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>C<span class="built_in">_</span>n<span class="built_in">^</span>2<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $C_n^2$  </p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span> <span class="keyword">\frac</span>&#123;1&#125;&#123;i<span class="built_in">^</span>2&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\sum \frac{1}{i^2}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcap</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigcap$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcap</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigcap_a^b$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigcup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcup</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigcup_a^b$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigsqcup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigsqcup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigsqcup</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigsqcup_a^b$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigvee</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigvee$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigvee</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigvee_a^b$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigwedge</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigwedge$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigwedge</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigwedge_a^b$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\widetilde</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\widetilde{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\widehat</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\widehat{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overleftarrow</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\overleftarrow{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overrightarrow</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\overrightarrow{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overbrace</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\overbrace{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\underbrace</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\underbrace{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\underline</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\underline{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overline</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\overline{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> a&#125;&#123;<span class="keyword">\partial</span> b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\frac{\partial a}{\partial b}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;<span class="keyword">\text</span>&#123;d&#125;x&#125;&#123;<span class="keyword">\text</span>&#123;d&#125;y&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\frac{\text{d}x}{\text{d}y}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;a <span class="keyword">\rightarrow</span> b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lim_{a \rightarrow b}$</p><h2 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h2><p><strong>注意: 部分公式显示失败, 请自行安装对应插件</strong></p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>无括号版:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;matrix&#125;</span><br><span class="line">1&amp;0&amp;0\\</span><br><span class="line">0&amp;1&amp;0\\</span><br><span class="line">0&amp;0&amp;1\\</span><br><span class="line">\end&#123;matrix&#125;$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\begin{matrix}<br>1&amp;0&amp;0\<br>0&amp;1&amp;0\<br>0&amp;0&amp;1\<br>\end{matrix}$$</p><p>中括号版:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;bmatrix&#125;</span><br><span class="line">&#123;a_&#123;11&#125;&#125;&amp;&#123;a_&#123;12&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;1n&#125;&#125;\\</span><br><span class="line">&#123;a_&#123;21&#125;&#125;&amp;&#123;a_&#123;22&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;2n&#125;&#125;\\</span><br><span class="line">&#123;\vdots&#125;&amp;&#123;\vdots&#125;&amp;&#123;\ddots&#125;&amp;&#123;\vdots&#125;\\</span><br><span class="line">&#123;a_&#123;m1&#125;&#125;&amp;&#123;a_&#123;m2&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;mn&#125;&#125;\\</span><br><span class="line">\end&#123;bmatrix&#125;$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\begin{bmatrix}<br>{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\<br>{a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\<br>{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\<br>{a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\<br>\end{bmatrix}$$</p><p>小括号版:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;pmatrix&#125;</span><br><span class="line">&#123;a_&#123;11&#125;&#125;&amp;&#123;a_&#123;12&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;1n&#125;&#125;\\</span><br><span class="line">&#123;a_&#123;21&#125;&#125;&amp;&#123;a_&#123;22&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;2n&#125;&#125;\\</span><br><span class="line">&#123;\vdots&#125;&amp;&#123;\vdots&#125;&amp;&#123;\ddots&#125;&amp;&#123;\vdots&#125;\\</span><br><span class="line">&#123;a_&#123;m1&#125;&#125;&amp;&#123;a_&#123;m2&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;mn&#125;&#125;\\</span><br><span class="line">\end&#123;pmatrix&#125;$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\begin{pmatrix}<br>{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\<br>{a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\<br>{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\<br>{a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\<br>\end{pmatrix}$$</p><h3 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;cases&#125;</span><br><span class="line">a_1x+b_1y+c_1z=d_1\\</span><br><span class="line">a_2x+b_2y+c_2z=d_2\\</span><br><span class="line">a_3x+b_3y+c_3z=d_3\\</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\begin{cases}<br>a_1x+b_1y+c_1z&#x3D;d_1\<br>a_2x+b_2y+c_2z&#x3D;d_2\<br>a_3x+b_3y+c_3z&#x3D;d_3\<br>\end{cases}<br>$$<br>有条件版:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$Sum=\begin&#123;cases&#125; L == 0 &amp; H[R]\\</span><br><span class="line">L != 0 &amp; H[R] = H[L-1]\end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$Sum&#x3D;\begin{cases} L &#x3D;&#x3D; 0 &amp; H[R]\<br>L !&#x3D; 0 &amp; H[R] &#x3D; H[L-1]\end{cases}$$  </p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;cases&#125;a &amp; x = 0\\ </span><br><span class="line">b &amp; x &gt; 0</span><br><span class="line">\end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\begin{cases}a &amp; x &#x3D; 0\<br>b &amp; x &gt; 0<br>\end{cases}$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了各种LaTex代码和其对应的数学表达式，包括希腊字母表，常见符号，箭头，常见数学公式以及复杂表达式如矩阵和方程组等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;希腊字母表&quot;&gt;&lt;a href=&quot;#希腊字母表</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Markdown" scheme="http://fu-jw.com/tags/Markdown/"/>
    
    <category term="LaTex" scheme="http://fu-jw.com/tags/LaTex/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 常用语法</title>
    <link href="http://fu-jw.com/posts/e317821c.html"/>
    <id>http://fu-jw.com/posts/e317821c.html</id>
    <published>2022-12-30T00:00:00.000Z</published>
    <updated>2023-07-09T11:25:56.293Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>🤖🤖-摘要:<br>本文介绍了MarkDown编辑的多种技巧，包括字体的加粗、斜体、大小调整、颜色改变，和文本的换行、横线、链接、分页、折叠等效果的生成方法，以及如何嵌入文件、网络图片和视频</p></blockquote><h2 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h2><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$\mathbf&#123;你好啊&#125;$</span><br></pre></td></tr></table></figure><p>普通: 你好啊<br>效果: $\mathbf{你好啊}$</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">**你好啊**</span><br></pre></td></tr></table></figure><p>效果: <strong>你好啊</strong></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$\mathit&#123;世界&#125;$</span><br></pre></td></tr></table></figure><p>效果: $\mathit{世界}$</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">*世界*</span><br></pre></td></tr></table></figure><p>效果: <em>世界</em></p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$\tiny 你好(tiny)$</span><br><span class="line"></span><br><span class="line">$\scriptsize 你好(scriptsize)$</span><br><span class="line"></span><br><span class="line">$\small 你好(small)$</span><br><span class="line"></span><br><span class="line">$\normalsize 你好(normalsize)$</span><br><span class="line"></span><br><span class="line">$\large 你好(large)$</span><br><span class="line"></span><br><span class="line">$\Large 你好(Large)$</span><br><span class="line"></span><br><span class="line">$\huge 你好(huge)$</span><br><span class="line"></span><br><span class="line">$\Huge 你好(Huge)$</span><br></pre></td></tr></table></figure><p>效果:<br>$\tiny 你好(tiny)$</p><p>$\scriptsize 你好(scriptsize)$</p><p>$\small 你好(small)$</p><p>$\normalsize 你好(normalsize)$</p><p>$\large 你好(large)$</p><p>$\Large 你好(Large)$</p><p>$\huge 你好(huge)$</p><p>$\Huge 你好(Huge)$</p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$\color&#123;Red&#125;&#123;红色&#125;$, $\color&#123;blue&#125;&#123;蓝色&#125;$,  $\color&#123;orange&#125;&#123;橘色&#125;$,  </span><br><span class="line">$\color&#123;Green&#125;&#123;绿色&#125;$,  $\color&#123;gray&#125;&#123;灰色&#125;$,  $\color&#123;purple&#125;&#123;紫色&#125;$.</span><br></pre></td></tr></table></figure><p>效果:<br>$\color{Red}{红色}$, $\color{blue}{蓝色}$,  $\color{orange}{橘色}$,<br>$\color{Green}{绿色}$,  $\color{gray}{灰色}$,  $\color{purple}{紫色}$.</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><h4 id="两个及以上空格-回车"><a href="#两个及以上空格-回车" class="headerlink" title="两个及以上空格 + 回车"></a>两个及以上空格 + 回车</h4><p>第一行<br>第二行</p><h4 id="html-标签-lt-x2F-br-gt"><a href="#html-标签-lt-x2F-br-gt" class="headerlink" title="html 标签 &lt;&#x2F;br&gt;"></a>html 标签 &lt;&#x2F;br&gt;</h4><p>第一行</br>第二行</p><h3 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h3><h4 id="上横线"><a href="#上横线" class="headerlink" title="上横线"></a>上横线</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$\overline&#123;\text&#123;上划线&#125;&#125;$</span><br></pre></td></tr></table></figure><p>效果:  $\overline{\text{上划线}}$</p><h4 id="中横线"><a href="#中横线" class="headerlink" title="中横线"></a>中横线</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">~~中划线~~</span><br></pre></td></tr></table></figure><p>效果: <del>中划线</del></p><h4 id="下横线"><a href="#下横线" class="headerlink" title="下横线"></a>下横线</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$\underline&#123;\text&#123;下划线1&#125;&#125;$</span><br><span class="line"></span><br><span class="line">&lt;u&gt;下划线2&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>效果: $\underline{\text{下划线1}}$    <u>下划线 2</u></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.baidu.com/">百度一下</a></p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;div STYLE=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div>  <p>将这个插入到你要分页的地方</p><h3 id="折叠内容"><a href="#折叠内容" class="headerlink" title="折叠内容"></a>折叠内容</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;details&gt; &lt;summary&gt;Title&lt;/summary&gt;</span><br><span class="line">contents ...</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><details><summary>Title</summary>contents ...</details><h2 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌"></a>内嵌</h2><p><a href="https://publish.obsidian.md/help/How+to/Embed+files">https://publish.obsidian.md/help/How+to/Embed+files</a></p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">![[My File.pdf#page=number]]</span><br></pre></td></tr></table></figure><h3 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">![网络图片](https://s2.loli.net/2023/06/11/MVbHQs1Eui6fAzo.webp)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/MVbHQs1Eui6fAzo.webp" alt="网络图片"></p><h3 id="网络视频"><a href="#网络视频" class="headerlink" title="网络视频"></a>网络视频</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;https://player.bilibili.com/player.html?aid=586848024&amp;bvid=BV1Kz4y1m74W&amp;cid=300166684&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; height=300 width=400&gt; </span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe src=" https://player.bilibili.com/player.html?aid=586848024&bvid=BV1Kz4y1m74W&cid=300166684&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height=300 width=400></iframe><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;🤖🤖-摘要:&lt;br&gt;本文介绍了MarkDown编辑的多种技巧，包括字体的加粗、斜体、大小调整、颜色改变，和文本的换行、横线、链接、分页、折叠等效果的生成方法，以及如何嵌入文件、网络图片和视频&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Markdown" scheme="http://fu-jw.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
