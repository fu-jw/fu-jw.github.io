<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fredo&#39;s Blog</title>
  
  
  <link href="http://fu-jw.com/atom.xml" rel="self"/>
  
  <link href="http://fu-jw.com/"/>
  <updated>2023-07-07T13:51:57.616Z</updated>
  <id>http://fu-jw.com/</id>
  
  <author>
    <name>Fredo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot单元测试</title>
    <link href="http://fu-jw.com/posts/6d37548c.html"/>
    <id>http://fu-jw.com/posts/6d37548c.html</id>
    <published>2023-07-02T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot单元测试"><a href="#SpringBoot单元测试" class="headerlink" title="SpringBoot单元测试"></a>SpringBoot单元测试</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在平时的开发当中，一个项目往往包含了大量的方法，可能有成千上万个。如何去保证这些方法产生的结果是我们想要的呢？</p><p>传统解决方案：Postman 发报文，System.out打印debug日志，或者眼睛看返回报文</p><ol><li>眼睛看结果是否正确，瞅瞎不说，也太不智能.我们是高智商程序员,能让代码解决的事情,绝不能靠人工去解决. </li><li>postman 只能对controller进行测试。controller要正确，前提是service，dao都正确。发现问题太晚，解决成本高。</li><li>对于一些交易系统，由于交易主键的存在，每次都要更改参数后，再进行测试，效率太低。</li><li>无法对内部的函数功能做测试</li><li>postman的测试案例与项目工程不再一起，这些案例只能自己一个人用，无法团队共享</li></ol><p>这时，就轮到单元测试闪亮出场了</p><ul><li>测试代码和工程代码在同一工程文件中，便于维护和传承。 </li><li>使用断言自动检测结果 </li><li>测试粒度小，可以小到每个函数 </li><li>测试模块间相互依赖小。开发完一个模块，就可以测试一个模块。妈妈再也不用担心我犯大错了。</li></ul><h2 id="SpringBoot单元测试-1"><a href="#SpringBoot单元测试-1" class="headerlink" title="SpringBoot单元测试"></a>SpringBoot单元测试</h2><p>业界单元测试一般采用基于<strong>JUnit</strong>和<strong>MockMvc</strong>框架进行</p><ul><li><strong>JUnit</strong>: 是通用测试框架,主要进行Dao层和Service层测试</li><li><strong>MockMvc</strong>: 主要进行Controller层测试</li></ul><h2 id="相关注解"><a href="#相关注解" class="headerlink" title="相关注解"></a>相关注解</h2><p><strong>JUnit5</strong>的注解与<strong>JUnit4</strong>的注解有所变化,详见<a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">官方文档</a></p><ul><li><code>@Test</code>:表示方法是测试方法。但是与<strong>JUnit4</strong>的<code>@Test</code>不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li><li><code>@ParameterizedTest</code>: 表示方法是参数化测试</li><li><code>@RepeatedTest</code>: 表示方法可重复执行</li><li><code>@DisplayName</code>: 为测试类或者测试方法设置展示名称</li><li><code>@BeforeEach</code>: 表示在每个单元测试之前执行</li><li><code>@AfterEach</code>: 表示在每个单元测试之后执行</li><li><code>@BeforeAll</code>: 表示在所有单元测试之前执行</li><li><code>@AfterAll</code>: 表示在所有单元测试之后执行</li><li><code>@Tag</code>: 表示单元测试类别，类似于<strong>JUnit4</strong>中的<code>@Categories</code></li><li><code>@Disabled</code>: 表示测试类或测试方法不执行，类似于<strong>JUnit4</strong>中的<code>@Ignore</code></li><li><code>@Timeout</code>: 表示测试方法运行如果超过了指定时间将会返回错误</li><li><code>@ExtendWith</code>: 为测试类或测试方法提供扩展类引用</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StandardTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span> <span class="comment">//表示在所有单元测试之前执行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始单元测试:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span> <span class="comment">//表示在每个单元测试之前执行</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DisplayName(&quot;测试名称&quot;)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">succeedingTest</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">failingTest</span><span class="params">()</span> &#123;</span><br><span class="line">        fail(<span class="string">&quot;a failing test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@Disabled(&quot;for demonstration purposes&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">skippedTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// not executed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">abortedTest</span><span class="params">()</span> &#123;</span><br><span class="line">        assumeTrue(<span class="string">&quot;abc&quot;</span>.contains(<span class="string">&quot;Z&quot;</span>));</span><br><span class="line">        fail(<span class="string">&quot;test should have been aborted&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行结束...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">tearDownAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;单元测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>assertEquals</td><td>判断两个对象或两个原始类型是否相等</td></tr><tr><td>assertNotEquals</td><td>判断两个对象或两个原始类型是否不相等</td></tr><tr><td>assertSame</td><td>判断两个对象引用是否指向同一个对象</td></tr><tr><td>assertNotSame</td><td>判断两个对象引用是否指向不同的对象</td></tr><tr><td>assertTrue</td><td>判断给定的布尔值是否为 true</td></tr><tr><td>assertFalse</td><td>判断给定的布尔值是否为 false</td></tr><tr><td>assertNull</td><td>判断给定的对象引用是否为 null</td></tr><tr><td>assertNotNull</td><td>判断给定的对象引用是否不为 null</td></tr><tr><td>assertArrayEquals</td><td>数组断言</td></tr><tr><td>assertAll</td><td>组合断言</td></tr><tr><td>assertThrows</td><td>异常断言</td></tr><tr><td>assertTimeout</td><td>超时断言</td></tr><tr><td>fail</td><td>快速失败</td></tr></tbody></table><h2 id="嵌套测试"><a href="#嵌套测试" class="headerlink" title="嵌套测试"></a>嵌套测试</h2><blockquote><p><strong>JUnit5</strong>可以通过Java中的内部类和<code>@Nested</code>注解实现嵌套测试, 从而可以更好的把相关的测试方法组织在一起.<br>在内部类中可以使用<code>@BeforeEach</code>和<code>@AfterEach</code>注解, 而且嵌套的层次没有限制</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@DisplayName(&quot;A stack&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestingAStackDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Object&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">isInstantiatedWithNew</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nested</span></span><br><span class="line">    <span class="meta">@DisplayName(&quot;when new&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WhenNew</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@BeforeEach</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">createNewStack</span><span class="params">()</span> &#123;</span><br><span class="line">            stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;is empty&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">            assertTrue(stack.isEmpty());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::pop);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Test</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">throwsExceptionWhenPeeked</span><span class="params">()</span> &#123;</span><br><span class="line">            assertThrows(EmptyStackException.class, stack::peek);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nested</span></span><br><span class="line">        <span class="meta">@DisplayName(&quot;after pushing an element&quot;)</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">AfterPushing</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">anElement</span> <span class="operator">=</span> <span class="string">&quot;an element&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@BeforeEach</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">pushAnElement</span><span class="params">()</span> &#123;</span><br><span class="line">                stack.push(anElement);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;it is no longer empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">isNotEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when popped and is empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">returnElementWhenPopped</span><span class="params">()</span> &#123;</span><br><span class="line">                assertEquals(anElement, stack.pop());</span><br><span class="line">                assertTrue(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Test</span></span><br><span class="line">            <span class="meta">@DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span></span><br><span class="line">            <span class="keyword">void</span> <span class="title function_">returnElementWhenPeeked</span><span class="params">()</span> &#123;</span><br><span class="line">                assertEquals(anElement, stack.peek());</span><br><span class="line">                assertFalse(stack.isEmpty());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数化测试"><a href="#参数化测试" class="headerlink" title="参数化测试"></a>参数化测试</h2><p>参数化测试是<strong>JUnit5</strong>很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。</p><p>利用<code>@ValueSource</code>等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p><ul><li><code>@ValueSource</code>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型</li><li><code>@NullSource</code>: 表示为参数化测试提供一个null的入参</li><li><code>@EnumSource</code>: 表示为参数化测试提供一个枚举入参</li><li><code>@CsvFileSource</code>：表示读取指定CSV文件内容作为参数化测试入参</li><li><code>@MethodSource</code>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;参数化测试1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">parameterizedTest1</span><span class="params">(String string)</span> &#123;</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    Assertions.assertTrue(StringUtils.isNotBlank(string));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource(&quot;method&quot;)</span>    <span class="comment">//指定方法名</span></span><br><span class="line"><span class="meta">@DisplayName(&quot;方法来源参数&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWithExplicitLocalMethodSource</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    Assertions.assertNotNull(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Stream&lt;String&gt; <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Stream.of(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot单元测试&quot;&gt;&lt;a href=&quot;#SpringBoot单元测试&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot单元测试&quot;&gt;&lt;/a&gt;SpringBoot单元测试&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot;</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot核心特性</title>
    <link href="http://fu-jw.com/posts/dcf57196.html"/>
    <id>http://fu-jw.com/posts/dcf57196.html</id>
    <published>2023-07-02T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot核心特性"><a href="#SpringBoot核心特性" class="headerlink" title="SpringBoot核心特性"></a>SpringBoot核心特性</h1><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html">官方文档:</a></p><blockquote><p>Spring Application: SpringApplication<br>External Configuration: External Configuration<br>Profiles: Profiles<br>Logging: Logging</p></blockquote><h2 id="1-SpringApplication"><a href="#1-SpringApplication" class="headerlink" title="1.SpringApplication"></a>1.SpringApplication</h2><p><code>SpringApplication</code>简化了Spring程序的启动过程.<br>大多数情况下, 可以委托给静态<code>SpringApplication.run</code>方法, 如以下示例所示:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动日志:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot ::                (v3.1.0)</span><br><span class="line"></span><br><span class="line">2023-07-05T14:07:10.668+08:00  INFO 9584 --- [           main] com.fredo.Main                           : Starting Main using Java 17.0.2 with PID 9584 (D:\Develop\Projects\ideaProject\spring-tutorial\spring-boot\demo05-features\target\classes started by Administrator in D:\Develop\Projects\ideaProject\spring-tutorial)</span><br><span class="line">2023-07-05T14:07:10.673+08:00  INFO 9584 --- [           main] com.fredo.Main                           : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2023-07-05T14:07:12.122+08:00  INFO 9584 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="line">2023-07-05T14:07:12.123+08:00  INFO 9584 --- [           main] o.a.catalina.core.AprLifecycleListener   : An older version [1.2.34] of the Apache Tomcat Native library is installed, while Tomcat recommends a minimum version of [2.0.1]</span><br><span class="line">2023-07-05T14:07:12.123+08:00  INFO 9584 --- [           main] o.a.catalina.core.AprLifecycleListener   : Loaded Apache Tomcat Native library [1.2.34] using APR version [1.7.0].</span><br><span class="line">2023-07-05T14:07:12.140+08:00  INFO 9584 --- [           main] o.a.catalina.core.AprLifecycleListener   : OpenSSL successfully initialized [OpenSSL 1.1.1o  3 May 2022]</span><br><span class="line">2023-07-05T14:07:12.159+08:00  INFO 9584 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2023-07-05T14:07:12.159+08:00  INFO 9584 --- [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.8]</span><br><span class="line">2023-07-05T14:07:12.356+08:00  INFO 9584 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2023-07-05T14:07:12.360+08:00  INFO 9584 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1596 ms</span><br><span class="line">2023-07-05T14:07:13.208+08:00  INFO 9584 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#x27;&#x27;</span><br><span class="line">2023-07-05T14:07:13.219+08:00  INFO 9584 --- [           main] com.fredo.Main                           : Started Main in 3.223 seconds (process running for 4.118)</span><br></pre></td></tr></table></figure><p>注意: 只有前两行和最后一行是SpringBoot的<strong>启动日志</strong><br>启动日志可以关闭:</p><ul><li>配置文件</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.main.log-startup-info</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><ul><li>代码:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SpringApplication application=<span class="keyword">new</span> <span class="title class_">SpringApplication</span>(Main.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭启动日志(注意:配置文件的优先级大于代码优先级!!!)</span></span><br><span class="line">        application.setLogStartupInfo(<span class="literal">false</span>);</span><br><span class="line">        application.run(args);</span><br></pre></td></tr></table></figure><h3 id="1-启动失败"><a href="#1-启动失败" class="headerlink" title="1.启动失败"></a>1.启动失败</h3><p>如果应用程序无法启动, 已注册的<code>FailureAnalyzers</code>将有机会提供专用的错误消息和解决问题的具体操作<br>以端口占用为例:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Embedded servlet container failed to start. Port 8080 was already in use.</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Identify and stop the process that is listening on port 8080 or configure this application to listen on another port.</span><br></pre></td></tr></table></figure><p><code>FailureAnalyzers</code>是一个用于分析应用程序失败原因的工具.当应用程序发生失败时,<code>FailureAnalyzers</code>会收集失败信息,<br>并分析失败原因,以便开发人员能够更好地理解应用程序的健康状况.</p><p>可自定义:</p><ul><li>1.自定义类继承<code>AbstractFailureAnalyzer</code>,并重写<code>analyze</code>方法.可参考:<code>BindValidationFailureAnalyzer</code></li><li>2.注册在META-INF&#x2F;spring.factories 文件中</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">com.fredo.custom.MyFailureAnalyzer</span><br></pre></td></tr></table></figure><h3 id="2-延迟初始化"><a href="#2-延迟初始化" class="headerlink" title="2.延迟初始化"></a>2.延迟初始化</h3><p>在容器启动时不初始化Bean,只有在第一次使用时再初始化</p><p>配置方法:</p><ul><li>配置文件</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.main.lazy-initialization</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><ul><li>代码:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启延迟初始化(默认关闭,不建议开启)</span></span><br><span class="line">application.setLazyInitialization(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>可以使用注解<code>@Lazy(false)</code>, 单独指定某些Bean延迟初始化</p><h3 id="3-自定义Banner"><a href="#3-自定义Banner" class="headerlink" title="3.自定义Banner"></a>3.自定义Banner</h3><p>Banner 就是程序启动时最上面的信息</p><p>类路径添加文件:<strong>banner.txt</strong>或设置<code>spring.banner.location</code>就可以定制 Banner<br><a href="https://www.bootschool.net/ascii">推荐网址</a></p><p>关闭</p><ul><li>配置文件</li></ul><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.main.banner-mode</span>=<span class="string">off</span></span><br></pre></td></tr></table></figure><ul><li>代码:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭Banner,默认值:CONSOLE</span></span><br><span class="line">application.setBannerMode(Banner.Mode.OFF);</span><br></pre></td></tr></table></figure><h3 id="4-自定义SpringApplication"><a href="#4-自定义SpringApplication" class="headerlink" title="4.自定义SpringApplication"></a>4.自定义SpringApplication</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">  SpringApplication application=<span class="keyword">new</span> <span class="title class_">SpringApplication</span>(Main.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭启动日志(注意:配置文件的优先级大于代码优先级!!!)</span></span><br><span class="line">  application.setLogStartupInfo(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开启延迟初始化(默认关闭,不建议开启)</span></span><br><span class="line">  application.setLazyInitialization(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭Banner,默认值:CONSOLE</span></span><br><span class="line"><span class="comment">//        application.setBannerMode(Banner.Mode.OFF);</span></span><br><span class="line"></span><br><span class="line">  application.run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义信息在<code>application.properties</code>中,<br>具体可<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config">参考官网</a></p><h3 id="5-流式构造API"><a href="#5-流式构造API" class="headerlink" title="5.流式构造API"></a>5.流式构造API</h3><p>可用于构建父子层次结构</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">SpringApplicationBuilder</span>()</span><br><span class="line">  .sources(Main.class) <span class="comment">// 父</span></span><br><span class="line">  .child(Main.class) <span class="comment">// 子,非必须</span></span><br><span class="line">  .bannerMode(Banner.Mode.OFF)</span><br><span class="line">  .run(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-配置文件隔离"><a href="#2-配置文件隔离" class="headerlink" title="2.配置文件隔离"></a>2.配置文件隔离</h2><blockquote><p>环境隔离: 快速切换开发、测试、生产环境<br>步骤：</p><ol><li>标识环境：指定哪些组件、配置在哪个环境生效</li><li>切换环境：这个环境对应的所有组件和配置就应该生效</li></ol></blockquote><h3 id="1-指定环境"><a href="#1-指定环境" class="headerlink" title="1.指定环境"></a>1.指定环境</h3><p>Spring Profiles 提供一种隔离配置的方式, 使其仅在特定环境生效<br>任何组件都可用<code>@Profile</code>标记, 来指定何时被加载</p><p>例如:</p><ul><li>dev环境: @Profile({“dev”})</li><li>dev和prod环境: @Profile({“dev”, “prod”})</li></ul><h3 id="2-激活环境"><a href="#2-激活环境" class="headerlink" title="2.激活环境"></a>2.激活环境</h3><p>配置文件激活</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">prod</span></span><br></pre></td></tr></table></figure><p>命令行激活</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=prod</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>不标注<code>@Profile</code>的组件无论是在哪个环境中都会激活</li><li>存在默认环境<code>@Profile(&#123;&quot;default&quot;&#125;)</code>,需要激活默认环境才有效</li><li>也可以设置默认激活的环境, <code>spring.profiles.default=dev</code></li><li>推荐使用激活方式激活指定环境</li></ul><h3 id="3-环境包含"><a href="#3-环境包含" class="headerlink" title="3.环境包含"></a>3.环境包含</h3><p>在配置文件(必须是在主配置文件中)中设置:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.include[0]</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.profiles.include[1]</span>=<span class="string">test</span></span><br><span class="line"><span class="attr">或者</span>:<span class="string"></span></span><br><span class="line"><span class="attr">spring.profiles.include</span>=<span class="string">dev,test</span></span><br></pre></td></tr></table></figure><h4 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4.最佳实践"></a>4.最佳实践</h4><p><strong>生效的环境 &#x3D; 激活的环境&#x2F;默认环境 + 包含的环境</strong></p><p>项目中:</p><ul><li>基础的配置<code>mybatis</code>,<code>log</code>,…：写到<strong>包含环境</strong>中</li><li>要动态切换变化的<code>db</code>, <code>redis</code>,…：写到<strong>激活的环境</strong>中</li></ul><h4 id="5-Profile-分组"><a href="#5-Profile-分组" class="headerlink" title="5.Profile 分组"></a>5.Profile 分组</h4><p>创建prod组，指定包含db和mq配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.group.prod[0]</span>=<span class="string">db</span></span><br><span class="line"><span class="attr">spring.profiles.group.prod[1]</span>=<span class="string">mq</span></span><br></pre></td></tr></table></figure><p>使用<code>--spring.profiles.active=prod</code>, 就会激活prod, 就会使用db, mq配置文件</p><h4 id="6-Profile-配置文件"><a href="#6-Profile-配置文件" class="headerlink" title="6.Profile 配置文件"></a>6.Profile 配置文件</h4><ul><li><code>application-&#123;profile&#125;.properties</code>可以作为指定环境的配置文件</li><li>激活这个环境，配置就会生效。最终生效的所有配置是<ul><li><code>application.properties</code>：主配置文件，任意时候都生效</li><li><code>application-&#123;profile&#125;.properties</code>：指定环境配置文件，激活指定环境生效</li></ul></li></ul><p>profile优先级 &gt; application</p><h2 id="3-外置配置文件"><a href="#3-外置配置文件" class="headerlink" title="3.外置配置文件"></a>3.外置配置文件</h2><blockquote><p>场景：线上应用如何快速修改配置，并应用最新配置？</p><ul><li>SpringBoot 使用  <strong>配置优先级</strong> + <strong>外部配置</strong>  简化配置更新、简化运维。</li><li>只需要给jar应用所在的文件夹放一个<code>application.properties</code>最新配置文件，重启项目就能自动应用最新配置</li></ul></blockquote><p>SpringBoot允许将配置外部化, 以便可以在不同的环境中使用相同的应用程序代码.<br>我们可以使用各种<strong>外部配置源</strong>, 包括<strong>Java Properties文件</strong>、<strong>YAML文件</strong>、<strong>环境变量</strong>和<strong>命令行参数</strong>。</p><p><code>@Value</code>可以获取值, 也可以用<code>@ConfigurationProperties</code>将所有属性<strong>绑定</strong>到java object中</p><h3 id="1-配置优先级"><a href="#1-配置优先级" class="headerlink" title="1.配置优先级"></a>1.配置优先级</h3><p>以下是SpringBoot属性源加载顺序。<strong>由低到高，高优先级配置覆盖低优先级</strong></p><ol><li><strong>默认属性</strong>（通过<code>SpringApplication.setDefaultProperties</code>指定的）</li><li><code>@PropertySource</code>指定加载的配置（需要写在<code>@Configuration</code>类上才可生效）</li><li>配置文件（application.properties&#x2F;yml等）</li><li><code>RandomValuePropertySource</code>支持的<code>random.*</code>配置（如：<code>@Value(&quot;$&#123;random.int&#125;&quot;)</code>）</li><li>OS 环境变量</li><li>Java 系统属性（System.getProperties()）</li><li>JNDI 属性（来自java:comp&#x2F;env）</li><li>ServletContext 初始化参数</li><li>ServletConfig 初始化参数</li><li>SPRING_APPLICATION_JSON属性（内置在环境变量或系统属性中的 JSON）</li><li><strong>命令行参数</strong></li><li>测试属性。(@SpringBootTest进行测试时指定的属性)</li><li>测试类@TestPropertySource注解</li><li>Devtools 设置的全局属性。($HOME&#x2F;.config&#x2F;spring-boot)</li></ol><p>小结一下:<br>常见的优先级顺序：<br>命令行&gt; 配置文件&gt; springapplication配置</p><p><strong>配置文件优先级如下</strong>：(后面覆盖前面)</p><ol><li>jar 包内的application.properties&#x2F;yml</li><li>jar 包内的application-{profile}.properties&#x2F;yml</li><li>jar 包外的application.properties&#x2F;yml</li><li>jar 包外的application-{profile}.properties&#x2F;yml</li></ol><blockquote><p>建议：用一种格式的配置文件。如果.properties和.yml同时存在,则.properties优先</p></blockquote><p>小结一下:</p><ul><li>包外 &gt; 包内</li><li>同级情况：profile配置 &gt; application配置</li></ul><p>所有参数均可由命令行传入，使用<code>--参数项=参数值</code>，将会被添加到环境变量中，并优先于配置文件<br>比如<code>java -jar app.jar --name=&quot;Spring&quot;</code>,可以使用<code>@Value(&quot;$&#123;name&#125;&quot;)</code>获取</p><p>演示场景：</p><ul><li>包内： application.properties   server.port&#x3D;8000</li><li>包内： application-dev.properties    server.port&#x3D;9000</li><li>包外：  application.properties   server.port&#x3D;8001</li><li>包外： application-dev.properties    server.port&#x3D;9001</li></ul><p>启动端口: 命令行 &gt; 9001 &gt; 8001 &gt; 9000 &gt; 8000</p><h3 id="2-外部配置"><a href="#2-外部配置" class="headerlink" title="2.外部配置"></a>2.外部配置</h3><p>SpringBoot 应用启动时会自动寻找<strong>application.properties</strong>和<strong>application.yaml</strong>位置进行加载.<br>顺序如下：（后面覆盖前面）</p><ul><li>类路径: 内部<ul><li>类根路径</li><li>类下<code>/config</code>包</li></ul></li><li>当前路径（项目所在的位置）<ul><li>当前路径</li><li>当前下<code>/config</code>子目录</li><li><code>/config</code>目录的直接子目录</li></ul></li></ul><p>最终效果：优先级由高到低，前面覆盖后面</p><ul><li>命令行 &gt; 包外config直接子目录 &gt; 包外config目录 &gt; 包外根目录 &gt; 包内目录</li><li>同级比较：<ul><li>profile配置 &gt; 默认配置</li><li>properties配置 &gt; yaml配置</li></ul></li></ul><img alt="配置优先级" src="https://image.fu-jw.com/img/2023/07/06/64a67fc67db26.png"/><p>规律：最外层的最优先</p><ul><li>命令行 &gt; 所有</li><li>包外 &gt; 包内</li><li>config目录 &gt; 根目录</li><li>profile &gt; application</li></ul><p>配置不同就都生效（互补），配置相同高优先级覆盖低优先级</p><h3 id="3-导入配置"><a href="#3-导入配置" class="headerlink" title="3.导入配置"></a>3.导入配置</h3><p>使用<code>spring.config.import</code>可以导入额外配置</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.config.import</span>=<span class="string">my.properties</span></span><br><span class="line"><span class="attr">my.property</span>=<span class="string">value</span></span><br></pre></td></tr></table></figure><p>无论以上写法的先后顺序, <strong>my.properties</strong>的值总是优先于直接在文件中编写的<strong>my.property</strong></p><h3 id="4-属性占位符"><a href="#4-属性占位符" class="headerlink" title="4.属性占位符"></a>4.属性占位符</h3><p>配置文件中可以使用<code>$&#123;name:default&#125;</code>形式取出之前配置过的值</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="attr">app.description</span>=<span class="string">$&#123;app.name&#125; is a Spring Boot application written by $&#123;username:Unknown&#125;</span></span><br></pre></td></tr></table></figure><h2 id="4-日志"><a href="#4-日志" class="headerlink" title="4.日志"></a>4.日志</h2><p>详细可参考<a href="https://blog.fu-jw.com/posts/4275e528.html">SpringBoot日志</a></p><h2 id="5-单元测试-JUnit5"><a href="#5-单元测试-JUnit5" class="headerlink" title="5.单元测试-JUnit5"></a>5.单元测试-JUnit5</h2><p>详细可参考<a href="http://localhost:4000/posts/6d37548c.html">SpringBoot单元测试</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot核心特性&quot;&gt;&lt;a href=&quot;#SpringBoot核心特性&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot核心特性&quot;&gt;&lt;/a&gt;SpringBoot核心特性&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://docs.</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发1-自动配置原理浅析</title>
    <link href="http://fu-jw.com/posts/d5a9e6d8.html"/>
    <id>http://fu-jw.com/posts/d5a9e6d8.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-Web开发1-自动配置原理浅析"><a href="#SpringBoot-Web开发1-自动配置原理浅析" class="headerlink" title="SpringBoot Web开发1-自动配置原理浅析"></a>SpringBoot Web开发1-自动配置原理浅析</h1><blockquote><p>我的<a href="https://github.com/fu-jw/spring-tutorial">SpringBoot项目</a>第四个模块</p></blockquote><p>由前面<a href="https://blog.fu-jw.com/posts/4ccc97e8.html">SpringBoot快速入门</a>分析可知,SpringBoot提出场景启动器的概念,<br>将场景中需要的所有依赖囊括进来,并自动装配,简化配置.<br>场景一引入,配置即完成</p><p>web开发同样需要<strong>web场景启动器</strong></p><h2 id="0-引入web场景启动器"><a href="#0-引入web场景启动器" class="headerlink" title="0.引入web场景启动器"></a>0.引入web场景启动器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-boot-starter-web</code>依赖<strong>核心场景启动器:</strong><code>spring-boot-starter</code><br><code>spring-boot-starter</code>依赖:<code>spring-boot-autoconfigure</code><br><code>spring-boot-autoconfigure</code>会加载:META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports<br>中的自动配置类<br>其中web相关有如下:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</span><br><span class="line">------------------------------以下是响应式编程相关--------------------------------------</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveMultipartAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebSessionIdResolverAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration</span><br></pre></td></tr></table></figure><p>上面的自动配置类会绑定的配置有:</p><ul><li><code>server</code> &#x3D;&#x3D;&gt;服务器相关</li><li><code>spring.mvc</code> &#x3D;&#x3D;&gt;springMVC相关</li><li><code>server.servlet.encoding</code> &#x3D;&#x3D;&gt;servlet编码相关</li><li><code>spring.servlet.multipart</code> &#x3D;&#x3D;&gt;servlet文件处理相关</li></ul><p>SpringBoot 的自动装配功能在<code>web场景</code>中添加了如下特性:</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/web.html#web.servlet.spring-mvc">官网介绍</a>:</p><blockquote><ol><li>Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans.</li><li>Support for serving static resources, including support for WebJars (covered later in this document).</li><li>Automatic registration of Converter, GenericConverter, and Formatter beans.</li><li>Support for HttpMessageConverters (covered later in this document).</li><li>Automatic registration of MessageCodesResolver (covered later in this document).</li><li>Static index.html support.</li><li>Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document).</li></ol><p>If you want to keep those Spring Boot MVC customizations and make more<br>MVC customizations (interceptors, formatters, view controllers, and other features),<br>you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc.</p><p>If you want to provide custom instances of RequestMappingHandlerMapping,<br>RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver,<br>and still keep the Spring Boot MVC customizations, you can declare a bean of<br>type WebMvcRegistrations and use it to provide custom instances of those components.</p><p>If you want to take complete control of Spring MVC,<br>you can add your own @Configuration annotated with @EnableWebMvc,<br>or alternatively add your own @Configuration-annotated DelegatingWebMvcConfiguration<br>as described in the Javadoc of @EnableWebMvc</p></blockquote><p><code>web场景</code>引入后,就有了如下功能:</p><ol><li>包含<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>组件,方便视图解析</li><li>默认的静态资源处理机制: 静态资源放在<strong>static</strong>文件夹下即可直接访问</li><li>自动注册了<code>Converter</code>,<code>GenericConverter</code>,<code>Formatter</code>组件,适配常见<strong>数据类型转换</strong>和<strong>格式化</strong>需求</li><li>支持<code>HttpMessageConverters</code>,可以方便返回json等数据类型</li><li>自动注册<code>MessageCodesResolver</code>,方便<strong>国际化</strong>及错误消息处理</li><li>支持静态 index.html</li><li>自动使用<code>ConfigurableWebBindingInitializer</code>,实现<strong>消息处理</strong>,<strong>数据绑定</strong>,<strong>类型转化</strong>,<strong>数据校验</strong>等功能</li></ol><p>注意:</p><ul><li>如果想保持 SpringBoot MVC 的默认配置,并且自定义更多的 MVC 配置,如:<code>interceptors</code>,<code>formatters</code>,<code>view controllers</code><br>等.可以使用<code>@Configuration</code>注解添加一个<strong>WebMvcConfigurer</strong>类型的配置类,但不要标注<code>@EnableWebMvc</code></li><li>如果想保持 SpringBoot MVC<br>的默认配置,但要自定义核心组件实例,比如:<code>RequestMappingHandlerMapping</code>,<code>RequestMappingHandlerAdapter</code><br>,或<code>ExceptionHandlerExceptionResolver</code>,给容器中放一个<code>WebMvcRegistrations</code>组件即可</li><li>如果想全面接管 Spring MVC,<code>@Configuration</code>标注一个配置类,并加上<code>@EnableWebMvc</code>注解,实现<strong>WebMvcConfigurer</strong>接口</li></ul><p>接下来分别展开分析.</p><h2 id="1-自动配置原理浅析"><a href="#1-自动配置原理浅析" class="headerlink" title="1.自动配置原理浅析"></a>1.自动配置原理浅析</h2><p>由前面知道引入<code>web场景</code>会加载自动配置类:<code>WebMvcAutoConfiguration</code></p><p>下面简要分析<code>WebMvcAutoConfiguration</code>原理</p><h3 id="1-生效条件"><a href="#1-生效条件" class="headerlink" title="1.生效条件"></a>1.生效条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration(after = &#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span></span><br><span class="line"><span class="meta">        ValidationAutoConfiguration.class&#125;)</span> <span class="comment">// 需要在这三个自动配置之后</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span> <span class="comment">// //需要是普通的SERVLET类型的 web应用就生效,REACTIVE类型的响应式web是另一套</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span> <span class="comment">// 需要包括这三个类</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span> <span class="comment">// 需要容器中没有这个bean</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span> <span class="comment">// 优先级</span></span><br><span class="line"><span class="meta">@ImportRuntimeHints(WebResourcesRuntimeHints.class)</span></span><br><span class="line"><span class="comment">// 项目启动就注册的静态资源:&quot;META-INF/resources/&quot;,&quot;resources/&quot;,&quot;static/&quot;,&quot;public/&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生效后, 在容器中放入两个bean:</p><h3 id="2-HiddenHttpMethodFilter-过滤页面表单提交的Rest请求"><a href="#2-HiddenHttpMethodFilter-过滤页面表单提交的Rest请求" class="headerlink" title="2.HiddenHttpMethodFilter: 过滤页面表单提交的Rest请求"></a>2.<code>HiddenHttpMethodFilter</code>: 过滤页面表单提交的Rest请求</h3><blockquote><ul><li>Rest 请求有: <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, <code>PATCH</code></li><li>请求数据包含三部分: <strong>请求行</strong>, <strong>请求头</strong>, <strong>请求体</strong></li><li>浏览器只能发送<code>GET</code>请求和<code>POST</code>请求</li><li><code>GET</code>请求没有<strong>请求体</strong>, 参数在<strong>请求行</strong>中,获取参数的方法是<code>getQueryString()</code></li><li><code>POST</code>请求的参数在<strong>请求体</strong>中, 获取方法是<code>getReader()</code>或<code>getInputStream()</code></li><li>getMethod() 获取具体哪种请求方式</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法将浏览器不支持的请求,转换成标准的HTTP方法:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将发出请求的方法参数转换为 HTTP 方法，可通过 HttpServletRequest.getMethod() 检索。</span></span><br><span class="line"><span class="comment"> * 由于浏览器目前仅支持GET和POST，通常是使用带有附加隐藏表单字段（_method）的普通POST来传递“真正的”HTTP方法。</span></span><br><span class="line"><span class="comment"> * 例如:&lt;form action=&quot;...&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="comment"> *       &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot; /&gt;</span></span><br><span class="line"><span class="comment"> *       ......</span></span><br><span class="line"><span class="comment"> *     &lt;/form&gt;</span></span><br><span class="line"><span class="comment"> * 此过滤器读取该参数并相应地更改 HttpServletRequestWrapper.getMethod（） 返回值。</span></span><br><span class="line"><span class="comment"> * 只允许使用“PUT”、“DELETE”和“PATCH” HTTP方法。</span></span><br><span class="line"><span class="comment"> * 请求参数的名称默认为 _method，但可以通过 methodParam 属性进行调整。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：在大部分 POST 请求的情况下，此过滤器需要在 MultipartFilter 处理后运行，因为它本来就需要检查 POST 正文参数。</span></span><br><span class="line"><span class="comment"> * 所以通常，在你的web.xml过滤器链中，在隐藏的HttpMethodFilter之前放置一个 </span></span><br><span class="line"><span class="comment"> * Spring org.springframework.web.multipart.support.MultipartFilter。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 即在此过滤之前会有专门处理 POST 请求的 MultipartFilter.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiddenHttpMethodFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; ALLOWED_METHODS =</span><br><span class="line">            List.of(HttpMethod.PUT.name(), HttpMethod.DELETE.name(), HttpMethod.PATCH.name());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">requestToUse</span> <span class="operator">=</span> request;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(request.getMethod()) &amp;&amp; request.getAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">paramValue</span> <span class="operator">=</span> request.getParameter(<span class="built_in">this</span>.methodParam);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(paramValue)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> paramValue.toUpperCase(Locale.ENGLISH);</span><br><span class="line">              <span class="keyword">if</span> (ALLOWED_METHODS.contains(method)) &#123;</span><br><span class="line">                requestToUse = <span class="keyword">new</span> <span class="title class_">HttpMethodRequestWrapper</span>(request, method);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      filterChain.doFilter(requestToUse, response);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-FormContentFilter-用于分析表单内容-与前面的过滤器配合使用"><a href="#3-FormContentFilter-用于分析表单内容-与前面的过滤器配合使用" class="headerlink" title="3.FormContentFilter:用于分析表单内容, 与前面的过滤器配合使用,"></a>3.<code>FormContentFilter</code>:用于分析表单内容, 与前面的过滤器配合使用,</h3><p>同样只针对<code>PUT</code>,<code>PATCH</code>,<code>DELETE</code>三种HTTP请求</p><h3 id="4-静态内部类WebMvcAutoConfigurationAdapter"><a href="#4-静态内部类WebMvcAutoConfigurationAdapter" class="headerlink" title="4.静态内部类WebMvcAutoConfigurationAdapter"></a>4.静态内部类<code>WebMvcAutoConfigurationAdapter</code></h3><p>在<code>WebMvcAutoConfiguration</code>中有静态内部类<code>WebMvcAutoConfigurationAdapter</code>源码如下:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Defined as a nested config to ensure WebMvcConfigurer is not read when not on the classpath</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, WebProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>, ServletContextAware &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口WebMvcConfigurer"><a href="#接口WebMvcConfigurer" class="headerlink" title="接口WebMvcConfigurer"></a>接口<code>WebMvcConfigurer</code></h4><p><code>WebMvcAutoConfigurationAdapter</code>实现了<code>WebMvcConfigurer</code>接口,可以重写一些有关Web MVC的配置方法,比如添加拦截器、配置视图解析器、配置静态资源等.<br>通过重写这些方法,可以根据自己的需要定制化Web MVC的行为.可定制功能有:</p><img src="https://image.fu-jw.com/img/2023/07/01/649f85725fe98.webp" alt="WebMvcConfigurer"/><ul><li>addArgumentResolvers:添加参数解析器</li><li>addCorsMappings:添加跨域映射</li><li>addFormatters:添加格式化器</li><li>addInterceptors:添加拦截器</li><li>addResourceHandlers:添加资源处理器,处理静态资源规则</li><li>addReturnValueHandlers:添加返回值处理器</li><li>addViewControllers:添加视图控制器,指定某个请求路径跳转到指定页面</li><li>configureAsyncSupport:配置异步支持</li><li>configureContentNegotiation:配置内容协商</li><li>configureDefaultServletHandling:配置默认的处理,默认接收: &#x2F;</li><li>configureHandlerExceptionResolvers:配置异常解析器</li><li>configureMessageConverters:配置消息转化器</li><li>configurePathMatch:配置路径匹配</li><li>configureViewResolvers:配置视图解析器</li><li>extendHandlerExceptionResolvers:扩展处理异常解析器</li><li>extendMessageConverters扩展消息转换器</li><li>getMessageCodesResolver:获取消息编码解析器</li><li>getValidator:获取校验器</li></ul><h4 id="静态资源规则源码浅析"><a href="#静态资源规则源码浅析" class="headerlink" title="静态资源规则源码浅析"></a>静态资源规则源码浅析</h4><p>由上面分析,<code>addResourceHandlers</code>用来处理静态资源,源码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVLET_LOCATION=<span class="string">&quot;/&quot;</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add handlers to serve static resources such as images, js, and, css files from specific locations under web application root, the classpath,and others.</span></span><br><span class="line"><span class="comment"> * 即根据配置情况，添加不同的静态资源处理器，用于处理静态资源的访问请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否需要启用默认的资源处理。</span></span><br><span class="line">  <span class="comment">// 如果不需要启用，默认资源处理被禁用，同时输出调试信息，并直接返回</span></span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">this</span>.resourceProperties.isAddMappings())&#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Default resource handling disabled&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 需要启用默认资源处理,下面添加两种静态资源处理规则</span></span><br><span class="line">    <span class="comment">// private String webjarsPathPattern = &quot;/webjars/**&quot;;        </span></span><br><span class="line">    <span class="comment">// 访问路径:/webjars/**, 就去路径:classpath:/META-INF/resources/webjars/ 下面找对应资源</span></span><br><span class="line">    addResourceHandler(registry,<span class="built_in">this</span>.mvcProperties.getWebjarsPathPattern(),</span><br><span class="line">    <span class="string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);</span><br><span class="line">    <span class="comment">// private String staticPathPattern = &quot;/**&quot;;</span></span><br><span class="line">    <span class="comment">// private String[] staticLocations = </span></span><br><span class="line">    <span class="comment">// &quot;classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot;</span></span><br><span class="line">    addResourceHandler(registry,<span class="built_in">this</span>.mvcProperties.getStaticPathPattern(),(registration)-&gt;&#123;</span><br><span class="line">    registration.addResourceLocations(<span class="built_in">this</span>.resourceProperties.getStaticLocations());</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.servletContext!=<span class="literal">null</span>)&#123;</span><br><span class="line">       ServletContextResource resource=<span class="keyword">new</span> <span class="title class_">ServletContextResource</span>(<span class="built_in">this</span>.servletContext,SERVLET_LOCATION);</span><br><span class="line">       registration.addResourceLocations(resource);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向资源处理器注册表中添加资源处理器,并根据配置文件和自定义函数设置资源处理器的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addResourceHandler</span><span class="params">(ResourceHandlerRegistry registry,String pattern,Consumer&lt;ResourceHandlerRegistration&gt; customizer)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否已经存在了指定的pattern</span></span><br><span class="line">    <span class="keyword">if</span>(registry.hasMappingForPattern(pattern))&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个资源处理器注册（ResourceHandlerRegistration）对象</span></span><br><span class="line">    ResourceHandlerRegistration registration=registry.addResourceHandler(pattern);</span><br><span class="line">    <span class="comment">// 将刚才创建的资源处理器注册对象作为参数，用于自定义资源处理器的属性</span></span><br><span class="line">    customizer.accept(registration);</span><br><span class="line">    <span class="comment">// 根据配置文件中的缓存时间设置资源处理器的缓存时间（cache period），以及缓存控制（cache control）策略</span></span><br><span class="line">   registration.setCachePeriod(getSeconds(<span class="built_in">this</span>.resourceProperties.getCache().getPeriod()));</span><br><span class="line">    registration.setCacheControl(<span class="built_in">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());</span><br><span class="line">    registration.setUseLastModified(<span class="built_in">this</span>.resourceProperties.getCache().isUseLastModified());</span><br><span class="line">    <span class="comment">// 进一步自定义资源处理器注册对象的属性</span></span><br><span class="line">    customizeResourceHandlerRegistration(registration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结一下:<br>静态资源访问规则如下:</p><ul><li>规则一 访问： <code>/webjars/**</code>路径就去<code>classpath:/META-INF/resources/webjars/</code>下找资源.</li><li>规则二 访问： <code>/**</code>路径就去 静态资源默认的四个位置找资源<ul><li><code>classpath:/META-INF/resources/</code></li><li><code>classpath:/resources/</code></li><li><code>classpath:/static/</code></li><li><code>classpath:/public/</code></li></ul></li><li>规则三 静态资源默认都有<strong>缓存规则</strong>的设置<ul><li>所有缓存的设置, 直接通过配置文件:<code>spring.web</code></li><li>cachePeriod: 缓存周期; 多久不用找服务器要新的, 默认没有，以秒为单位</li><li>cacheControl: <strong>HTTP缓存控制</strong>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching">查看文档</a></li><li>useLastModified：是否使用最后一次修改, 配合HTTP Cache规则, 如果浏览器访问了一个静态资源</li></ul></li></ul><blockquote><p>如果浏览器访问了一个静态资源 index.js，如果服务这个资源没有发生变化，下次访问的时候就可以直接让浏览器用自己缓存中的东西，而不用给服务器发请求</p></blockquote><h4 id="HTTP缓存实验"><a href="#HTTP缓存实验" class="headerlink" title="HTTP缓存实验"></a>HTTP缓存实验</h4><p>设置如下:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1、spring.web：</span></span><br><span class="line"><span class="comment"># 1.配置国际化的区域信息(locale)</span></span><br><span class="line"><span class="comment"># 2.静态资源策略(开启、处理链、缓存)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">true</span> <span class="comment"># 开启静态资源映射规则,默认true</span></span><br><span class="line">      <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">period:</span> <span class="number">3600</span> <span class="comment"># 单位是 秒, 此为简要设置, 下面(cache-control)是详细配置,会覆盖period</span></span><br><span class="line">        <span class="attr">cache-control:</span></span><br><span class="line">          <span class="attr">max-age:</span> <span class="number">7200</span> <span class="comment"># 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span></span><br><span class="line">        <span class="attr">use-last-modified:</span> <span class="literal">true</span> <span class="comment"># 默认true, 使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304</span></span><br></pre></td></tr></table></figure><p>第一次请求:</p><img src="https://image.fu-jw.com/img/2023/07/01/649f850bd24ec.webp" alt="第一次请求"/><p>第二次请求:</p><img src="https://image.fu-jw.com/img/2023/07/01/649f85350e56a.webp" alt="第二次请求"/><h3 id="5-自定义静态资源"><a href="#5-自定义静态资源" class="headerlink" title="5.自定义静态资源"></a>5.自定义静态资源</h3><p>大体分为两种方式:</p><ul><li>配置文件的方式</li><li>代码的方式</li></ul><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@Import(EnableWebMvcConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, WebProperties.class&#125;)</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WebMvcAutoConfigurationAdapter</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span>, ServletContextAware &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与两个配置文件绑定<code>WebMvcProperties.class</code>和<code>WebProperties.class</code>,<br>即以<code>spring.web</code>和<code>spring.mvc</code>开头的配置</p><ul><li><code>spring.web</code>:可配置locale(国际化)和resources(静态资源相关),具体可查看<code>WebProperties.class</code></li><li><code>spring.mvc</code>:可配置内容很多,具体可查看<code>WebMvcProperties.class</code></li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">true</span> <span class="comment"># 开启静态资源映射规则,默认true</span></span><br><span class="line">      <span class="attr">cache:</span></span><br><span class="line">        <span class="attr">period:</span> <span class="number">3600</span> <span class="comment"># 单位是 秒, 此为简要设置, 下面(cache-control)是详细配置,会覆盖period</span></span><br><span class="line">        <span class="attr">cache-control:</span></span><br><span class="line">          <span class="attr">max-age:</span> <span class="number">7200</span> <span class="comment"># 浏览器第一次请求服务器，服务器告诉浏览器此资源缓存7200秒，7200秒以内的所有此资源访问不用发给服务器请求，7200秒以后发请求给服务器</span></span><br><span class="line">        <span class="attr">use-last-modified:</span> <span class="literal">true</span> <span class="comment"># 默认true, 使用资源 last-modified 时间，来对比服务器和浏览器的资源是否相同没有变化。相同返回 304</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">classpath:/static/,classpath:/test/</span> <span class="comment"># 自定义静态资源目录,按顺序访问</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">webjars-path-pattern:</span> <span class="string">/webjars/**</span> <span class="comment"># 自定义webjars路径前缀,默认:/webjars/**</span></span><br><span class="line">    <span class="attr">static-path-pattern:</span> <span class="string">/static/**</span> <span class="comment"># 静态资源访问路径前缀,默认:/**</span></span><br></pre></td></tr></table></figure><h4 id="代码方式"><a href="#代码方式" class="headerlink" title="代码方式"></a>代码方式</h4><p>就是在容器中放置组件:<code>WebMvcConfigurer</code>,来配置底层.</p><p>注意:</p><ul><li>默认配置仍有效</li><li>加上<code>@EnableWebMvc</code>会将默认配置失效</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> WebMvcConfigurer <span class="title function_">webMvcConfigurer</span><span class="params">()</span> &#123;<span class="comment">// 与下面代码一样效果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WebMvcConfigurer</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">&quot;/static&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123; <span class="comment">// 还可以上面写法,效果一样</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 保留默认配置</span></span><br><span class="line">    WebMvcConfigurer.<span class="built_in">super</span>.addResourceHandlers(registry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义配置</span></span><br><span class="line">    registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>)<span class="comment">// 设置静态资源访问前缀,同配置文件中的spring.mvc.static-path-pattern:</span></span><br><span class="line">            .addResourceLocations(<span class="string">&quot;/static&quot;</span>);<span class="comment">// 设置静态资源获取路径,同配置文件中的spring.web.resources.static-locations: classpath:/static/</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details> <summary><strong><span style="color: red; ">为什么容器中含有WebMvcConfigurer组件,就能配置底层行为???</span></strong></summary><ol><li><code>WebMvcAutoConfiguration</code>是一个自动配置类, 它里面有一个<code>EnableWebMvcConfiguration</code></li><li><code>EnableWebMvcConfiguration</code>继承与<code>DelegatingWebMvcConfiguration</code>, 这两个都生效</li><li><code>DelegatingWebMvcConfiguration</code>利用<strong>DI</strong>把容器中所有<code>WebMvcConfigurer</code>注入进来</li><li>当调用<code>DelegatingWebMvcConfiguration</code>的方法配置底层规则, 而它调用所有<code>WebMvcConfigurer</code>的配置底层方法</li></ol></details>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot-Web开发1-自动配置原理浅析&quot;&gt;&lt;a href=&quot;#SpringBoot-Web开发1-自动配置原理浅析&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot Web开发1-自动配置原理浅析&quot;&gt;&lt;/a&gt;SpringBo</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发2-路径匹配</title>
    <link href="http://fu-jw.com/posts/10ba68de.html"/>
    <id>http://fu-jw.com/posts/10ba68de.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-Web开发2-路径匹配"><a href="#SpringBoot-Web开发2-路径匹配" class="headerlink" title="SpringBoot Web开发2-路径匹配"></a>SpringBoot Web开发2-路径匹配</h1><h2 id="2-路径匹配"><a href="#2-路径匹配" class="headerlink" title="2.路径匹配"></a>2.路径匹配</h2><p><strong>Spring5.3</strong>之后加入了更多的<strong>请求路径匹配</strong>的实现策略,</p><p>以前只支持<strong>AntPathMatcher</strong>策略,现在提供了<strong>PathPatternParser</strong>策略,<br>并且可以指定使用哪种策略</p><p>默认使用<strong>PathPatternParser</strong>策略</p><h3 id="1-AntPathMatcher策略"><a href="#1-AntPathMatcher策略" class="headerlink" title="1.AntPathMatcher策略"></a>1.AntPathMatcher策略</h3><p>Ant 风格的路径模式语法具有以下规则:</p><ul><li><em>：表示<strong>任意数量</strong>的*<em>字符</em></em>,0~n</li><li>?：表示<strong>任意一个</strong>字符,</li><li>*<em>：表示<strong>任意数量</strong>的*<em>目录</em></em></li><li>{}：表示一个命名的模式<strong>占位符</strong></li><li>[]：表示字符集合,例如[a-z]表示小写字母</li></ul><p>例如:</p><ul><li><strong>*.html</strong> 匹配任意名称,且扩展名为.html的文件</li><li><strong>&#x2F;folder1&#x2F;<em>&#x2F;</em>.java</strong> 匹配在folder1目录下的任意两级目录下的.java文件</li><li><strong>&#x2F;folder2&#x2F;**&#x2F;*.jsp</strong> 匹配在folder2目录下任意目录深度的.jsp文件</li><li><strong>&#x2F;{type}&#x2F;{id}.html</strong> 匹配任意文件名为{id}.html,在任意命名的{type}目录下的文件</li></ul><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">注意：Ant 风格的路径模式语法中的特殊字符需要转义,如:</span><br><span class="line">1. 要匹配文件路径中的星号,则需要转义为\\*</span><br><span class="line">2. 要匹配文件路径中的问号,则需要转义为\\?</span><br></pre></td></tr></table></figure><p>代码测试:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AntPathController</span> &#123;</span><br><span class="line">  <span class="meta">@GetMapping(&quot;/a*/b?/&#123;p1:[a-f]+&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                      <span class="meta">@PathVariable(&quot;p1&quot;)</span> String path)</span> &#123;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;路径变量p1： &#123;&#125;&quot;</span>, path);</span><br><span class="line">    <span class="comment">//获取请求路径</span></span><br><span class="line">    <span class="keyword">return</span> request.getRequestURI();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问:<a href="http://localhost:8080/ads/bd/adf">http://localhost:8080/ads/bd/adf</a></p><img src="https://image.fu-jw.com/img/2023/07/01/649f847e483f9.webp" alt="AntPathMatcher策略"/><p>控制台打印:</p><blockquote><p>路径变量p1： adf</p></blockquote><h3 id="2-PathPatternParser策略"><a href="#2-PathPatternParser策略" class="headerlink" title="2.PathPatternParser策略"></a>2.PathPatternParser策略</h3><blockquote><ul><li>基准测试下,有<strong>6~8</strong>倍吞吐量提升,降低30%~40%空间分配率</li><li>兼容<strong>AntPathMatcher</strong>语法,并支持更多类型的路径模式</li></ul></blockquote><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">注意:&quot;**&quot; 多段匹配的支持仅允许在模式末尾使用</span><br></pre></td></tr></table></figure><h3 id="3-修改默认策略"><a href="#3-修改默认策略" class="headerlink" title="3.修改默认策略"></a>3.修改默认策略</h3><ul><li>配置文件:spring.mvc.pathmatch.matching-strategy&#x3D;ant_path_matcher</li><li>代码修改:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法可以修改路径匹配规则</span></span><br><span class="line"><span class="comment"> * 从spring5.3 开始,默认 PathPatternParser</span></span><br><span class="line"><span class="comment"> * 想要修改为 AntPathMatcher,则只需设置为空即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span>&#123;</span><br><span class="line">    configurer.setPatternParser(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><ul><li>使用默认的路径匹配规则(<code>PathPatternParser</code>)即可,性能高,兼容Ant风格</li><li>如果中间需要双星(**),只能换回Ant风格</li></ul><p>SpringBoot 底层匹配策略:<br>WebMvcAutoConfiguration.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configurePathMatch</span><span class="params">(PathMatchConfigurer configurer)</span>&#123;</span><br><span class="line">  <span class="comment">// 只有 ANT_PATH_MATCHER 才条件成立,创建 new AntPathMatcher()</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.mvcProperties.getPathmatch().getMatchingStrategy()==WebMvcProperties.MatchingStrategy.ANT_PATH_MATCHER)&#123;</span><br><span class="line">    configurer.setPathMatcher(<span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>());</span><br><span class="line">    <span class="built_in">this</span>.dispatcherServletPath.ifAvailable((dispatcherPath)-&gt;&#123;</span><br><span class="line">      String servletUrlMapping=dispatcherPath.getServletUrlMapping();</span><br><span class="line">      <span class="keyword">if</span>(servletUrlMapping.equals(<span class="string">&quot;/&quot;</span>)&amp;&amp;singleDispatcherServlet())&#123;</span><br><span class="line">        UrlPathHelper urlPathHelper=<span class="keyword">new</span> <span class="title class_">UrlPathHelper</span>();</span><br><span class="line">        urlPathHelper.setAlwaysUseFullPath(<span class="literal">true</span>);</span><br><span class="line">        configurer.setUrlPathHelper(urlPathHelper);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况,WebMvcProperties.java:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认情况是:PATH_PATTERN_PARSER</span></span><br><span class="line"><span class="keyword">private</span> MatchingStrategy matchingStrategy=MatchingStrategy.PATH_PATTERN_PARSER;</span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////</span></span><br><span class="line"><span class="comment">// MatchingStrategy 是枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">MatchingStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Use the &#123;<span class="doctag">@code</span> AntPathMatcher&#125; implementation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ANT_PATH_MATCHER,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Use the &#123;<span class="doctag">@code</span> PathPatternParser&#125; implementation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  PATH_PATTERN_PARSER</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot-Web开发2-路径匹配&quot;&gt;&lt;a href=&quot;#SpringBoot-Web开发2-路径匹配&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot Web开发2-路径匹配&quot;&gt;&lt;/a&gt;SpringBoot Web开发2-路径</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发3-内容协商</title>
    <link href="http://fu-jw.com/posts/2ba4c64a.html"/>
    <id>http://fu-jw.com/posts/2ba4c64a.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-Web开发3-内容协商"><a href="#SpringBoot-Web开发3-内容协商" class="headerlink" title="SpringBoot Web开发3-内容协商"></a>SpringBoot Web开发3-内容协商</h1><h2 id="3-内容协商"><a href="#3-内容协商" class="headerlink" title="3.内容协商"></a>3.内容协商</h2><h3 id="1-HTTP内容协商"><a href="#1-HTTP内容协商" class="headerlink" title="1.HTTP内容协商"></a>1.HTTP内容协商</h3><p>在<strong>HTTP</strong>协议中,<strong>内容协商</strong>是一种机制,用于为同一<strong>URI</strong>提供资源不同的表示形式,以帮助用户代理指定最适合用户的表示形式<br>例如,哪种文档语言,哪种图片格式或者哪种内容编码</p><p>内容协商通常有两种方式,服务端驱动型内容协商和代理驱动型内容协商</p><h4 id="服务端驱动型内容协商"><a href="#服务端驱动型内容协商" class="headerlink" title="服务端驱动型内容协商"></a>服务端驱动型内容协商</h4><p>在服务端驱动型内容协商或者主动内容协商中,浏览器（或者其他任何类型的用户代理）会随同 URL 发送一系列的 HTTP 标头.<br>这些标头描述了用户倾向的选择.服务器则以此为线索,通过内部算法来选择最佳方案提供给客户端.如果它不能提供一个合适的资源,<br>它可能使用 406（Not Acceptable）、415（Unsupported Media Type）进行响应并为其支持的媒体类型设置标头.<br>例如，分别对 POST 和 PATCH 请求使用 Accept-Post (en-US) 或 Accept-Patch 标头</p><img src="https://image.fu-jw.com/img/2023/07/01/649f8446e65eb.webp" alt="服务端驱动型内容协商"/><p>HTTP&#x2F;1.1 规范指定了一系列的标准标头用于启动服务端驱动型内容协商（Accept、Accept-Charset、Accept-Encoding、Accept-Language）</p><table><thead><tr><th>请求头</th><th>请求头说明</th><th>响应头</th><th>响应头说明</th></tr></thead><tbody><tr><td>Accept</td><td>告诉服务端需要的类型</td><td>Content-Type</td><td>告诉客户端响应的媒体类型</td></tr><tr><td>Accept-Language</td><td>告诉服务端需要的语言</td><td>Content-Language</td><td>告诉客户端响应的语言</td></tr><tr><td>Accept-Charset</td><td>告诉服务端需要的字符集</td><td>Content-Charset</td><td>告诉客户端响应的字符集</td></tr><tr><td>Accept-Encoding</td><td>告诉服务端需要的压缩方式</td><td>Content-Encoding</td><td>告诉客户端响应的压缩方式</td></tr></tbody></table><h4 id="代理驱动型内容协商"><a href="#代理驱动型内容协商" class="headerlink" title="代理驱动型内容协商"></a>代理驱动型内容协商</h4><p>从 HTTP 协议制定之初，该协议就准许另外一种协商机制：代理驱动型内容协商，或称为响应式协商。<br>在这种协商机制中，当面临不明确的请求时，服务器会返回一个页面，其中包含了可供选择的资源的链接。<br>资源呈现给用户，由用户做出选择.但是HTTP 标准没有明确指定提供可选资源链接的页面的格式，这阻碍了该过程的无痛自动化。<br>除了退回至服务端驱动型内容协商外，这种自动化方法几乎无一例外都是通过脚本技术来完成的，<br>尤其是 JavaScript 重定向技术：在检测了协商的条件之后，脚本会触发重定向动作。<br>另外一个问题是，为了获得实际的资源，需要额外发送一次请求，减慢了将资源呈现给用户的速度</p><h3 id="2-SpringMVC的内容协商"><a href="#2-SpringMVC的内容协商" class="headerlink" title="2.SpringMVC的内容协商"></a>2.SpringMVC的内容协商</h3><p>SpringMVC实现了HTTP内容协商的同时,又进行了扩展.<br>支持4种内容协商方式：HTTP首部Accept，扩展名，请求参数，或者固定类型</p><h3 id="3-SpringBoot的内容协商"><a href="#3-SpringBoot的内容协商" class="headerlink" title="3.SpringBoot的内容协商"></a>3.SpringBoot的内容协商</h3><p>由于SpringBoot的<code>web场景启动器</code>整合了SpringMVC,因此SpringBoot引入<code>web场景启动器</code>后即可拥有内容协商功能</p><p>SpringBoot有两种方式:基于请求头和基于请求参数的实现</p><ul><li>基于请求头内容协商:(默认开启)<ul><li>客户端向服务端发送请求，携带HTTP标准的<strong>Accept请求头</strong></li><li><strong>Accept</strong>: <code>application/json</code>、<code>text/xml</code>、<code>text/yaml</code></li><li>服务端根据客户端请求头期望的数据类型进行动态返回</li></ul></li><li>基于请求参数内容协商:(需要开启)<ul><li>发送请求: GET &#x2F;person?format&#x3D;json</li><li>匹配到 @GetMapping(“&#x2F;person”)</li><li>根据参数协商,优先返回<strong>json</strong>类型数据,(需要开启参数匹配设置)</li><li>发送请求 GET &#x2F;person?format&#x3D;xml,优先返回<strong>xml</strong>类型数据</li></ul></li></ul><img src="https://image.fu-jw.com/img/2023/07/01/649f841eacfa9.webp"/><h3 id="4-测试"><a href="#4-测试" class="headerlink" title="4.测试"></a>4.测试</h3><p>默认情况,返回JSON</p><details> <summary><strong><span style="color: red; ">是因为???</span></strong></summary><strong>web场景</strong>依赖<strong>spring-boot-starter-json</strong><br/><strong>spring-boot-starter-json</strong>依赖<strong>jackson-databind</strong><br/><strong>jackson-databind</strong>可以将对象转为JSON</details><p>效果:<br><img src="https://image.fu-jw.com/img/2023/07/01/649f83f97a750.webp"/><br><img src="https://image.fu-jw.com/img/2023/07/01/649f83db815e5.webp"/></p><p>修改为XML格式:</p><ol><li>引依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>标注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JacksonXmlRootElement</span>  <span class="comment">// 可以写出为xml文档</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果:</p><img src="https://image.fu-jw.com/img/2023/07/01/649f83a2b0c4e.webp"/><p>参数演示:</p><p>需要开启<strong>基于请求参数</strong>的内容协商</p><p>代码版:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内容协商的相关配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureContentNegotiation</span><span class="params">(ContentNegotiationConfigurer configurer)</span>&#123;</span><br><span class="line">    <span class="comment">// 开启基于请求参数的内容协商功能</span></span><br><span class="line">    configurer.favorParameter(<span class="literal">true</span>);<span class="comment">// 默认:false</span></span><br><span class="line">    <span class="comment">// 自定义内容协商时使用的参数名</span></span><br><span class="line">    configurer.parameterName(<span class="string">&quot;type&quot;</span>);<span class="comment">// 默认:format</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件版:</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启基于请求参数的内容协商功能。 默认参数名：format。 默认此功能不开启</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.favor-parameter</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 指定内容协商时使用的参数名。默认是 format</span></span><br><span class="line"><span class="attr">spring.mvc.contentnegotiation.parameter-name</span>=<span class="string">type</span></span><br></pre></td></tr></table></figure><img src="https://image.fu-jw.com/img/2023/07/01/649f8378aac51.webp"/><img src="https://image.fu-jw.com/img/2023/07/01/649f835b383d5.webp"/><img src="https://image.fu-jw.com/img/2023/07/01/649f8333bc364.webp"/><img src="https://image.fu-jw.com/img/2023/07/01/649f83010fe7d.webp"/><h3 id="5-内容协商原理浅析"><a href="#5-内容协商原理浅析" class="headerlink" title="5.内容协商原理浅析"></a>5.内容协商原理浅析</h3><blockquote><p>其实就是</p><ul><li>HttpMessageConverter 怎么工作？合适工作？</li><li>定制 HttpMessageConverter 来实现多端内容协商</li><li>编写WebMvcConfigurer提供的configureMessageConverters底层，修改底层的MessageConverter</li></ul></blockquote><h4 id="1-ResponseBody由HttpMessageConverter处理"><a href="#1-ResponseBody由HttpMessageConverter处理" class="headerlink" title="1.@ResponseBody由HttpMessageConverter处理"></a>1.<code>@ResponseBody</code>由<strong>HttpMessageConverter</strong>处理</h4><blockquote><p>标注了<code>@ResponseBody</code>的返回值 将会由支持它的<strong>HttpMessageConverter</strong>写给浏览器</p></blockquote><ul><li><p>如果<strong>controller</strong>方法的返回值标注了<code>@ResponseBody</code>注解</p><ul><li>请求进来先来到<strong>DispatcherServlet</strong>的<code>doDispatch()</code>进行处理</li><li>找到一个<strong>HandlerAdapter</strong>适配器。利用适配器执行目标方法</li><li><code>RequestMappingHandlerAdapter</code>来执行，调用<code>invokeHandlerMethod()</code>来执行目标方法</li><li>目标方法执行之前，准备好两个东西<ul><li>HandlerMethodArgumentResolver：参数解析器，确定目标方法每个参数值</li><li>HandlerMethodReturnValueHandler：返回值处理器，确定目标方法的返回值改怎么处理</li></ul></li><li><code>RequestMappingHandlerAdapter</code>里面的<code>invokeAndHandle()</code>真正执行目标方法</li><li>目标方法执行完成，会返回<strong>返回值对象</strong></li><li>找到一个合适的返回值处理器<code>HandlerMethodReturnValueHandler</code></li><li>最终找到<code>RequestResponseBodyMethodProcessor</code>能处理 标注了<code>@ResponseBody</code>注解的方法</li><li><code>RequestResponseBodyMethodProcessor</code>调用<code>writeWithMessageConverters</code>,利用<code>MessageConverter</code>把返回值写出去</li></ul></li><li><p><code>HttpMessageConverter</code>会先进行内容协商</p><ul><li>遍历所有的<code>MessageConverter</code>看谁支持这种内容类型的数据</li><li>默认<code>MessageConverter</code>有以下:</li><li><img src="https://image.fu-jw.com/img/2023/07/01/649f825276881.webp"/></li><li>最终因为要<code>json</code>所以<code>MappingJackson2HttpMessageConverter</code>支持写出json</li><li>jackson用<code>ObjectMapper</code>把对象写出去</li></ul></li></ul><h4 id="2-WebMvcAutoConfiguration提供几种默认HttpMessageConverters"><a href="#2-WebMvcAutoConfiguration提供几种默认HttpMessageConverters" class="headerlink" title="2.WebMvcAutoConfiguration提供几种默认HttpMessageConverters"></a>2.WebMvcAutoConfiguration提供几种默认HttpMessageConverters</h4><p><code>EnableWebMvcConfiguration</code>通过<code>addDefaultHttpMessageConverters</code>添加了默认的<code>MessageConverter</code>;<br>如下:</p><ul><li><code>ByteArrayHttpMessageConverter</code>： 支持字节数据读写</li><li><code>StringHttpMessageConverter</code>: 支持字符串读写</li><li><code>ResourceHttpMessageConverter</code>: 支持资源读写</li><li><code>ResourceRegionHttpMessageConverter</code>: 支持分区资源写出</li><li><code>AllEncompassingFormHttpMessageConverter</code>: 支持表单xml&#x2F;json读写</li><li><code>MappingJackson2HttpMessageConverter</code>: 支持请求响应体Json读写</li></ul><blockquote><p>系统提供默认的MessageConverter 功能有限，仅用于json或者普通返回数据。<br>额外增加新的内容协商功能，必须增加新的HttpMessageConverter</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot-Web开发3-内容协商&quot;&gt;&lt;a href=&quot;#SpringBoot-Web开发3-内容协商&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot Web开发3-内容协商&quot;&gt;&lt;/a&gt;SpringBoot Web开发3-内容</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发4-模板引擎</title>
    <link href="http://fu-jw.com/posts/3965340.html"/>
    <id>http://fu-jw.com/posts/3965340.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-Web开发4-模板引擎"><a href="#SpringBoot-Web开发4-模板引擎" class="headerlink" title="SpringBoot Web开发4-模板引擎"></a>SpringBoot Web开发4-模板引擎</h1><h2 id="4-模板引擎"><a href="#4-模板引擎" class="headerlink" title="4.模板引擎"></a>4.模板引擎</h2><blockquote><p>除了RESTWeb服务，您还可以使用SpringMVC来提供动态HTML内容。<br>SpringMVC支持多种模板技术，包括Thymelaf、FreeMarker和JSP。<br>此外，许多其他模板引擎也包含了它们自己的SpringMVC集成。</p></blockquote><p>SpringBoot自动配置支持的模板引擎有:</p><ul><li><a href="https://freemarker.apache.org/docs/">FreeMarker</a></li><li><a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine">Groovy</a></li><li><a href="https://www.thymeleaf.org/">Thymeleaf</a></li><li><a href="https://mustache.github.io/">Mustache</a></li></ul><h3 id="整合Thymeleaf"><a href="#整合Thymeleaf" class="headerlink" title="整合Thymeleaf"></a>整合Thymeleaf</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由自动配置原理知:</p><ol><li>开启了<code>org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration</code>自动配置</li><li>属性绑定在<strong>ThymeleafProperties</strong>中，对应配置文件<code>spring.thymeleaf</code>内容</li><li>默认情况,模板页面在<code>classpath:/templates</code>文件夹下</li><li>默认情况,模板页面前缀<code>classpath:/templates/</code></li><li>默认情况,模板页面后缀<code>.html</code></li><li>达到效果: <code>classpath:/templates/</code> + 页面名 + <code>.html</code></li></ol><blockquote><p>目前大多数是前后分离开发,由专业的前端框架完成,模板引擎部分用处不大.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot-Web开发4-模板引擎&quot;&gt;&lt;a href=&quot;#SpringBoot-Web开发4-模板引擎&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot Web开发4-模板引擎&quot;&gt;&lt;/a&gt;SpringBoot Web开发4-模板</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发5-错误处理</title>
    <link href="http://fu-jw.com/posts/41ac7873.html"/>
    <id>http://fu-jw.com/posts/41ac7873.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-Web开发5-错误处理"><a href="#SpringBoot-Web开发5-错误处理" class="headerlink" title="SpringBoot Web开发5-错误处理"></a>SpringBoot Web开发5-错误处理</h1><h2 id="5-错误处理"><a href="#5-错误处理" class="headerlink" title="5.错误处理"></a>5.错误处理</h2><h3 id="默认机制"><a href="#默认机制" class="headerlink" title="默认机制"></a>默认机制</h3><p>SpringBoot在<strong>web场景</strong>下,当应用程序发生错误或异常时,SpringBoot会自动应用<code>ErrorMvcAutoConfiguration</code>进行配置.</p><img src="https://image.fu-jw.com/img/2023/07/01/649f81ec7ae0a.webp"/><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Load before the main WebMvcAutoConfiguration so that the error View is available</span></span><br><span class="line"><span class="comment">// 在WebMvcAutoConfiguration自动装配之前</span></span><br><span class="line"><span class="meta">@AutoConfiguration(before = WebMvcAutoConfiguration.class)</span></span><br><span class="line"><span class="comment">// 条件:普通的servlet web类型</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="comment">// 条件:有Servlet和DispatcherServlet类</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class&#125;)</span></span><br><span class="line"><span class="comment">// 绑定配置文件:server.*和spring.mvc.*</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;ServerProperties.class, WebMvcProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMvcAutoConfiguration</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两大处理机制:<br>机制一: <strong>SpringBoot</strong>会自适应处理错误,响应页面或<strong>JSON</strong>数据(内容协商)</p><img alt="同一请求-浏览器返回白页" src="https://image.fu-jw.com/img/2023/07/01/649ff3f00a98a.webp"/><img alt="同一请求-客户端返回JSON" src="https://image.fu-jw.com/img/2023/07/01/649ff431580c1.webp"/><img alt="同一请求-客户端也可设置返回XML" src="https://image.fu-jw.com/img/2023/07/01/649ff45dc52e3.webp"/><p>机制二: <strong>SpringMVC</strong>的错误处理机制依然保留,MVC处理不了,才会交给boot进行处理</p><img alt="SpringBoot错误处理机制" src="https://image.fu-jw.com/img/2023/07/03/64a22e201bcbb.webp"/><h3 id="SpringMVC处理错误"><a href="#SpringMVC处理错误" class="headerlink" title="SpringMVC处理错误"></a>SpringMVC处理错误</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorController</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 测试MVC的错误处理机制</span></span><br><span class="line"><span class="comment">   * 默认情况下--不处理错误:</span></span><br><span class="line"><span class="comment">   * 浏览器返回白页,因为请求头中: Accept:text/html</span></span><br><span class="line"><span class="comment">   * 移动端postman返回JSON.因为请求头中: (Accept:* 所有类型,优先JSON)</span></span><br><span class="line"><span class="comment">   * 自己处理错误: handleException()</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;testError&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">testError</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误出现</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12</span> / <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;testError&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 自定义处理所有错误</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@ExceptionHandler</span> 可以标识一个方法, 默认只能处理这个类发生的指定错误</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@ControllerAdvice</span> AOP思想, 可以统一处理所有方法, 如 GlobalExceptionHandler.java</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;错误已发生,原因:&quot;</span> + e.getMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img alt="mvc处理错误" src="https://image.fu-jw.com/img/2023/07/03/64a232aac8fa8.png"/><p>统一错误处理:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span> <span class="comment">// 统一处理所有Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 自定义处理所有错误</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@ExceptionHandler</span> 可以标识一个方法, 默认只能处理这个类发生的指定错误</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@ControllerAdvice</span> AOP思想, 可以统一处理所有方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">handleException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;统一处理,错误已发生,原因:&quot;</span> + e.getMessage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img alt="mvc统一处理错误" src="https://image.fu-jw.com/img/2023/07/03/64a232c9bbac2.png"/><h3 id="SpringBoot错误原理浅析"><a href="#SpringBoot错误原理浅析" class="headerlink" title="SpringBoot错误原理浅析"></a>SpringBoot错误原理浅析</h3><p>自动配置类<code>ErrorMvcAutoConfiguration</code>, 主要包含以下功能:</p><h4 id="注册组件-BasicErrorController"><a href="#注册组件-BasicErrorController" class="headerlink" title="注册组件: BasicErrorController"></a>注册组件: BasicErrorController</h4><p>这是一个默认的错误处理控制器,用于处理一般的错误请求.</p><p>可以在配置文件中配置:<code>server.error.path=/error</code>(默认值)<br>当发生错误以后,将SpringMVC不能处理的错误请求转发给<code>/error</code>进行处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">// 可以处理配置文件中:server.error.path 的映射</span></span><br><span class="line"><span class="comment">// 或者处理配置文件中:error.path 的映射</span></span><br><span class="line"><span class="comment">// 以上都没配置,就会将请求映射到: /error</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicErrorController</span> <span class="keyword">extends</span> <span class="title class_">AbstractErrorController</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会根据请求的<code>Accept</code>头部信息返回对应的错误响应,比如<strong>JSON</strong>,<strong>XML</strong>或<strong>HTML</strong>格式.<br><strong>内容协商机制</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;text/html&quot;</span></span><br><span class="line"><span class="comment">// 返回html页面</span></span><br><span class="line"><span class="meta">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">errorHtml</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求的状态码</span></span><br><span class="line">    HttpStatus status=getStatus(request);</span><br><span class="line">    Map&lt;String, Object&gt; model=Collections</span><br><span class="line">    .unmodifiableMap(getErrorAttributes(request,getErrorAttributeOptions(request,MediaType.TEXT_HTML)));</span><br><span class="line">    response.setStatus(status.value());</span><br><span class="line">    <span class="comment">// 得到解析的错误视图</span></span><br><span class="line">    ModelAndView modelAndView=resolveErrorView(request,response,status,model);</span><br><span class="line">    <span class="comment">// 返回上面解析的视图,或者新建一个error视图(SpringBoot默认有一个error页面,状态码999)</span></span><br><span class="line">    <span class="keyword">return</span>(modelAndView!=<span class="literal">null</span>)?modelAndView:<span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>,model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 ResponseEntity,即JSON数据</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt;error(HttpServletRequest request)&#123;</span><br><span class="line">    HttpStatus status=getStatus(request);</span><br><span class="line">    <span class="keyword">if</span>(status==HttpStatus.NO_CONTENT)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(status);</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, Object&gt; body=getErrorAttributes(request,getErrorAttributeOptions(request,MediaType.ALL));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(body,status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误视图解析:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、解析错误的自定义视图地址</span></span><br><span class="line">ModelAndView modelAndView=resolveErrorView(request,response,status,model);</span><br><span class="line"><span class="comment">//2、如果解析不到错误页面的地址，默认的错误页就是 error</span></span><br><span class="line"><span class="keyword">return</span>(modelAndView!=<span class="literal">null</span>)?modelAndView:<span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>,model);</span><br></pre></td></tr></table></figure><p><strong>1.解析错误视图:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">resolveErrorView</span><span class="params">(HttpServletRequest request,HttpServletResponse response,HttpStatus status,Map&lt;String, Object&gt; model)</span>&#123;</span><br><span class="line">  <span class="comment">// 遍历错误视图解析器:errorViewResolvers</span></span><br><span class="line">  <span class="keyword">for</span>(ErrorViewResolver resolver:<span class="built_in">this</span>.errorViewResolvers)&#123;</span><br><span class="line">    ModelAndView modelAndView=resolver.resolveErrorView(request,status,model);</span><br><span class="line">    <span class="keyword">if</span>(modelAndView!=<span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在自动配置类,会将<strong>默认的错误视图解析器</strong>放在容器中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="comment">// 绑定配置文件中 web.* 和 web.mvc.*</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(&#123;WebProperties.class, WebMvcProperties.class&#125;)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DefaultErrorViewResolverConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Resources resources;</span><br><span class="line"></span><br><span class="line">  DefaultErrorViewResolverConfiguration(ApplicationContext applicationContext, WebProperties webProperties) &#123;</span><br><span class="line">    <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    <span class="built_in">this</span>.resources = webProperties.getResources();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnBean(DispatcherServlet.class)</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(ErrorViewResolver.class)</span></span><br><span class="line">  DefaultErrorViewResolver <span class="title function_">conventionErrorViewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在容器中放入默认错误视图解析器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultErrorViewResolver</span>(<span class="built_in">this</span>.applicationContext, <span class="built_in">this</span>.resources);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>默认的错误视图解析过程:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">resolveErrorView</span><span class="params">(HttpServletRequest request,HttpStatus status,Map&lt;String, Object&gt; model)</span>&#123;</span><br><span class="line">  <span class="comment">// 1. 获取状态码</span></span><br><span class="line">  <span class="comment">// 2. 根据状态码解析错误视图(如: 404 500 等)    </span></span><br><span class="line">  ModelAndView modelAndView=resolve(String.valueOf(status.value()),model);</span><br><span class="line">  <span class="comment">// 3. 状态码没有精确匹配,则模糊匹配(如:4xx 5xx, 注意只有这俩)</span></span><br><span class="line">  <span class="keyword">if</span>(modelAndView==<span class="literal">null</span>&amp;&amp;SERIES_VIEWS.containsKey(status.series()))&#123;</span><br><span class="line">    modelAndView=resolve(SERIES_VIEWS.get(status.series()),model);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的解析过程</span></span><br><span class="line"><span class="keyword">private</span> ModelAndView <span class="title function_">resolve</span><span class="params">(String viewName,Map&lt;String, Object&gt; model)</span>&#123;</span><br><span class="line">  <span class="comment">// 错误视图名: error/404 或 error/4xx    </span></span><br><span class="line">  String errorViewName=<span class="string">&quot;error/&quot;</span>+viewName;</span><br><span class="line">  TemplateAvailabilityProvider provider=<span class="built_in">this</span>.templateAvailabilityProviders.getProvider(errorViewName,<span class="built_in">this</span>.applicationContext);</span><br><span class="line">  <span class="keyword">if</span>(provider!=<span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="comment">// 有就返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(errorViewName,model);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有, 继续</span></span><br><span class="line">  <span class="keyword">return</span> resolveResource(errorViewName,model);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续解析错误视图, 在静态资源目录下查找</span></span><br><span class="line"><span class="keyword">private</span> ModelAndView <span class="title function_">resolveResource</span><span class="params">(String viewName,Map&lt;String, Object&gt; model)</span>&#123;</span><br><span class="line">  <span class="comment">// 遍历四个静态资源目录:classpath:/META-INF/resources/&quot;,&quot;classpath:/resources/&quot;,</span></span><br><span class="line">  <span class="comment">// &quot;classpath:/static/&quot;, &quot;classpath:/public/    </span></span><br><span class="line">  <span class="keyword">for</span>(String location:<span class="built_in">this</span>.resources.getStaticLocations())&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Resource resource=<span class="built_in">this</span>.applicationContext.getResource(location);</span><br><span class="line">      resource=resource.createRelative(viewName+<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span>(resource.exists())&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="keyword">new</span> <span class="title class_">HtmlResourceView</span>(resource),model);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.解析不到错误视图:</strong><br>精确状态码以及模糊状态码都没有匹配时,则映射到error视图</p><p>在template目录下创建<code>error.html</code>就会返回(注意:将上面统一错误处理注释)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">模板: error 页</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果:</p><img alt="error页" src="https://image.fu-jw.com/img/2023/07/03/64a259a289e8c.png"/><p><strong>如果error视图页没有:</strong></p><p>自动配置类<code>ErrorMvcAutoConfiguration</code>,在容器中放入了<code>error</code>组件,提供了默认白页功能:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(prefix = &quot;server.error.whitelabel&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span></span><br><span class="line"><span class="meta">@Conditional(ErrorTemplateMissingCondition.class)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WhitelabelErrorViewConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StaticView</span> <span class="variable">defaultErrorView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticView</span>();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(name = &quot;error&quot;)</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(name = &quot;error&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> View <span class="title function_">defaultErrorView</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.defaultErrorView;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the user adds @EnableWebMvc then the bean name view resolver from</span></span><br><span class="line">  <span class="comment">// WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment.</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> BeanNameViewResolver <span class="title function_">beanNameViewResolver</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BeanNameViewResolver</span> <span class="variable">resolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanNameViewResolver</span>();</span><br><span class="line">    resolver.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> resolver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建白页:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticView</span> <span class="keyword">implements</span> <span class="title class_">View</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">MediaType</span> <span class="variable">TEXT_HTML_UTF8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediaType</span>(<span class="string">&quot;text&quot;</span>, <span class="string">&quot;html&quot;</span>, StandardCharsets.UTF_8);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">logger</span> <span class="operator">=</span> LogFactory.getLog(StaticView.class);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">          <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> getMessage(model);</span><br><span class="line">      logger.error(message);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    response.setContentType(TEXT_HTML_UTF8.toString());</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">timestamp</span> <span class="operator">=</span> model.get(<span class="string">&quot;timestamp&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">message</span> <span class="operator">=</span> model.get(<span class="string">&quot;message&quot;</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">trace</span> <span class="operator">=</span> model.get(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (response.getContentType() == <span class="literal">null</span>) &#123;</span><br><span class="line">      response.setContentType(getContentType());</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;&quot;</span>)</span><br><span class="line">            .append(<span class="string">&quot;&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;&quot;</span>)</span><br><span class="line">            .append(<span class="string">&quot;&lt;div id=&#x27;created&#x27;&gt;&quot;</span>)</span><br><span class="line">            .append(timestamp)</span><br><span class="line">            .append(<span class="string">&quot;&lt;/div&gt;&quot;</span>)</span><br><span class="line">            .append(<span class="string">&quot;&lt;div&gt;There was an unexpected error (type=&quot;</span>)</span><br><span class="line">            .append(htmlEscape(model.get(<span class="string">&quot;error&quot;</span>)))</span><br><span class="line">            .append(<span class="string">&quot;, status=&quot;</span>)</span><br><span class="line">            .append(htmlEscape(model.get(<span class="string">&quot;status&quot;</span>)))</span><br><span class="line">            .append(<span class="string">&quot;).&lt;/div&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (message != <span class="literal">null</span>) &#123;</span><br><span class="line">      builder.append(<span class="string">&quot;&lt;div&gt;&quot;</span>).append(htmlEscape(message)).append(<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (trace != <span class="literal">null</span>) &#123;</span><br><span class="line">      builder.append(<span class="string">&quot;&lt;div style=&#x27;white-space:pre-wrap;&#x27;&gt;&quot;</span>).append(htmlEscape(trace)).append(<span class="string">&quot;&lt;/div&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    response.getWriter().append(builder.toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h3><p>先尝试解析错误页, 解析失败则在静态资源目录下查找</p><ol><li><strong>解析</strong>一个错误页</li></ol><ul><li>如果发生了500、404、503、403 这些错误<ul><li>如果有模板引擎，默认在<code>classpath:/templates/error/精确码.html</code></li><li>如果没有模板引擎，在静态资源文件夹下找<code>精确码.html</code></li></ul></li><li>如果匹配不到<code>精确码.html</code>这些精确的错误页，就去找<code>5xx.html</code>, <code>4xx.html</code><strong>模糊匹配</strong><ul><li>如果有模板引擎，默认在<code>classpath:/templates/error/5xx.html</code></li><li>如果没有模板引擎，在静态资源文件夹下找<code>5xx.html</code></li></ul></li></ul><ol start="2"><li>如果模板引擎路径<code>templates</code>下有<code>error.html</code>页面, 就直接渲染</li></ol><h3 id="自定义错误响应"><a href="#自定义错误响应" class="headerlink" title="自定义错误响应"></a>自定义错误响应</h3><ul><li>自定义json响应<ul><li>使用@ControllerAdvice + @ExceptionHandler 进行统一异常处理</li></ul></li><li>自定义页面响应<ul><li>根据boot的错误页面规则，自定义页面模板</li></ul></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li>前后分离<ul><li>后台发生的所有错误, <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code>进行统一异常处理</li></ul></li><li>服务端页面渲染<ul><li>不可预知的错误,HTTP码表示的服务器端或客户端错误<ul><li>给<code>classpath:/templates/error/</code>下面，放常用精确的错误码页面。<code>500.html</code>，<code>404.html</code></li><li>给<code>classpath:/templates/error/</code>下面，放通用模糊匹配的错误码页面。 <code>5xx.html</code>，<code>4xx.html</code></li></ul></li><li>发生业务错误<ul><li><strong>核心业务</strong>, 每一种错误, 都应该代码控制, 跳转到自己<strong>定制的错误页</strong></li><li><strong>通用业务</strong>, <code>classpath:/templates/error.html</code>页面, 显示错误信息</li></ul></li></ul></li></ul><p>无论是返回页面或者JSON数据, 可用的<strong>Model</strong>数据都一样, 如下:<br><img alt="model" src="https://image.fu-jw.com/img/2023/07/03/64a2742fd9f6c.png"/></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot-Web开发5-错误处理&quot;&gt;&lt;a href=&quot;#SpringBoot-Web开发5-错误处理&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot Web开发5-错误处理&quot;&gt;&lt;/a&gt;SpringBoot Web开发5-错误</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Web开发6-嵌入式容器</title>
    <link href="http://fu-jw.com/posts/128d12a9.html"/>
    <id>http://fu-jw.com/posts/128d12a9.html</id>
    <published>2023-07-01T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-Web开发6-嵌入式容器"><a href="#SpringBoot-Web开发6-嵌入式容器" class="headerlink" title="SpringBoot Web开发6-嵌入式容器"></a>SpringBoot Web开发6-嵌入式容器</h1><h2 id="6-嵌入式容器"><a href="#6-嵌入式容器" class="headerlink" title="6.嵌入式容器"></a>6.嵌入式容器</h2><p>Servlet容器：管理、运行Servlet组件的环境，一般指服务器</p><p>Servlet三大组件:</p><ul><li>Servlet, 处理请求</li><li>Filter, 过滤请求</li><li>Listener, 监听请求</li></ul><h3 id="自动配置原理浅析"><a href="#自动配置原理浅析" class="headerlink" title="自动配置原理浅析"></a>自动配置原理浅析</h3><p>先从自动配置类开始</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration(after = SslAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="comment">// 生效条件:实现ServletRequest接口的Servlet请求</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRequest.class)</span></span><br><span class="line"><span class="comment">// 生效条件:是SERVLET类型的程序</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="comment">// 绑定配置文件, server.*</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span></span><br><span class="line"><span class="comment">// 批量导入一些嵌入式服务器类</span></span><br><span class="line"><span class="meta">@Import(&#123;ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span></span><br><span class="line"><span class="meta">        ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span></span><br><span class="line"><span class="meta">        ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span></span><br><span class="line"><span class="meta">        ServletWebServerFactoryConfiguration.EmbeddedUndertow.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryAutoConfiguration</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌入式的三大服务器:<code>Tomcat</code>、<code>Jetty</code>、<code>Undertow</code></p><ul><li>导入<code>Tomcat</code>、<code>Jetty</code>、<code>Undertow</code>都有条件注解(系统中有对应的类才行,导包即可)</li><li>默认<code>Tomcat</code>配置生效.<strong>web场景</strong>默认导入<code>spring-boot-starter-tomcat</code></li><li><code>Tomcat</code>配置生效后,会在容器中放入<code>TomcatServletWebServerFactory</code>组件,用于创建容器的工厂类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line">  <span class="meta">@ConditionalOnClass(&#123;Servlet.class, Tomcat.class, UpgradeProtocol.class&#125;)</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">EmbeddedTomcat</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    TomcatServletWebServerFactory <span class="title function_">tomcatServletWebServerFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,</span></span><br><span class="line"><span class="params">            ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers)</span> &#123;</span><br><span class="line">      <span class="type">TomcatServletWebServerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class="line">      factory.getTomcatConnectorCustomizers().addAll(connectorCustomizers.orderedStream().toList());</span><br><span class="line">      factory.getTomcatContextCustomizers().addAll(contextCustomizers.orderedStream().toList());</span><br><span class="line">      factory.getTomcatProtocolHandlerCustomizers().addAll(protocolHandlerCustomizers.orderedStream().toList());</span><br><span class="line">      <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 其他容器...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>TomcatServletWebServerFactory</code>工厂类中,具体的创建方法:</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 获取web服务器</span></span><br><span class="line"><span class="keyword">public</span> WebServer <span class="title function_">getWebServer</span><span class="params">(ServletContextInitializer...initializers)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">this</span>.disableMBeanRegistry)&#123;</span><br><span class="line">  Registry.disableRegistry();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Tomcat容器</span></span><br><span class="line">Tomcat tomcat=<span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">File baseDir=(<span class="built_in">this</span>.baseDirectory!=<span class="literal">null</span>)?<span class="built_in">this</span>.baseDirectory:createTempDir(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line"><span class="keyword">for</span>(LifecycleListener listener:<span class="built_in">this</span>.serverLifecycleListeners)&#123;</span><br><span class="line">  tomcat.getServer().addLifecycleListener(listener);</span><br><span class="line">&#125;</span><br><span class="line">Connector connector=<span class="keyword">new</span> <span class="title class_">Connector</span>(<span class="built_in">this</span>.protocol);</span><br><span class="line">connector.setThrowOnFailure(<span class="literal">true</span>);</span><br><span class="line">tomcat.getService().addConnector(connector);</span><br><span class="line">customizeConnector(connector);</span><br><span class="line">tomcat.setConnector(connector);</span><br><span class="line">tomcat.getHost().setAutoDeploy(<span class="literal">false</span>);</span><br><span class="line">configureEngine(tomcat.getEngine());</span><br><span class="line"><span class="keyword">for</span>(Connector additionalConnector:<span class="built_in">this</span>.additionalTomcatConnectors)&#123;</span><br><span class="line">  tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">&#125;</span><br><span class="line">prepareContext(tomcat.getHost(),initializers);</span><br><span class="line"><span class="keyword">return</span> getTomcatWebServer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Tomcat容器创建时机"><a href="#Tomcat容器创建时机" class="headerlink" title="Tomcat容器创建时机"></a>Tomcat容器创建时机</h3><p>SpringApplication.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String...args)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  refreshContext(context); <span class="comment">// 刷新上下文</span></span><br><span class="line">  afterRefresh(context,applicationArguments);</span><br><span class="line">  <span class="comment">// ...    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// 刷新上下文</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshContext</span><span class="params">(ConfigurableApplicationContext context)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">this</span>.registerShutdownHook)&#123;</span><br><span class="line">    shutdownHook.registerApplicationContext(context);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 刷新</span></span><br><span class="line">  refresh(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//////////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(ConfigurableApplicationContext applicationContext)</span>&#123;</span><br><span class="line">  applicationContext.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<strong>web场景</strong>下,<br>ServletWebServerApplicationContext.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span><span class="keyword">throws</span> BeansException,IllegalStateException&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 刷新</span></span><br><span class="line">    <span class="built_in">super</span>.refresh();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span>(RuntimeException ex)&#123;</span><br><span class="line">    WebServer webServer=<span class="built_in">this</span>.webServer;</span><br><span class="line">    <span class="keyword">if</span>(webServer!=<span class="literal">null</span>)&#123;</span><br><span class="line">      webServer.stop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractApplicationContext.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="comment">// 创建容器十二步</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span><span class="keyword">throws</span> BeansException,IllegalStateException&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor)&#123;</span><br><span class="line">    StartupStep contextRefresh=<span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备上下文内容</span></span><br><span class="line">    <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">    prepareRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.获取刷新的bean工厂</span></span><br><span class="line">    <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.准备上下文用到的bean工厂,如:类加载器,后置处理器</span></span><br><span class="line">    <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">    prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 4.通过编程方式修改BeanFactory的配置，比如添加自定义的BeanDefinition，修改属性值，注册BeanPostProcessor等等。</span></span><br><span class="line">    <span class="comment">// 通过这种方式，开发人员可以对Spring容器进行更灵活和定制化的配置</span></span><br><span class="line">    <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">    postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.执行所有已注册的BeanFactoryPostProcessor的postProcessBeanFactory方法</span></span><br><span class="line">    StartupStep beanPostProcess=<span class="built_in">this</span>.applicationStartup.start(<span class="string">&quot;spring.context.beans.post-process&quot;</span>);</span><br><span class="line">    <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">    invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.注册所有的BeanPostProcessor实例.</span></span><br><span class="line">    <span class="comment">// 允许开发人员在bean实例化和依赖注入的过程中对bean进行增强或定制</span></span><br><span class="line">    <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">    registerBeanPostProcessors(beanFactory);</span><br><span class="line">    beanPostProcess.end();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.初始化上下文的消息资源</span></span><br><span class="line">    <span class="comment">// 消息资源用于国际化和本地化的目的，它可以根据不同的语言和区域设置，提供相应的文本消息</span></span><br><span class="line">    <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">    initMessageSource();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.初始化应用程序事件的多播器,使得应用程序能够对事件进行发布和监听</span></span><br><span class="line">    <span class="comment">// 事件机制是一种通信机制，用于在不同的组件之间传递消息和触发相应的处理逻辑</span></span><br><span class="line">    <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">    initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9.容器刷新过程中的一个回调方法，用于提供一个扩展点，让开发人员可以在容器刷新完成后执行一些自定义的逻辑</span></span><br><span class="line">    <span class="comment">// 可以在onRefresh方法中执行一些额外的初始化操作、启动定时任务、注册额外的bean等</span></span><br><span class="line">    <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">    onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10.向应用程序上下文注册事件监听器</span></span><br><span class="line">    <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">    registerListeners();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 11.在Bean工厂初始化的最后阶段，完成所有注册的Bean的初始化过程</span></span><br><span class="line">    <span class="comment">// Bean工厂中所有已注册的Bean的名称 --&gt;</span></span><br><span class="line">    <span class="comment">// 遍历所有的Bean名称获取对应的Bean定义 --&gt;</span></span><br><span class="line">    <span class="comment">// 根据Bean定义的信息，进行实例化、依赖注入、初始化等操作 --&gt;</span></span><br><span class="line">    <span class="comment">// 若Bean定义中有初始化方法（例如通过@PostConstruct注解标记的方法），则调用该方法进行额外的初始化逻辑</span></span><br><span class="line">    <span class="comment">// 若Bean定义中有销毁方法（例如通过@PreDestroy注解标记的方法），则在容器关闭时调用该方法进行资源释放等操作</span></span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12.容器刷新的最后阶段，执行一些额外的逻辑以完成刷新过程</span></span><br><span class="line">    <span class="comment">// 清理初始化过程中一系列操作使用到的资源缓存</span></span><br><span class="line">    <span class="comment">// 初始化LifecycleProcessor</span></span><br><span class="line">    <span class="comment">// 启动所有实现了Lifecycle接口的bean</span></span><br><span class="line">    <span class="comment">// 发布ContextRefreshedEvent事件</span></span><br><span class="line">    <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">    finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">catch</span>(BeansException ex)&#123;</span><br><span class="line">    <span class="keyword">if</span>(logger.isWarnEnabled())&#123;</span><br><span class="line">      logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span>+</span><br><span class="line">      <span class="string">&quot;cancelling refresh attempt: &quot;</span>+ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">    <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">    resetCommonCaches();</span><br><span class="line">    contextRefresh.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切换服务器"><a href="#切换服务器" class="headerlink" title="切换服务器"></a>切换服务器</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Exclude the Tomcat dependency --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Use Jetty instead --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot-Web开发6-嵌入式容器&quot;&gt;&lt;a href=&quot;#SpringBoot-Web开发6-嵌入式容器&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot Web开发6-嵌入式容器&quot;&gt;&lt;/a&gt;SpringBoot Web开发6</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>AList+云盘+LskyPro 搭建大容量图床</title>
    <link href="http://fu-jw.com/posts/4140de30.html"/>
    <id>http://fu-jw.com/posts/4140de30.html</id>
    <published>2023-06-30T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AList-云盘-LskyPro-搭建大容量图床"><a href="#AList-云盘-LskyPro-搭建大容量图床" class="headerlink" title="AList+云盘+LskyPro 搭建大容量图床"></a>AList+云盘+LskyPro 搭建大容量图床</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://www.lsky.pro/">兰空官网:</a></p><blockquote><p>兰空图床可以帮您保管大量无处安放的图片，数据可以自由选择储存驱动，支持主流第三方储存。<br>作为一个助手，它不仅可以将您把图片以指定规则存放在指定位置，还有更多强大的功能来帮助您处理这些图片。</p></blockquote><p><a href="https://alist.nn.ci/zh/">AList:</a></p><blockquote><p>一个支持多种存储，支持网页浏览和 WebDAV 的文件列表程序<br>支持多个存储提供商，包括本地存储、阿里云盘、OneDrive、Google Drive 等，且易于拓展<br>支持所有 WebDAV 存储，这是一种用于访问文件的标准</p></blockquote><p>云盘:<br>本文以<a href="https://cloud.189.cn/web/login.html">天翼云盘</a>为例, 免费 30 GB 的空间, 支持 WebDAV</p><p><a href="https://image.fu-jw.com/">自建图床</a><br><img src="https://image.fu-jw.com/img/2023/06/30/649ec9d66f54d.webp" alt="Snipaste_2023-06-30_19-51-10.png"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>无需缴高额图床管理费</li><li>访问速度取决于自建服务器的配置</li><li>图片自治, 自己管理图片, 不用担心图床跑路或被墙</li></ul><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><blockquote><p>前提:<br>需要公网服务器和已备案域名<br>服务器安装宝塔, Docker, Nginx</p></blockquote><h3 id="1-AList"><a href="#1-AList" class="headerlink" title="1. AList"></a>1. AList</h3><p>使用 Docker 安装</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always -v /etc/alist:/opt/alist/data -p 5244:5244 -e PUID=0 -e PGID=0 -e UMASK=022 --name=<span class="string">&quot;alist&quot;</span> xhofe/alist:latest</span><br></pre></td></tr></table></figure><blockquote><p>注意: 端口号是: 5244, 如果使用云服务器如阿里云, 腾讯云等, 记得开放此端口.</p></blockquote><h3 id="2-WebDAV-服务"><a href="#2-WebDAV-服务" class="headerlink" title="2. WebDAV 服务"></a>2. WebDAV 服务</h3><ul><li>注册登录<a href="https://cloud.189.cn/web/login.html">天翼云盘</a></li><li>在个人网盘中创建 <code>Pics</code> 文件夹</li><li>在 AList 中将该文件夹挂载到路径 <code>/image</code> (在 AList 显示的路径)</li></ul><img src=" https://image.fu-jw.com/img/2023/06/30/649ed7ee1dce7.webp"/><p>参考配置:<br><img src=" https://image.fu-jw.com/img/2023/06/30/649ed98c2c787.webp"/><br><img src=" https://image.fu-jw.com/img/2023/06/30/649edb3e4e9a2.webp"/></p><p><a href="https://alist.nn.ci/zh/guide/drivers/189.html">参考文档</a></p><h3 id="3-Lsky"><a href="#3-Lsky" class="headerlink" title="3. Lsky"></a>3. Lsky</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建容器并启动（宿主机4003端口可自行更改）  </span></span><br><span class="line">sudo docker run -d --name lskypro --restart unless-stopped -p 4003:80 -v /data/lskypro:/var/www/html coldpig/lskypro-docker:latest </span><br></pre></td></tr></table></figure><h4 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h4><p>注意: 如果在 Nginx 配置中开启了 HTTPS ，需要执行以下命令修改图床项目源码，否则前端页面布局将被打乱</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker <span class="built_in">exec</span> -it lskypro sed -i <span class="string">&#x27;32 a \\\Illuminate\\Support\\Facades\\URL::forceScheme(&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;https&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;);&#x27;</span> /var/www/html/app/Providers/AppServiceProvider.php</span><br></pre></td></tr></table></figure><p>假设图床服务的域名为 <code>image.domain.com</code>，AList 部署在本地端口 <code>5244</code>，在 <code>nginx.conf</code> 中添加如下配置项：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">server</span><br><span class="line">&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">listen 443 ssl http2;</span><br><span class="line">    server_name image.domain.com;</span><br><span class="line">    index index.php index.html index.htm default.php default.htm default.html;</span><br><span class="line">    root /www/wwwroot/image.domain.com;</span><br><span class="line"></span><br><span class="line">    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则</span><br><span class="line">    #error_page 404/404.html;</span><br><span class="line">    ssl_certificate    /www/server/panel/vhost/cert/image.domain.com/fullchain.pem;</span><br><span class="line">    ssl_certificate_key    /www/server/panel/vhost/cert/image.domain.com/privkey.pem;</span><br><span class="line">    ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;</span><br><span class="line">    ssl_ciphers EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    ssl_session_cache shared:SSL:10m;</span><br><span class="line">    ssl_session_timeout 10m;</span><br><span class="line">    add_header Strict-Transport-Security &quot;max-age=31536000&quot;;</span><br><span class="line">    error_page 497  https://$host$request_uri;</span><br><span class="line"></span><br><span class="line">    #SSL-END</span><br><span class="line"></span><br><span class="line">    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改</span><br><span class="line">    #error_page 404 /404.html;</span><br><span class="line">    #error_page 502 /502.html;</span><br><span class="line">    #ERROR-PAGE-END</span><br><span class="line"></span><br><span class="line">    #PHP-INFO-START  PHP引用配置，可以注释或修改</span><br><span class="line">    include enable-php-00.conf;</span><br><span class="line">    #PHP-INFO-END</span><br><span class="line"></span><br><span class="line">    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效</span><br><span class="line">    include /www/server/panel/vhost/rewrite/image.domain.com.conf;</span><br><span class="line">    #REWRITE-END</span><br><span class="line"></span><br><span class="line">    #禁止访问的文件或目录</span><br><span class="line">    # 转发图床服务请求</span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header Range $http_range;</span><br><span class="line">      proxy_set_header If-Range $http_if_range;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        client_max_body_size 20000m;</span><br><span class="line">      # 转发端口 4003 与上面设定的宿主机端口保持一致</span><br><span class="line">        proxy_pass http://IP:4003;</span><br><span class="line">        proxy_read_timeout 600s;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    # 转发 AList 图片直链访问请求</span><br><span class="line">    location /img &#123;</span><br><span class="line">        proxy_pass http://IP:5244/d/image;</span><br><span class="line">        proxy_read_timeout 600s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #禁止在证书验证目录放入敏感文件</span><br><span class="line">    if ( $uri ~ &quot;^/\.well-known/.*\.(php|jsp|py|js|css|lua|ts|go|zip|tar\.gz|rar|7z|sql|bak)$&quot; ) &#123;</span><br><span class="line">        return 403;</span><br><span class="line">    &#125;</span><br><span class="line">    access_log  /www/wwwlogs/image.domain.com.log;</span><br><span class="line">    error_log  /www/wwwlogs/image.domain.com.error.log;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lsky-数据库配置"><a href="#Lsky-数据库配置" class="headerlink" title="Lsky 数据库配置"></a>Lsky 数据库配置</h4><p>以上步骤完成后，浏览器访问图床服务域名可进入如下图所示的配置页面。配置页面将引导我们设置数据库服务，为了减轻工作量，我们直接使用本地 SQLite 数据库，数据库路径留空即可（将自动在服务根目录的 <code>database</code> 目录下创建 <code>database.sqlite</code> 文件），同时需要设定管理员邮箱和登录密码。<br><img src=" https://image.fu-jw.com/img/2023/06/30/649edebe28bcb.webp"/><br><img src=" https://image.fu-jw.com/img/2023/06/30/649edece60c02.webp"/></p><h4 id="设置存储策略"><a href="#设置存储策略" class="headerlink" title="设置存储策略"></a>设置存储策略</h4><img src=" https://image.fu-jw.com/img/2023/06/30/649edffb7426c.webp"/><p>参考配置:<br><img src=" https://image.fu-jw.com/img/2023/06/30/649ee183cdadf.webp"/></p><p>默认存储策略为本地存储，为了不占用服务器空间，我们这里使用 AList 提供的 WebDAV 服务创建一个新的存储策略，配置项如表所示，其中访问域名即为图片直链对应的域名和路径。</p><p>注意: 设置 WebDAV 为默认存储策略</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AList-云盘-LskyPro-搭建大容量图床&quot;&gt;&lt;a href=&quot;#AList-云盘-LskyPro-搭建大容量图床&quot; class=&quot;headerlink&quot; title=&quot;AList+云盘+LskyPro 搭建大容量图床&quot;&gt;&lt;/a&gt;AList+云盘+LskyP</summary>
      
    
    
    
    <category term="教程" scheme="http://fu-jw.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="图床" scheme="http://fu-jw.com/tags/%E5%9B%BE%E5%BA%8A/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot日志</title>
    <link href="http://fu-jw.com/posts/4275e528.html"/>
    <id>http://fu-jw.com/posts/4275e528.html</id>
    <published>2023-06-13T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot日志"><a href="#SpringBoot日志" class="headerlink" title="SpringBoot日志"></a>SpringBoot日志</h1><blockquote><p>我的<a href="https://github.com/fu-jw/spring-tutorial">SpringBoot项目</a>第三个模块</p></blockquote><p>在前面<a href="https://blog.fu-jw.com/posts/4ccc97e8.html">SpringBoot快速入门</a>中我们知道,</p><p>每个SpringBoot项目都会依赖<strong>核心启动器</strong>:<code>spring-boot-starter</code>, 核心启动器会依赖:<code>spring-boot-starter-logging</code>实现日志功能</p><p><code>spring-boot-starter-logging</code>依赖<code>Logback</code>的日志实现和<code>SLF4J</code>桥接器,将其他日志实现桥接到<code>SLF4J</code></p><p>即<code>SLF4J</code>+<code>Logback</code>的日志组合.</p><!-- ![SpringBoot日志依赖](https://s2.loli.net/2023/06/15/Rtsyneul2bhIKNr.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7b539f42d.webp"/><details> <summary><strong><span style="color: red; ">为什么日志不用SpringBoot的自动配置???</span></strong></summary><strong>日志是系统启动就要使用</strong>,<strong>xxxAutoConfiguration</strong>是系统启动好了以后放好的组件,后来用的.<br>日志是利用<strong>监听器机制</strong>配置好的,<strong>ApplicationListener</strong></details><h2 id="默认日志"><a href="#默认日志" class="headerlink" title="默认日志"></a>默认日志</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2023-06-12T20:57:23.829+08:00  INFO 5232 --- [           main] com.fredo.Main                           : Starting Main using Java 17.0.2 with PID 5232</span><br><span class="line">2023-06-12T20:57:23.837+08:00  INFO 5232 --- [           main] com.fredo.Main                           : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2023-06-12T20:57:25.094+08:00  INFO 5232 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br></pre></td></tr></table></figure><p>默认输出格式：</p><ul><li>时间和日期：毫秒级精度</li><li>日志级别：ERROR, WARN, INFO, DEBUG, or TRACE.</li><li>进程 ID</li><li>—： 消息分割符</li><li>线程名： 使用[]包含</li><li>Logger 名： 通常是产生日志的类名</li><li>消息： 日志记录的内容</li></ul><!-- ![SpringBoot日志默认值](https://s2.loli.net/2023/06/16/EiSUmc3tWpYnea8.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7bc000895.webp"/><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;logging.pattern.console&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;java.lang.String&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Appender pattern for output to the console. Supported only with the default Logback setup.&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sourceType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;org.springframework.boot.context.logging.LoggingApplicationListener&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSXXX&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="修改格式"><a href="#修改格式" class="headerlink" title="修改格式"></a>修改格式</h2><p>在SpringBoot的配置文件<strong>application.properties</strong>中直接修改即可:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; ==== %msg%n</span><br></pre></td></tr></table></figure><p>结果如下:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">2023-06-12 21:19:29.634 [main] INFO  com.fredo.Main ==== Starting Main using Java 17.0.2 with PID 11216</span><br><span class="line">2023-06-12 21:19:29.639 [main] INFO  com.fredo.Main ==== No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2023-06-12 21:19:30.922 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer ==== Tomcat initialized with port(s): 8080 (http)</span><br></pre></td></tr></table></figure><p><strong>简单方便</strong></p><p>也可以单独文件配置<code>logback</code>, <strong>优先级高于SpringBoot的配置</strong><br>默认在<strong>classpath</strong>中依次寻找<strong>logback-spring.xml, logback-spring.groovy, logback.groovy, logback.xml</strong>文件</p><p>还可以在SpringBoot配置文件中指定文件位置</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">logging.config=classpath:logback-bak.xml</span><br></pre></td></tr></table></figure><h2 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h2><p>在每个类中添加代码:<br><code>Logger log = LoggerFactory.getLogger(getClass());</code></p><p>或者添加<code>lombok</code>依赖, 在类上直接使用<code>@Slf4j</code>注解即可代替上面代码</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在想要打印日志的位置使用即可<br><code>log.info(&quot;...&quot;);</code></p><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p>由低到高：</p><ul><li>ALL: 开启日志打印</li><li>TRACE: 可跟踪打印框架底层信息</li><li>DEBUG: 调试信息</li><li>INFO: 普通信息</li><li>WARN: 系统的告警信息</li><li>ERROR: 系统的错误信息,异常信息</li><li>FATAL: 可能导致系统崩溃的严重信息</li><li>OFF: 关闭日志打印</li></ul><p>注意：</p><ul><li><code>Logback</code>没有<code>FATAL</code>级别, 对应的是<code>ERROR</code></li><li><strong>高级别包含低级别的所有信息</strong></li><li>SpringBoot日志默认级别是<code>INFO</code></li></ul><blockquote><p>默认所有日志没有精确指定级别就使用<strong>root</strong>的默认级别:<br>logging.level.root&#x3D;info</br><br>精确调整某个包下的日志级别<br>logging.level.com.fredo.logging.controller&#x3D;debug<br>logging.level.com.fredo.logging.service&#x3D;debug</p></blockquote><h2 id="日志分组"><a href="#日志分组" class="headerlink" title="日志分组"></a>日志分组</h2><p>在给不同包下的类定义日志级别时,还可以自定义分组,以组为单位划分日志级别</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">logging.group.组名=包名</span><br><span class="line">logging.level.组名=日志级别</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">logging.group.tomcat=org.apache.catalina,org.apache.coyote,org.apache.tomcat</span><br><span class="line">logging.level.tomcat=trace</span><br></pre></td></tr></table></figure><p>SpringBoot 预定义两个组</p><table><thead><tr><th>Name</th><th>Loggers</th></tr></thead><tbody><tr><td>web</td><td>org.springframework.core.codec,</br> org.springframework.http,</br> org.springframework.web,</br> org.springframework.boot.actuate.endpoint.web,</br> org.springframework.boot.web.servlet.ServletContextInitializerBeans</td></tr><tr><td>sql</td><td>org.springframework.jdbc.core,</br> org.hibernate.SQL,</br> org.jooq.tools.LoggerListener</td></tr></tbody></table><h2 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h2><p>SpringBoot默认只把日志写在控制台,如果想额外记录到文件,<br>可以在<code>application.properties</code>中添加<code>logging.file.name</code> or <code>logging.file.path</code>配置项</p><table><thead><tr><th>logging.file.name</th><th>logging.file.path</th><th>示例</th><th>效果</th></tr></thead><tbody><tr><td>-</td><td>-</td><td></td><td>仅控制台输出</td></tr><tr><td>指定</td><td>-</td><td>my.log</td><td>写入指定文件。可以加路径</td></tr><tr><td>-</td><td>指定</td><td>&#x2F;var&#x2F;log</td><td>写入指定目录，文件名为<code>spring.log</code></td></tr><tr><td>指定</td><td>指定</td><td></td><td>以<code>logging.file.name</code>为准(path无效)</td></tr></tbody></table><h3 id="归档与切割"><a href="#归档与切割" class="headerlink" title="归档与切割"></a>归档与切割</h3><blockquote><p>归档：每天的日志单独存到一个文档中<br>切割：每个文件10MB,超过大小切割成另外一个文件</p></blockquote><p>每天的日志应该独立分割出来存档.如果使用<code>Logback</code>(SpringBoot默认日志实现),<br>可以通过<code>application.properties/yaml</code>文件指定日志滚动规则</p><p>如果是其他日志系统,需要自行配置(添加<code>log4j2.xml</code>或<code>log4j2-spring.xml</code>)</p><p>滚动规则设置如下:</p><table><thead><tr><th>配置项</th><th>描述</th></tr></thead><tbody><tr><td><strong>logging.logback.rollingpolicy.file-name-pattern</strong></td><td>日志存档的文件名格式（默认值：<strong>${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz</strong> ）</td></tr><tr><td><strong>logging.logback.rollingpolicy.clean-history-on-start</strong></td><td>应用启动时是否清除以前存档（默认值：<strong>false</strong>）</td></tr><tr><td><strong>logging.logback.rollingpolicy.max-file-size</strong></td><td>存档前，每个日志文件的最大大小（默认值：<strong>10MB</strong></td></tr><tr><td><strong>logging.logback.rollingpolicy.total-size-cap</strong></td><td>日志文件被删除之前，可以容纳的最大大小（默认值：0B）。设置<strong>1GB</strong>则磁盘存储超过<strong>1GB</strong>日志后就会删除旧日志文件</td></tr><tr><td><strong>logging.logback.rollingpolicy.max-history</strong></td><td>日志文件保存的最大天数(默认值：<strong>7</strong>)</td></tr></tbody></table><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>通常配置<code>application.properties</code>就够了.当然也可以自定义. 比如:</p><table><thead><tr><th>日志系统</th><th>自定义文件</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy</td></tr><tr><td>Log4j2</td><td>log4j2-spring.xml or log4j2.xml</td></tr><tr><td>JUL</td><td>logging.properties</td></tr></tbody></table><p>建议在日志配置中使用<code>-spring</code>变量(比如<code>logback-spring.xml</code>而不是<code>logback.xml</code>).<br>如果使用标准配置文件, <code>spring</code>无法完全控制日志初始化</p><h2 id="切换日志组合"><a href="#切换日志组合" class="headerlink" title="切换日志组合"></a>切换日志组合</h2><p>需要排除SpringBoot自带的日志</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>log4j2</code>支持<code>yaml</code>和<code>json</code>格式的配置文件</p><table><thead><tr><th>格式</th><th>依赖</th><th>文件名</th></tr></thead><tbody><tr><td>YAML</td><td>com.fasterxml.jackson.core:jackson-databind + com.fasterxml.jackson.dataformat:jackson-dataformat-yaml</td><td>log4j2.yaml + log4j2.yml</td></tr><tr><td>JSON</td><td>com.fasterxml.jackson.core:jackson-databind</td><td>log4j2.json + log4j2.jsn</td></tr></tbody></table><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>导入任何第三方框架,先排除它的日志包,因为SpringBoot底层控制好了日志</li><li>修改<code>application.properties</code>配置文件,就可以调整日志的所有行为.如果不够,可以编写日志框架自己的配置文件放在类路径下就行,比如<code>logback-spring.xml</code>,<code>log4j2-spring.xml</code></li><li>如需<strong>对接专业日志系统</strong>,也只需要把<code>logback</code>记录的日志配置文件导入<code>kafka</code>之类的中间件即可,这和SpringBoot没关系,都是日志框架自己的配置,修改配置文件即可</li><li>业务中使用slf4j-api记录日志</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot日志&quot;&gt;&lt;a href=&quot;#SpringBoot日志&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot日志&quot;&gt;&lt;/a&gt;SpringBoot日志&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我的&lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java日志体系</title>
    <link href="http://fu-jw.com/posts/c3b98719.html"/>
    <id>http://fu-jw.com/posts/c3b98719.html</id>
    <published>2023-06-12T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java日志体系"><a href="#Java日志体系" class="headerlink" title="Java日志体系"></a>Java日志体系</h1><p>日志记录了系统行为的时间, 地点, 状态等相关信息, 能够帮助我们了解并监控系统状态,<br>在发生错误或者接近某种危险状态时能及时提醒我们处理, 同时在系统产生问题, 能够帮助我们快速定位, 诊断问题.</p><p>在生产环境中日志可能是我们<strong>了解系统运行状况的唯一方式</strong>, 其重要性无需赘述<br>总结如下优点:</p><ul><li>记录系统行为</li><li>监控系统状态</li><li>提示系统风险</li><li>定位系统问题</li></ul><h2 id="0-System-out"><a href="#0-System-out" class="headerlink" title="0.System.out"></a>0.System.out</h2><p>同样可以打印信息, 为什么不用<code>System.out.print(&quot;&quot;)</code>?</p><ol><li>难定位<br><code>System.out.print</code>输出的日志只打印在控制台, 没有存储到一个日志文件中, 且格式不统一, 在生产环境这样打印出来很难定位信息, 意义不大.</li><li>性能弱<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    write(String.valueOf(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            ensureOpen();</span><br><span class="line">            textOut.write(s);</span><br><span class="line">            textOut.flushBuffer();</span><br><span class="line">            charOut.flushBuffer();</span><br><span class="line">            <span class="keyword">if</span> (autoFlush &amp;&amp; (s.indexOf(<span class="string">&#x27;\n&#x27;</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedIOException x) &#123;</span><br><span class="line">        Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">        trouble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>由上面的源码可以看出<code>print</code>的方法实现是由<code>synchronized</code>包裹的同步代码块<br>不能异步打印日志, 在<strong>高并发</strong>的情况下, 会严重<strong>影响性能</strong></li></ol><p><strong>阿里巴巴Java开发手册:</strong></p><blockquote><p>【强制】 应用中不可直接使用日志系统（ Log4j、 Logback） 中的 API，而应依赖使用日志框架（ SLF4J、 JCL–Jakarta Commons Logging） 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一<br>【强制】 生产环境禁止直接使用 System.out 或 System.err 输出日志或使用e.printStackTrace()打印异常堆栈<br>【强制】 在日志输出时，字符串变量之间的拼接使用占位符的方式<br>【强制】 对于 trace&#x2F;debug&#x2F;info 级别的日志输出，必须进行日志级别的开关判断</p></blockquote><h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><p>Log for Java</p><p>Ceki Gülcü于2001年发布了Log4j, 并将其捐献给Apache软件基金会, 成为Apache基金会的顶级项目.<br>Apache基金会最早实现的一套日志框架, 通过使用<code>Log4j</code></p><ul><li>可以<strong>控制日志信息输送的目的地</strong>是控制台, 文件等</li><li>可以控制每一条日志的<strong>输出格式</strong></li><li>通过定义每一条<strong>日志信息的级别</strong>, 我们能够更加细致地控制日志的生成过程</li><li>可以通过一个<strong>配置文件</strong>来灵活地进行配置, 而不需要修改应用的代码 ☆☆</li></ul><p><code>Log4j</code>主要由<code>Loggers</code>(日志记录器), <code>Appenders</code>(输出端), <code>Layout</code>(格式化).</p><ul><li><code>Loggers</code>控制日志输出级别与日志是否输出</li><li><code>Appenders</code>指定日志的输出方式(输出到控制台或文件等)</li><li><code>Layout</code>控制日志的输出格式</li></ul><blockquote><p>2015年9月, Apache软件基金业宣布, Log4j不再维护, 建议所有相关项目升级到Log4j2.</p></blockquote><h2 id="JUL"><a href="#JUL" class="headerlink" title="JUL"></a>JUL</h2><p>Java Util Logging</p><p>SUN公司在JDK1.4发布的Java原生的日志框架, 使用时不需要另外引用第三方的类库, 相对其他的框架使用方便</p><ol><li>初始化<code>LogManager</code><ol><li><code>LogManager</code>加载logging.properties配置</li><li>添加<code>Logger</code>到<code>LogManager</code></li></ol></li><li>从<code>LogManager</code>中获取<code>Logger</code></li><li>设置级别<code>Level</code>, 并指定日志记录<code>LogRecord</code></li><li><code>Filter</code>提供日志级别之外更细粒度的控制</li><li><code>Handler</code>是用来处理日志输出位置</li><li><code>Formatter</code>用来格式化LogRecord</li></ol><!-- ![JUL流程](https://s2.loli.net/2023/06/13/bCoUrAMwVqHFGz7.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f79a49ed5f.webp"/><h2 id="JCL"><a href="#JCL" class="headerlink" title="JCL"></a>JCL</h2><p>Jakarta Commons Logging</p><blockquote><p>JUL的api与log4j是完全不同的(参数只接受string).由于日志系统没有互相关联,彼此没有约定,不同人的代码使用不同日志,替换和统一也就变成了一件非常棘手的事情.<br>那我们该如何解决这个问题呢?<br>抽象出一个接口层,对每个日志实现都适配或者转接,这样这些提供给别人的库都直接使用抽象层即可,以后需要调用的时候,就调用这些接口.</p></blockquote><p>Apache基金下Jakarta小组开发的通用日志API</p><p>主要功能是给<strong>所有的日志实现</strong>提供一个<strong>统一接口</strong>, 本身也提供日志实现(SimpleLog),但是很弱一般不用.<br>常见的日志实现如:最早的<strong>Log4j</strong>以及JDK自带的<strong>JUL</strong>等</p><!-- ![JCL](https://s2.loli.net/2023/06/13/EZ62fIKGMwTsRDn.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f79de6b8b2.webp"/><p>日志门面的好处:</p><ul><li><strong>面向接口编程</strong>  解耦合</li><li>可灵活切换日志框架</li><li>统一日志API方便使用</li><li>统一日志配置和管理</li></ul><blockquote><p>由于设计缺陷,只支持当时主流的几个日志实现,不利于其他日志的使用(需修改源码),现已淘汰!!!</p></blockquote><h2 id="SLF4J"><a href="#SLF4J" class="headerlink" title="SLF4J"></a>SLF4J</h2><blockquote><p><code>Log4j</code>的作者觉得<code>JCL</code>不好用,自己又写了一个新的接口api,就是<code>SLF4J</code>,<br>并且为了追求更极致的性能,新增了一套日志的实现,就是<code>logback</code></p></blockquote><p>Simple Logging Facade For Java</p><p><code>SLF4J</code>主要给Java日志访问提供一套标准,规范的API框架.</p><p>目前市面最流行的日志门面,主要功能:</p><ul><li>日志框架的绑定</li><li>日志框架的桥接</li></ul><h3 id="SLF4J的各种组合"><a href="#SLF4J的各种组合" class="headerlink" title="SLF4J的各种组合"></a>SLF4J的各种组合</h3><!-- ![SLF4J](https://s2.loli.net/2023/06/14/q1GbgIwUevMZ8WA.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7a7907f73.webp"/>需对应的适配器<ul><li><p>SLF4J unbound:没有绑定实现,则只有接口,没有日志功能</p></li><li><p>SLF4J bound to logback:logback是后出现的日志实现,实现了SLF4J接口,可直接搭配使用</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SLF4J + logback 组合结果(黑色字体):</span><br><span class="line">20:24:32.167 [main] ERROR com.fredo.slf4j.SLF4JTest -- error</span><br><span class="line">20:24:32.172 [main] WARN com.fredo.slf4j.SLF4JTest -- warn</span><br><span class="line">20:24:32.172 [main] INFO com.fredo.slf4j.SLF4JTest -- info</span><br><span class="line">20:24:32.172 [main] ERROR com.fredo.slf4j.SLF4JTest -- 出现异常:java.lang.ArithmeticException: / by zero</span><br><span class="line"></span><br><span class="line">注意:注释slf4j-simple, 并且不要排除SpringBoot内置的日志实现:logback</span><br></pre></td></tr></table></figure></li><li><p>SLF4J bound to reload4j:reload4j是先出现的日志实现,没有实现了SLF4J接口,需配合适配器使用</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SLF4J + log4j 组合结果:</span><br><span class="line"> 2023-06-11 20:38:19.738 error</span><br><span class="line"> 2023-06-11 20:38:19.739 warn</span><br><span class="line"> 2023-06-11 20:38:19.739 info</span><br><span class="line"> 2023-06-11 20:38:19.739 debug</span><br><span class="line"> 2023-06-11 20:38:19.740 trace</span><br><span class="line"> 2023-06-11 20:38:19.741 出现异常:java.lang.ArithmeticException: / by zero</span><br><span class="line"></span><br><span class="line"> 注意:需要适配器:slf4j-log4j12以及log4j对应的配置文件</span><br></pre></td></tr></table></figure></li><li><p>SLF4J bound to JUL:JUL是先出现的日志实现,没有实现了SLF4J接口,需适配器使用</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SLF4J + JUL 组合结果(红色字体):</span><br><span class="line"> 6月 11, 2023 20:42:46 上午 com.fredo.slf4j.SLF4JTest test01</span><br><span class="line"> SEVERE: error</span><br><span class="line"> 6月 11, 2023 20:42:46 上午 com.fredo.slf4j.SLF4JTest test01</span><br><span class="line"> WARNING: warn</span><br><span class="line"> 6月 11, 2023 20:42:46 上午 com.fredo.slf4j.SLF4JTest test01</span><br><span class="line"> INFO: info</span><br><span class="line"> 6月 11, 2023 20:42:46 上午 com.fredo.slf4j.SLF4JTest test01</span><br><span class="line"> SEVERE: 出现异常:java.lang.ArithmeticException: / by zero</span><br><span class="line"></span><br><span class="line"> 注意:JDK默认自带无需依赖,但需要对应的适配器:slf4j-jdk14</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>SLF4J bound to simple:simple是后出现的日志实现,实现了SLF4J接口,可直接搭配使用</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SLF4J + SLF4J-Simple 组合结果(红色字体):</span><br><span class="line"> [main] ERROR com.fredo.slf4j.SLF4JTest - error</span><br><span class="line"> [main] WARN com.fredo.slf4j.SLF4JTest - warn</span><br><span class="line"> [main] INFO com.fredo.slf4j.SLF4JTest - info</span><br><span class="line"> [main] ERROR com.fredo.slf4j.SLF4JTest - 出现异常:java.lang.ArithmeticException: / by zero</span><br><span class="line"></span><br><span class="line"> 注意:需要提前排除:logback.SpringBoot默认的日志实现</span><br><span class="line"> &lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">     &lt;exclusions&gt;</span><br><span class="line">         &lt;exclusion&gt;</span><br><span class="line">             &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">             &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">         &lt;/exclusion&gt;</span><br><span class="line">     &lt;/exclusions&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>SLF4J bound to nop:nop是日志开关,关闭日志实现,不打印日志</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">SLF4J + slf4j-nop 组合结果:</span><br><span class="line"> 无任何打印(slf4j-nop关闭了日志打印)</span><br><span class="line"></span><br><span class="line"> 注意:提前排除SpringBoot默认自带的logback日志实现.</span><br></pre></td></tr></table></figure></li></ul><p>小结一下:</p><ul><li>添加依赖:<code>slf4j-api</code>,使用<code>sl4j</code>的API在项目中进行统一日志记录</li><li>绑定具体的日志实现<ul><li>对于已经实现了<code>sl4j</code>API的日志实现,直接添加对应的依赖即可</li><li>对于没有实现<code>sl4j</code>API的日志实现,需要先添加对应的日志<strong>适配器</strong>,再添加对应的依赖</li></ul></li><li><code>sl4j</code>有且仅有一个日志实现的绑定,出现多个时默认使用第一个</li></ul><h3 id="SLF4J桥接器"><a href="#SLF4J桥接器" class="headerlink" title="SLF4J桥接器"></a>SLF4J桥接器</h3><blockquote><p>以上都是SLF4J和不同的日志组合实现,可以发现不同的日志框架打印的日志格式不一!!!<br>这是因为SLF4J为了适配不同的日志框架提供了不同的<strong>适配器</strong>,具体的日志记录还是交给对应的日志框架实现的</br><br>SLF4J还提供了<strong>桥接器</strong>!!!<br>桥接器则是由SLF4J实现一套对应的日志框架的API,日志的记录打印完全由这套API实现,可以做到格式统一,且旧代码无需任何更改.</p></blockquote><p><strong>桥接器</strong>解决的是项目中日志的遗留问题,当系统中存在之前的日志API可以通过桥接转换到SLF4J的实现</p><ol><li>移除旧日志框架的依赖–此时旧代码会报错(没有依赖了)</li><li>添加SLF4J提供的对应的桥接组件–SLF4J自己提供一套API,旧代码不再报错</li><li>为项目添加SLF4J的具体实现–就是新的日志实现(SLF4J作为日志门面,还需要具体的日志实现)</li></ol><!-- ![SLF4J桥接](https://s2.loli.net/2023/06/14/YI3nCNavq5oZFbU.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7a9bba159.webp"/><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>pom.xml部分内容:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">假设以前使用了log4j的日志框架,但后续想要改用其他日志框架,如logback</span></span><br><span class="line"><span class="comment">原来的代码由于使用的log4j,依赖也是log4j的API,现在没有了log4j的依赖则会报错</span></span><br><span class="line"><span class="comment">当有了桥接器则只需要引入对应的桥接器即可,旧代码无任何改动</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;dependency&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;groupId&gt;log4j&lt;/groupId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;artifactId&gt;log4j&lt;/artifactId&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;version&gt;1.2.17&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/dependency&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--log4j和slf4j的桥接器--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将log4j桥接到slf4j,slf4j再去使用logback记录日志--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 桥接器演示</span></span><br><span class="line"><span class="comment"> *  假设以前使用的日志是:Log4j</span></span><br><span class="line"><span class="comment"> *  现在要换成Logback(SpringBoot 默认自带,无需引入依赖)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log4jTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(Log4jTest.class);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">&quot;Hello Log4j&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用log4j时,打印信息:</span></span><br><span class="line"><span class="comment">     *  2023-06-11 21:52:29.039 Hello Log4j</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用log4j和slf4j的桥接器时,打印信息:</span></span><br><span class="line"><span class="comment">     *  22:10:38.352 [main] INFO com.fredo.slf4j.Log4jTest -- Hello Log4j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:**适配器和桥接器不要同时出现!!!**否则可能出现<code>StackOverflowError</code>异常(我没演示出来~~~)</p><h2 id="Logback"><a href="#Logback" class="headerlink" title="Logback"></a>Logback</h2><p>是<code>Log4j</code>的创始人设计的另一个开源日志组件,性能比<code>Log4j</code>好.</p><p>logback分为三个模块:</p><ul><li>logback-core:其他两个模块的核心</li><li>logback-classic:兼容<code>log4j 1.x</code>和<code>JUL</code>,并进行了改进</li><li>logback-access:与Servlet容器(如Tomcat和Jetty)集成,以提供<code>HTTP</code>访问日志功能</li></ul><h2 id="Log4j2"><a href="#Log4j2" class="headerlink" title="Log4j2"></a>Log4j2</h2><p>Apache <code>Log4j2</code>是对<code>Log4j</code>的重大升级,并参考了<code>logback</code>的一些优秀设计,主要特点:</p><ul><li>异常处理机制: 在<code>logback</code>中,<code>Appender</code>中的异常不会被感知到,但在<code>log4j2</code>中提供了异常处理机制</li><li>性能提升: 相较<code>log4j</code>和<code>logback</code>都有明显性能提升</li><li>自动重载配置: 参考<code>logback</code>的设计,自动刷新参数配置,生产环境可动态修改日志配置</li><li>无垃圾机制: 避免频繁的日志收集导致JVM的GC.</li></ul><p>注意:<code>Log4j2</code>既是日志门面又是日志实现,但<code>SLF4J</code>日志门面更早出现更流行,所以市面上主流的搭配还是<code>SLF4J</code>+<code>Logback</code>&#x2F;<code>Log4J2</code></p><ul><li>log4j-api: 是日志门面</li><li>log4j-core: 是日志实现</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>市面上的日志框架可分成两类:日志门面和日志实现</p><!-- ![日志分类](https://s2.loli.net/2023/06/16/6ApzJit1ovaQ9w5.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7acd02dad.webp"/><p>项目中会选一个日志门面和一个日志实现组合</p><ul><li>日志门面一般选<code>SLF4J</code>,相比<code>JCL</code>更简单好用</li><li>日志实现一般选<code>Logback</code>.<code>SLF4J</code>和<code>Logback</code>&#x2F;<code>Log4j</code>是同一个作者更易搭配,且<code>Logback</code>是<code>Log4j</code>的升级版</li></ul><p>市面上常见搭配是:<code>SLF4J</code>+<code>Logback</code>(也是SpringBoot的默认)</p><p>而Apache基金新推出的<code>Log4j2</code>比<code>Logback</code>性能更好,<code>SLF4J</code>+<code>Log4j2</code>也是大势所趋.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java日志体系&quot;&gt;&lt;a href=&quot;#Java日志体系&quot; class=&quot;headerlink&quot; title=&quot;Java日志体系&quot;&gt;&lt;/a&gt;Java日志体系&lt;/h1&gt;&lt;p&gt;日志记录了系统行为的时间, 地点, 状态等相关信息, 能够帮助我们了解并监控系统状态,&lt;br</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="http://fu-jw.com/tags/Java/"/>
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot自动配置原理浅析</title>
    <link href="http://fu-jw.com/posts/ab942f3d.html"/>
    <id>http://fu-jw.com/posts/ab942f3d.html</id>
    <published>2023-06-03T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot自动配置原理浅析"><a href="#SpringBoot自动配置原理浅析" class="headerlink" title="SpringBoot自动配置原理浅析"></a>SpringBoot自动配置原理浅析</h1><blockquote><p>我的<a href="https://github.com/fu-jw/spring-tutorial">SpringBoot项目</a>第二个模块</p></blockquote><p>在日常开发中, 通常我们只需要引入某个<code>场景启动器</code>, 再加上一些相应的配置即可, 无需费心复杂的整合操作, 这也是 SpringBoot 的强大之处.</p><p>SpringBoot 是如何省去繁杂的整合过程的呢?</p><p>接下来按照流程一步一步分析.</p><h2 id="SpringBoot自动配置流程"><a href="#SpringBoot自动配置流程" class="headerlink" title="SpringBoot自动配置流程"></a>SpringBoot自动配置流程</h2><h3 id="1-导入starter"><a href="#1-导入starter" class="headerlink" title="1.导入starter"></a>1.导入<code>starter</code></h3><p>以<code>web场景</code>为例, 导入了web开发场景</p><ol><li>场景启动器导入了相关场景的所有依赖, 如下:<ul><li><code>starter-json</code>,<code>starter-tomcat</code>,<code>springMVC</code></li></ul></li><li>每个场景启动器都引入了一个<code>spring-boot-starter</code>, <strong>核心场景启动器</strong></li><li><strong>核心场景启动器</strong>引入了<code>spring-boot-autoconfigure</code>包</li><li><code>spring-boot-autoconfigure</code>里面囊括了所有场景的所有配置</li><li>只要这个包下的所有类都能生效, 那么相当于SpringBoot官方写好的整合功能就生效了</li><li>SpringBoot默认却扫描不到<code>spring-boot-autoconfigure</code>下写好的所有<strong>配置类</strong>.<ul><li>这些<strong>配置类</strong>给我们做了整合操作,默认只扫描主程序所在的包</li></ul></li></ol><h3 id="2-主程序：-SpringBootApplication"><a href="#2-主程序：-SpringBootApplication" class="headerlink" title="2.主程序：@SpringBootApplication"></a>2.主程序：@SpringBootApplication</h3><p>为什么引入场景,无需配置就已经整合完成了?一切都要从<code>@SpringBootApplication</code>开始</p><p><code>@SpringBootApplication</code>由三个注解组成<code>@SpringBootConfiguration</code>,<code>@EnableAutoConfiguration</code>,<code>@ComponentScan</code></p><ul><li><code>@SpringBootConfiguration</code> 其实就是<code>@Configuration</code>, 声明主程序类是一个<strong>配置类</strong></li><li><code>@ComponentScan</code> SpringBoot默认只能扫描自己主程序所在的包及其下面的子包, 扫描不到<code>spring-boot-autoconfigure</code>包中官方写好的<strong>配置类</strong></li><li><code>@EnableAutoConfiguration</code>就是SpringBoot开启<strong>自动配置</strong>的核心<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong><code>@Import(AutoConfigurationImportSelector.class)</code> 可以批量给容器中导入组件</strong></li><li><a href="mailto:&#83;&#112;&#114;&#x69;&#110;&#x67;&#66;&#x6f;&#x6f;&#x74;&#64;&#51;&#46;&#x31;&#46;&#48;">&#83;&#112;&#114;&#x69;&#110;&#x67;&#66;&#x6f;&#x6f;&#x74;&#64;&#51;&#46;&#x31;&#46;&#48;</a> 会批量导入146个<strong>自动配置类</strong>(<code>xxxAutoConfiguration</code>)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware,</span><br><span class="line">ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 批量获取候选配置</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>    annotationMetadata 注解元信息(主程序全类名,本项目为:com.fredo.Main)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span>   候选配置的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">         <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 获取自动配置节点</span></span><br><span class="line">      <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">      <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取自动配置节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">         <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回注解属性, 类型:LinkedHashMap, 值(exclude-&gt;[],excludeName-&gt;[])</span></span><br><span class="line">      <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);</span><br><span class="line">      <span class="comment">// 获取候选配置类 值(146个自动配置类的全类名)</span></span><br><span class="line">      List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">      <span class="comment">// 去重, 移除重复项</span></span><br><span class="line">      configurations = removeDuplicates(configurations);</span><br><span class="line">      <span class="comment">// 获取排除项</span></span><br><span class="line">      Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">      checkExcludedClasses(configurations, exclusions);</span><br><span class="line">      <span class="comment">// 移除要排除的配置项</span></span><br><span class="line">      configurations.removeAll(exclusions);</span><br><span class="line">      configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">      fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取候选配置类</span></span><br><span class="line"><span class="comment">     * 位置:META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;</span><br><span class="line">        List&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())</span><br><span class="line">                .getCandidates();</span><br><span class="line">        Assert.notEmpty(configurations,</span><br><span class="line">                <span class="string">&quot;No auto configuration classes found in &quot;</span></span><br><span class="line">                        + <span class="string">&quot;META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you &quot;</span></span><br><span class="line">                        + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> configurations;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>按需生效</strong><ul><li>虽然导入了146个<strong>自动配置类</strong>, 并不是都能生效</li><li>每一个<strong>自动配置类</strong>, 都有条件注解<code>@ConditionalOnxxx</code>, 只有条件成立, 才能生效 </li><li>导入对应的依赖包, 即满足条件, 该自动配置类就会生效</li></ul></li></ul><h3 id="3-xxxAutoConfiguration自动配置类"><a href="#3-xxxAutoConfiguration自动配置类" class="headerlink" title="3.xxxAutoConfiguration自动配置类"></a>3.<code>xxxAutoConfiguration</code>自动配置类</h3><ol><li><p>每个<code>xxxAutoConfiguration</code>自动配置类,都需要满足某个条件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass(Xxx.class)</span> <span class="comment">// 条件就是需要引入依赖包含 Xxx.class</span></span><br><span class="line"><span class="meta">@Conditional(XxxCondition.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(XxxProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxxAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件满足, <strong>自动配置类</strong>就会给容器中使用<code>@Bean</code>放一堆组件</p></li><li><p>每个<strong>自动配置类</strong>都可能有这个注解<code>@EnableConfigurationProperties(XxxProperties.class)</code></p><ul><li>用来把配置文件中配的<strong>指定前缀</strong>的属性值封装到<code>XxxProperties</code><strong>属性类</strong>中</li></ul></li><li><p>以<strong>Tomcat</strong>为例：把服务器的所有配置都是以<code>server</code>开头的。配置都封装到了属性类中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerProperties</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="SpringBoot核心配置流程"><a href="#SpringBoot核心配置流程" class="headerlink" title="SpringBoot核心配置流程"></a>SpringBoot核心配置流程</h2><ol><li>导入<code>starter</code>, 就会导入<code>autoconfigure</code>包</li><li><code>autoconfigure</code>包里有文件:<strong>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports</strong>,里面指定的所有启动要加载的<strong>自动配置类</strong></li><li><code>@EnableAutoConfiguration</code>会自动的把上面文件里所有<strong>自动配置类</strong>都导入进来. <code>XxxAutoConfiguration</code>是有<strong>条件注解进行按需加载</strong></li><li><code>XxxAutoConfiguration</code>给容器中导入一堆组件, 组件都是从<code>xxxProperties</code>中提取属性值</li><li><code>XxxProperties</code>又和<strong>配置文件</strong>进行绑定</li></ol><p>达到的效果:导入<code>starter</code> –&gt; 修改配置文件, 就能修改底层行为</p><!-- ![SpringBoot自动装配](https://s2.loli.net/2023/06/11/ZGxL4F7YPrOqQcy.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f785fe3f3d.webp"/><h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>接下来检验下SpringBoot自动配置原理的理解, 尝试回答如下问题:</p><details> <summary><strong><span style="color: red; ">为什么项目启动后默认端口号是8080, 以及如何修改???</span></strong></summary><ol><li>引入<code>web场景</code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>自动引入了<code>spring-boot-starter</code>和<code>spring-boot-starter-tomcat</code><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><code>spring-boot-starter</code>自动引入依赖<code>spring-boot-autoconfigure</code>包<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><code>spring-boot-autoconfigure</code><br>包里有文件:</li></ol><ul><li><strong>additional-spring-configuration-metadata.json</strong>, 里面包含了所有的默认值<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;server.port&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;defaultValue&quot;</span><span class="punctuation">:</span> <span class="number">8080</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports</strong>,里面指定的所有启动要加载的<strong>自动配置类</strong></li></ul><!-- ![spring-boot-autoconfigure包](https://s2.loli.net/2023/06/11/ArMcsINnLb5pZ7t.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f78f673876.webp"/><ol start="2"><li>合成注解<code>@SpringBootApplication</code>中的<code>@EnableAutoConfiguration</code><br>自动的把上面文件里所有<strong>自动配置类</strong>都导入进来. <code>XxxAutoConfiguration</code>是有<strong>条件注解进行按需加载</strong></li></ol><p>其中就包括<code>ServletWebServerFactoryAutoConfiguration.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoConfiguration(after = SslAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRequest.class)</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span></span><br><span class="line"><span class="meta">ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span></span><br><span class="line"><span class="meta">ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span></span><br><span class="line"><span class="meta">ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletWebServerFactoryAutoConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绑定了属性文件<code>ServerProperties</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要在自己的配置文件中自定义<code>server.port</code>的值</p><p>SpringBoot启动时就会去resources路径下加载符合要求的文件, 从该文件中查找配置来覆盖默认配置,<br>即完成了配置自定义</p><p><code>spring-boot-starter-parent-3.1.0.pom</code>文件:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.yaml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/application*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></details><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot自动配置原理浅析&quot;&gt;&lt;a href=&quot;#SpringBoot自动配置原理浅析&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot自动配置原理浅析&quot;&gt;&lt;/a&gt;SpringBoot自动配置原理浅析&lt;/h1&gt;&lt;blockquo</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中常见注解</title>
    <link href="http://fu-jw.com/posts/f026602.html"/>
    <id>http://fu-jw.com/posts/f026602.html</id>
    <published>2023-06-02T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot中常见注解"><a href="#SpringBoot中常见注解" class="headerlink" title="SpringBoot中常见注解"></a>SpringBoot中常见注解</h1><p>Spring 开始是使用的XML的配置方式, 但随着配置内容的增加, 编写XML配置文件的方式不仅繁琐, 而且还很容易出错.<br>另外，每个项目都编写大量的XML文件来配置Spring, 也大大增加了项目维护的复杂度.<br>往往很多个项目的Spring XML文件的配置大部分是相同的, 只有很少量的配置不同, 这也造成了配置文件上的冗余<br>Spring注解驱动来开发, 你会发现以上这些问题都将不存在.<br>SpringBoot 则从一开始就改为全注解驱动.</p><h2 id="0-基于XML配置方式"><a href="#0-基于XML配置方式" class="headerlink" title="0.基于XML配置方式"></a>0.基于XML配置方式</h2><ol><li>resources&#x2F;ioc.xml<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.fredo.bean.Person&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;fredo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.fredo.bean.Cat&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tom&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>Main.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XML 的方式</span></span><br><span class="line"><span class="type">var</span> <span class="variable">ioc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;ioc.xml&quot;</span>);</span><br><span class="line">String[] names = ioc.getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;容器中的Bean:&quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>3.output<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">容器中的Bean:person</span><br><span class="line">容器中的Bean:cat</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-注解的方式"><a href="#1-注解的方式" class="headerlink" title="1.注解的方式"></a>1.注解的方式</h2><p>在代码中使用<code>@Configuration</code>和<code>@Bean</code>两个注解, 即可替代以前复杂的xml配置</p><p>config&#x2F;AppConfig.java</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 这是一个配置类, 替代以前的xml配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 替代以前xml中的bean标签</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">person</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setId(<span class="number">1</span>);</span><br><span class="line">        person.setName(<span class="string">&quot;fred0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">cat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        cat.setId(<span class="number">1</span>);</span><br><span class="line">        cat.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-常见注解"><a href="#2-常见注解" class="headerlink" title="2.常见注解"></a>2.常见注解</h2><h3 id="Component及其衍生组件-Repository-Controller-Service-Configuration"><a href="#Component及其衍生组件-Repository-Controller-Service-Configuration" class="headerlink" title="@Component及其衍生组件(@Repository, @Controller, @Service, @Configuration)"></a>@Component及其衍生组件(@Repository, @Controller, @Service, @Configuration)</h3><ul><li>@Component 是通用组件</li><li>@Repository 用于持久层</li><li>@Controller 用于表现层</li><li>@Service 用于业务逻辑层</li><li>@Configuration 用于配置文件</li></ul><h3 id="Configuration和-Bean"><a href="#Configuration和-Bean" class="headerlink" title="@Configuration和@Bean"></a>@Configuration和@Bean</h3><ul><li><code>@Configuration</code> 标注在<strong>类</strong>上, 声明这个类是一个配置类, 加入ioc容器中, 相当于以前的xml配置文件</li><li><code>@Bean</code> 标注在<strong>方法</strong>上, 该方法的输出结果就是一个 JavaBean</li></ul><p><code>@Configuration</code>和<code>@Bean</code>配合使用就可完全替代XML的配置文件</p><p><code>@SpringBootConfiguration</code>是 SpringBoot 中的特有注解, <code>@Configuration</code>是通用版注解, 功能一样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Indexed</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line"><span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>bean的名称, 默认是方法名</li><li>可以修改, <code>@Bean(&quot;newName&quot;)</code></li></ul><details> <summary>已经有`@Component`及其衍生组件,为什么还要`@Bean`注解?</summary><ul><li>类似<code>@Component</code>,<code>@Repository</code>,<code>@Controller</code>,<code>@Service</code>这些注册Bean的注解存在局限性:只能作用于自己编写的类, 不能导入第三方jar包, 但是<code>@Bean</code>就可以做到这一点！</li><li>能够动态获取一个Bean对象，能够根据环境不同得到不同的Bean对象</details></li></ul><h3 id="Component和-ComponentScan"><a href="#Component和-ComponentScan" class="headerlink" title="@Component和@ComponentScan"></a>@Component和@ComponentScan</h3><p>在实际项目中, 我们更多的是使用 Spring 的包扫描功能对项目中的包进行扫描,<br>凡是在指定的包或其子包中的类上标注了<code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>, <code>@Component</code>注解的类都会被扫描到, 并将这个类注入到 Spring 容器中</p><p>Spring 包扫描功能可以使用XML配置文件进行配置, 也可以直接使用<code>@ComponentScan</code>注解进行设置, 使用<code>@ComponentScan</code>注解进行设置比使用XML配置文件来配置要简单的多</p><p>XML方式</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包扫描：只要是标注了我们熟悉的@Controller、@Service、@Repository、@Component这四个注解中的任何一个的组件，它就会被自动扫描，并加进容器中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.fredo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@ComponentScan</code>方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;)</span> <span class="comment">// value指定要扫描的包</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 这是一个配置类, 替代以前的xml配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:<br>0. 主程序标注了<code>@SpringBootApplication</code>, 就会默认扫描主程序所在的包及其子包; </p><ol><li>如果设置了<code>@ComponentScan(&quot;...&quot;)</code>, 则以设置的扫描路径为主, 默认值不再生效</li><li><code>@ComponentScan</code>还可以设置包含某些组件(<code>includeFilters()</code>)或者排除某些组件(<code>excludeFilters()</code>)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, excludeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     * classes：除了@Controller和@Service标注的组件之外，IOC容器中剩下的组件我都要，即相当于是我要排除@Controller和@Service这俩注解标注的组件。</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Controller.class, Service.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure></li><li><code>@ComponentScan</code>是可重复注解<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     * classes：我们需要Spring在扫描时，只包含@Controller注解标注的类</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Controller.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     * classes：我们需要Spring在扫描时，只包含@Service注解标注的类</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Service.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure></li></ol><p>小结一下:</p><ul><li><code>@Component</code> 声明 Bean, 告诉 Spring 这是一个 Bean</li><li><code>@ComponentScan</code> 设置扫描路径, 告诉 Spring 到哪里找到这些 Bean</li></ul><h3 id="ComponentScan-Filter"><a href="#ComponentScan-Filter" class="headerlink" title="@ComponentScan.Filter"></a>@ComponentScan.Filter</h3><p>Spring 的强大之处不仅仅是提供了 IOC 容器,<br>可以设置包含某些组件(<code>includeFilters()</code>)或者排除某些组件(<code>excludeFilters()</code>), 它还能够通过自定义<code>TypeFilter</code>来指定过滤规则. </p><p><code>FilterType</code>中常用的规则如下: </p><ol><li>ANNOTATION：按照注解进行包含或者排除<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     * classes：我们需要Spring在扫描时，只包含@Controller注解标注的类</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ANNOTATION, classes=&#123;Controller.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure></li><li>ASSIGNABLE_TYPE：按照给定的类型进行包含或者排除<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    // 只要是BookService这种类型的组件都会被加载到容器中，不管是它的子类还是什么它的实现类。记住，只要是BookService这种类型的</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ASSIGNABLE_TYPE, classes=&#123;BookService.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure></li><li>ASPECTJ：使用表达式来挑选复杂的类子集<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.ASPECTJ, classes=&#123;AspectJTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure></li><li>REGEX：按照正则表达式进行包含或者排除<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.REGEX, classes=&#123;RegexPatternTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure></li><li>CUSTOM：按照自定义规则进行包含或者排除<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value=&quot;com.fredo&quot;, includeFilters=&#123;</span></span><br><span class="line"><span class="meta">    /*</span></span><br><span class="line"><span class="meta">     * type：指定你要排除的规则，是按照注解进行排除，还是按照给定的类型进行排除，还是按照正则表达式进行排除，等等</span></span><br><span class="line"><span class="meta">     */</span></span><br><span class="line"><span class="meta">    // 指定新的过滤规则，这个过滤规则是我们自个自定义的，过滤规则就是由我们这个自定义的MyTypeFilter类返回true或者false来代表匹配还是没匹配</span></span><br><span class="line"><span class="meta">    @Filter(type=FilterType.CUSTOM, classes=&#123;MyTypeFilter.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;, useDefaultFilters=false)</span> <span class="comment">// value指定要扫描的包</span></span><br></pre></td></tr></table></figure>MyTypeFilter.java<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTypeFilter</span> <span class="keyword">implements</span> <span class="title class_">TypeFilter</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * metadataReader：读取到的当前正在扫描的类的信息</span></span><br><span class="line"><span class="comment"> * metadataReaderFactory：可以获取到其他任何类的信息的（工厂）</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 返回值:</span></span><br><span class="line"><span class="comment">     * 当返回true时，表示符合规则，会包含在Spring容器中；</span></span><br><span class="line"><span class="comment">     * 当返回false时，表示不符合规则，就不会被包含在Spring容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 自定义过滤规则</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>属性值:</li></ol><ul><li>type: 要排除的方式:<code>FilterType</code></li><li>value: 要排除的类型, 同 <code>classes</code></li><li>classes: 同 <code>value</code></li><li>pattern: 正则表达式</li></ul><h3 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a>@Scope</h3><p>用于设置组件的<strong>作用域</strong>, 默认值是<code>singleton</code>单例</p><p>作用域取值:</p><ul><li>singleton: 单例, 默认值, 容器启动就会调用方法创建对象到ioc容器中</li><li>prototype: 多例, 容器启动时并不会调用方法创建对象, 每次获取时才会调用方法创建对象</li><li>request: web 环境中, 同一个请求只创建一个对象</li><li>session: web 环境中, 同一个 session 只创建一个对象</li><li>application: web 环境中, 一个应用程序只创建一个对象, 全局</li></ul><h3 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h3><p>懒加载就是Spring容器启动的时候, 先不创建对象, 在第一次使用(获取)bean的时候再来创建对象, 并进行一些初始化</p><p>注意: 懒加载, 仅针对单例bean生效</p><h3 id="条件注解"><a href="#条件注解" class="headerlink" title="条件注解"></a>条件注解</h3><p>@ConditionalOnXxx 注解指定的<strong>条件成立</strong>, 则触发指定行为</p><ul><li>@ConditionalOnClass：如果类路径中存在这个类，则触发指定行为</li><li>@ConditionalOnMissingClass：如果类路径中不存在这个类，则触发指定行为</li><li>@ConditionalOnBean：如果容器中存在这个Bean（组件），则触发指定行为</li><li>@ConditionalOnMissingBean：如果容器中不存在这个Bean（组件），则触发指定行为</li><li>…</li></ul><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><p>将容器中任意组件(Bean)的<strong>属性值和配置文件</strong>的配置项的值进行绑定</p><ol><li>给容器中注册组件(<code>@Component</code>, <code>@Bean</code>)</li><li>使用<code>@ConfigurationProperties</code>声明组件和配置文件的哪些配置项进行绑定</li></ol><p><code>@EnableConfigurationProperties</code> 快速注册注解</p><ul><li>SpringBoot 默认只扫描自己主程序所在的包. 如果导入第三方包, 即使组件上标注了<code>@Component</code>, <code>@ConfigurationProperties</code>注解, 也没用.</li><li>因为组件都扫描不进来, 此时使用这个注解就可以快速进行属性绑定并把组件注册进容器</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot中常见注解&quot;&gt;&lt;a href=&quot;#SpringBoot中常见注解&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot中常见注解&quot;&gt;&lt;/a&gt;SpringBoot中常见注解&lt;/h1&gt;&lt;p&gt;Spring 开始是使用的XML的配</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot快速入门</title>
    <link href="http://fu-jw.com/posts/4ccc97e8.html"/>
    <id>http://fu-jw.com/posts/4ccc97e8.html</id>
    <published>2023-06-01T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot快速入门"><a href="#SpringBoot快速入门" class="headerlink" title="SpringBoot快速入门"></a>SpringBoot快速入门</h1><blockquote><p>我的<a href="https://github.com/fu-jw/spring-tutorial">SpringBoot项目</a>第一个模块</p></blockquote><h2 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h2><p>按照官网一步一步操作即可:<br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.first-application">https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.first-application</a></p><h3 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h3><h4 id="pom-xml中出现Provides-transitive-vulnerable-dependency-maven-org-yaml-snakeyaml-1-33警告"><a href="#pom-xml中出现Provides-transitive-vulnerable-dependency-maven-org-yaml-snakeyaml-1-33警告" class="headerlink" title="pom.xml中出现Provides transitive vulnerable dependency maven:org.yaml:snakeyaml:1.33警告"></a>pom.xml中出现Provides transitive vulnerable dependency maven:org.yaml:snakeyaml:1.33警告</h4><ul><li>告警原因:Maven项目中使用了一个被认为是有漏洞的依赖项，并且这个依赖项也被其他依赖项所传递<ul><li>org.yaml:snakeyaml:1.33这个库是存在漏洞</li></ul></li><li>解决警告:升级依赖项<ul><li>在中央仓库搜索无告警版本: <a href="https://mvnrepository.com/">https://mvnrepository.com/</a></li><li>在Maven项目中，可以使用dependencyManagement标签来管理依赖项</li><li>这个标签中，可以指定一个特定版本，以便所有依赖项都将使用这个版本<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;dependencyManagement&gt;</span></span><br><span class="line">    <span class="string">&lt;dependencies&gt;</span></span><br><span class="line">        <span class="string">&lt;dependency&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.yaml&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;</span></span><br><span class="line">            <span class="string">&lt;version&gt;2.0&lt;/version&gt;</span></span><br><span class="line">        <span class="string">&lt;/dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;/dependencies&gt;</span></span><br><span class="line"><span class="string">&lt;/dependencyManagement&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>解决警告:移除依赖项<ul><li>如果这个库不是必须的，可以考虑从项目中移除它; 或者idea中设置忽略(眼不见心不烦)<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">    <span class="string">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="string">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span></span><br><span class="line">    <span class="string">&lt;exclusions&gt;</span></span><br><span class="line">        <span class="string">&lt;exclusion&gt;</span></span><br><span class="line">            <span class="string">&lt;groupId&gt;org.yaml&lt;/groupId&gt;</span></span><br><span class="line">            <span class="string">&lt;artifactId&gt;snakeyaml&lt;/artifactId&gt;</span></span><br><span class="line">        <span class="string">&lt;/exclusion&gt;</span></span><br><span class="line">    <span class="string">&lt;/exclusions&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="项目启动报错：An-incompatible-version-1-1-29-of-the-Apache-Tomcat-Native-library-is-installed-while-Tomcat-requires-version-1-2-34"><a href="#项目启动报错：An-incompatible-version-1-1-29-of-the-Apache-Tomcat-Native-library-is-installed-while-Tomcat-requires-version-1-2-34" class="headerlink" title="项目启动报错：An incompatible version [1.1.29] of the Apache Tomcat Native library is installed, while Tomcat requires version [1.2.34]"></a>项目启动报错：An incompatible version [1.1.29] of the Apache Tomcat Native library is installed, while Tomcat requires version [1.2.34]</h4><ul><li>打开网页 <a href="http://archive.apache.org/dist/tomcat/tomcat-connectors/native/">http://archive.apache.org/dist/tomcat/tomcat-connectors/native/</a></li><li>查找对应版本文件: <a href="http://archive.apache.org/dist/tomcat/tomcat-connectors/native/1.2.34/binaries/">http://archive.apache.org/dist/tomcat/tomcat-connectors/native/1.2.34/binaries/</a></li><li>下载对应的zip文件</li><li>解压文件,里面有32位和64位的 tcnative-1.dll 文件</li><li>根据自己的jdk和tomcat版本选择一个，复制到 jdk 的bin目录下即可</li><li>重启 spring boot项目</li></ul><h2 id="模块小结"><a href="#模块小结" class="headerlink" title="模块小结"></a>模块小结</h2><h3 id="SpringBoot-是什么"><a href="#SpringBoot-是什么" class="headerlink" title="SpringBoot 是什么"></a>SpringBoot 是什么</h3><p>SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 Spring 应用（说明：SpringBoot底层是Spring）</p><p>大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>简化整合<ul><li>SpringBoot提出<code>场景启动器</code>的概念</li><li>导入相关的场景，即拥有相关的功能。</li><li>默认支持的所有场景：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters</a><ul><li>官方提供的场景：命名为：spring-boot-starter-*</li><li>第三方提供场景：命名为：*-spring-boot-starter</li></ul></li><li>场景一导入，万物皆就绪</li></ul></li><li>简化开发<ul><li>无需编写任何配置，直接开发业务</li></ul></li><li>简化配置<ul><li>application.properties：</li><li>集中式管理配置。只需要修改这个文件就行 。</li><li>配置基本都有默认值</li><li>能写的所有配置都在： <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties</a></li></ul></li><li>简化部署<ul><li>打包为可执行的jar包。</li><li>linux服务器上有java环境。</li></ul></li><li>简化运维<ul><li>修改配置（外部放一个application.properties文件）、监控、健康检查。</li></ul></li></ol><h2 id="应用分析"><a href="#应用分析" class="headerlink" title="应用分析"></a>应用分析</h2><h3 id="依赖管理机制"><a href="#依赖管理机制" class="headerlink" title="依赖管理机制"></a>依赖管理机制</h3><ol><li><p>为什么导入<code>场景启动器</code>所有的依赖就都导入进来了?</p><ul><li>根据<code>maven</code>的依赖传递原则, A依赖B,B依赖C;则A同时依赖B C</li><li>以<code>web场景启动器</code>为例,引入<code>spring-boot-starter-web</code></li><li><code>spring-boot-starter-web</code> 会有很多依赖,包括其他<code>场景启动器</code><br>如<code>spring-boot-starter-tomcat</code>,<code>spring-web</code>,<code>spring-webmvc</code>等</li><li><strong>小结一下</strong>: 该<code>场景启动器</code>会将所有的依赖提前准备好,根据<code>maven</code>的依赖传递原则就可全部引入</li></ul></li><li><p>为什么版本号不用写?</p><ul><li>每个boot项目都有一个父项目<code>spring-boot-starter-parent</code></li><li>parent的父项目是<code>spring-boot-dependencies</code></li><li>也称<code>版本仲裁中心</code>,使用<code>dependencyManagement</code>标签已将所有常见的依赖版本号提前声明好</li></ul></li><li><p>自定义版本号</p><ul><li>根据<code>maven</code>的就近原则</li><li>直接在当前项目<code>properties</code>标签中修改版本号</li><li>或者直接在导入依赖的时候声明版本</li></ul></li><li><p>第三方的jar包</p><ul><li>boot 父项目没有管理的需要自行声明好</li></ul></li></ol><!-- ![SpringBoot依赖管理](https://s2.loli.net/2023/06/11/NzUIyCkxa6eLOPu.webp) --><img src="https://image.fu-jw.com/img/2023/07/01/649f7705d495d.webp"/><h3 id="自动装配机制"><a href="#自动装配机制" class="headerlink" title="自动装配机制"></a>自动装配机制</h3><h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>不用 SpringBoot 时, 要整合 SpringMVC 就需要自己手动配置:</p><ul><li><code>DispatcherServlet</code>: 拦截请求的组件</li><li><code>ViewResolver</code>: 视图解析组件</li><li><code>CharacterEncodingFilter</code>: 处理字符编码的组件</li><li>…</li></ul><p>现在有了 SpringBoot 以上组件都不用再自己手动配置了, 直接引入<code>web场景启动器</code>即可</p><h4 id="默认包扫描规则"><a href="#默认包扫描规则" class="headerlink" title="默认包扫描规则"></a>默认包扫描规则</h4><ul><li><code>@SpringBootApplication</code> 标注的类就是主程序类</li><li>SpringBoot 会默认扫描主程序所在的包及其子包, 即自动的 <strong>component-scan</strong> 功能</li><li>可自定义扫描路径<ul><li>@SpringBootApplication(scanBasePackages &#x3D; “com.fredo”)</li><li>@ComponentScan(“com.fredo”) 直接指定扫描的路径</li></ul></li></ul><h4 id="配置默认值"><a href="#配置默认值" class="headerlink" title="配置默认值"></a>配置默认值</h4><ul><li><strong>配置文件</strong>的所有配置项和某个类的对象值进行一一绑定</li><li>绑定了配置文件中每一项值的类称为: <strong>属性类</strong></li><li>参照<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html">官方文档</a>：或者参照绑定的<strong>属性类</strong></li></ul><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><ul><li><code>场景启动器</code>除了导入相关功能依赖, 还会导入一个<code>spring-boot-starter</code></li><li><code>spring-boot-starter</code>, 是所有<strong>starter</strong>的<strong>starter</strong>, 基础核心starter</li><li><code>spring-boot-starter</code>会导入包<code>spring-boot-autoconfigure</code>. 包里面都是全场景的 AutoConfiguration 自动配置类</li><li>虽然全场景的自动配置都在包:<code>spring-boot-autoconfigure</code>, 但并不会全都开启<ul><li>根据条件开启</li><li><code>@ConditionalOnXxx</code></li><li><code>@ConditionalOnMissingXxx</code></li></ul></li></ul><p>小结一下: 导入<code>场景启动器</code>, 触发<code>spring-boot-autoconfigure</code>这个包的自动配置生效, 容器中就会具有相关场景的功能</p><h4 id="自动配置流程细节梳理"><a href="#自动配置流程细节梳理" class="headerlink" title="自动配置流程细节梳理"></a>自动配置流程细节梳理</h4><ol><li>导入<code>场景启动器</code>, 以<code>spring-boot-starter-web</code>为例<ul><li>场景启动器就会导入相关场景的所有依赖, 如<code>starter-json</code>,<code>starter-tomcat</code>, <code>springmvc</code></li><li>每个场景启动器都会引入一个<code>spring-boot-starter</code>, 核心场景启动器</li><li><strong>核心场景启动器</strong>会引入包:<code>spring-boot-autoconfigure</code></li><li><code>spring-boot-autoconfigure</code>里面包含所有场景的所有配置</li><li>只要这个包下的所有类都能生效, 那么SpringBoot官方的整合功能就能生效</li><li>SpringBoot 默认扫描不到<code>spring-boot-autoconfigure</code>下的所有配置类(这些配置类给我们做了整合操作), 默认只扫描主程序所在的包</li></ul></li><li>主程序：@SpringBootApplication<ul><li><code>@SpringBootApplication</code>由三个注解组成: <code>@SpringBootConfiguration</code>, <code>@EnableAutoConfiguratio</code>, <code>@ComponentScan</code></li><li>SpringBoot 默认只扫描主程序所在的包及其下子包, 扫描不到<code>spring-boot-autoconfigure</code>包中的<strong>配置类</strong></li><li><code>@EnableAutoConfiguration</code>: SpringBoot 开启自动配置的核心<ul><li>是由<code>@Import(AutoConfigurationImportSelector.class)</code>提供功能：批量给容器中导入组件</li><li>SpringBoot 默认加载所有的配置类(SpringBoot3.1.0有146个)</li><li>这146个配置类来自于<code>spring-boot-autoconfigure</code>下 META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports 文件指定</li><li>项目启动的时候利用 @Import 批量导入组件机制, 把 autoconfigure 包下的<strong>自动配置类</strong>: xxxAutoConfiguration 导入进来</li></ul></li><li>按需生效<ul><li>这146个自动配置类并不全都生效</li><li>每个自动配置类都有条件注解<code>@ConditionalOnXxx</code>, 只有条件成立, 才能生效</li></ul></li></ul></li><li><code>xxxAutoConfiguration</code>自动配置类<ul><li>给容器中使用<code>@Bean</code>放一堆组件</li><li>每个自动配置类都可能有这个注解<code>@EnableConfigurationProperties(XxxProperties.class)</code>, 用来把配置文件中配的指定前缀的属性值封装到<code>xxxProperties</code>属性类中</li><li>以<code>Tomcat</code>为例: 把服务器的所有配置都是以<code>server</code>开头. 配置都封装到了属性类中</li><li>给容器中放的所有组件的一些核心参数, 都来自于<code>XxxProperties</code>. <code>XxxProperties</code>都是和配置文件绑定</li><li><strong>只需要改配置文件的值, 核心组件的底层参数都能修改</strong></li></ul></li><li>只需关注业务, 全程无需关心各种整合(底层这些已经整合完成)</li></ol><p>小结一下:</p><ol><li>导入<code>starter</code>, 就会导入<code>autoconfigure</code>包</li><li><code>autoconfigure</code>包里有文件: META-INF&#x2F;spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports, 里面指定了所有启动要加载的<strong>自动配置类</strong></li><li><code>@EnableAutoConfiguration</code>会自动的把上面文件里面写的所有<strong>自动配置类</strong>都导入进来</li><li><code>xxxAutoConfiguration</code>是有条件注解进行按需加载</li><li><code>xxxAutoConfiguration</code>给容器中导入许多组件, 组件都是从<code>xxxProperties</code>中提取属性值</li><li><code>xxxProperties</code>又和<strong>配置文件</strong>进行了绑定</li></ol><p>达到的效果: 导入<code>starter</code>, 修改配置文件, 就能修改底层行为</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SpringBoot快速入门&quot;&gt;&lt;a href=&quot;#SpringBoot快速入门&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot快速入门&quot;&gt;&lt;/a&gt;SpringBoot快速入门&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;我的&lt;a href</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="SpringBoot" scheme="http://fu-jw.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 中的数学公式</title>
    <link href="http://fu-jw.com/posts/63166764.html"/>
    <id>http://fu-jw.com/posts/63166764.html</id>
    <published>2022-12-30T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="希腊字母表"><a href="#希腊字母表" class="headerlink" title="希腊字母表"></a>希腊字母表</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\alpha</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\alpha$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\beta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\beta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\chi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\chi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\delta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\delta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Delta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Delta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\epsilon</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\epsilon$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\eta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\eta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Gamma</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Gamma$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\iota</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\iota$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\kappa</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\kappa$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lambda</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lambda$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Lambda</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Lambda$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\mu</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\mu$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nabla</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nabla$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nu</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nu$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\omega</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\omega$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Omega</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Omega$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\phi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\phi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Phi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Phi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\pi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\pi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Pi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Pi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\psi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\psi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Psi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Psi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rho</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rho$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sigma</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\sigma$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Sigma</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Sigma$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\tau</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\tau$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\theta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\theta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Theta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Theta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\upsilon</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\upsilon$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\varepsilon</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\varepsilon$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\varsigma</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\varsigma$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\vartheta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\vartheta$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\xi</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\xi$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\zeta</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\zeta$</p><h2 id="公式中的常见符号"><a href="#公式中的常见符号" class="headerlink" title="公式中的常见符号"></a>公式中的常见符号</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\cdot</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\cdot$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\colon</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\colon$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\vdots</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\vdots$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dotsm</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\dotsm$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dotso</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\dotso$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\ddots</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\ddots$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\check</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\check{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\grave</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\grave{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\breve</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\breve{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\acute</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\acute{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\tilde</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\tilde{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bar</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bar{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\hat</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\hat{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dot</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\dot{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\ddot</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\ddot{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\widehat</span>&#123;xxx&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\widehat{xxx}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\times</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\times$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\div</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\div$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\neq</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\neq$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\vec</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\vec{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\dddot</span>&#123;x&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\dddot{x}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\widetilde</span>&#123;xxx&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\widetilde{xxx}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\backslash</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\backslash$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>/<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $&#x2F;$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bracevert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bracevert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\smallsetminus</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\smallsetminus$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lbrace</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lbrace$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rbrace</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rbrace$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\arrowvert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\arrowvert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lVert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lVert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rVert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rVert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lgroup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lgroup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rgroup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rgroup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\langle</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\langle$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rangle</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rangle$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lvert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lvert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rvert</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rvert$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>[<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $[$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lmoustache</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lmoustache$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rmoustache</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rmoustache$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lceil</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lceil$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rceil</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rceil$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lfloor</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lfloor$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rfloor</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rfloor$</p><h2 id="公式中常见的箭头"><a href="#公式中常见的箭头" class="headerlink" title="公式中常见的箭头"></a>公式中常见的箭头</h2><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\uparrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果:  $\uparrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\downarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\downarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\longleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\longleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\longrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\longrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\longleftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\longleftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nwarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nwarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nearrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nearrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\swarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\swarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\searrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\searrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\upuparrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\upuparrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\downdownarrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\downdownarrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\updownarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\updownarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nleftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nleftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\upharpoonleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\upharpoonleft$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\upharpoonright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\upharpoonright$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\downharpoonleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\downharpoonleft$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\downharpoonright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\downharpoonright$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftharpoondown</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftharpoondown$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftharpoonup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftharpoonup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightharpoonup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightharpoonup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightharpoondown</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightharpoondown$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Uparrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Uparrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Downarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Downarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Leftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Leftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Rightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Rightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nLeftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nLeftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nRightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nRightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Leftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Leftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nLeftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nLeftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Updownarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Updownarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\mapsto</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\mapsto$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\nrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\nrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftleftarrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftleftarrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightrightarrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightrightarrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftrightarrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftrightarrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightleftarrows</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightleftarrows$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\hookleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\hookleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\hookrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\hookrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\curvearrowleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\curvearrowleft$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\curvearrowright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\curvearrowright$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\circlearrowleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\circlearrowleft$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\circlearrowright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\circlearrowright$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftrightharpoons</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftrightharpoons$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightleftharpoons</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightleftharpoons$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftrightharpoons</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftrightharpoons$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Longleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Longleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Longrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Longrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Longleftrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Longleftrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Lleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Lleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Rrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Rrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\looparrowleft</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\looparrowleft$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\looparrowright</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\looparrowright$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightsquigarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightsquigarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\longmapsto</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\longmapsto$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Lsh</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Lsh$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\Rsh</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\Rsh$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftarrowtail</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftarrowtail$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\rightarrowtail</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\rightarrowtail$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\multimap</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\multimap$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\twoheadleftarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\twoheadleftarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\twoheadrightarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\twoheadrightarrow$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\leftrightsquigarrow</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\leftrightsquigarrow$</p><h2 id="常见的数学公式"><a href="#常见的数学公式" class="headerlink" title="常见的数学公式"></a>常见的数学公式</h2><h3 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;ab&#125;&#123;cd&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\frac{ab}{cd}$</p><h3 id="开根号"><a href="#开根号" class="headerlink" title="开根号"></a>开根号</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sqrt</span>[x]&#123;y&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\sqrt[x]{y}$  </p><h3 id="对数-log"><a href="#对数-log" class="headerlink" title="对数-log"></a>对数-log</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\log</span><span class="built_in">_</span>&#123;a&#125;&#123;b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\log_{a}{b}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lg</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果:  $\lg{ab}$</p><h3 id="指数"><a href="#指数" class="headerlink" title="指数"></a>指数</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>&#123;ab&#125;<span class="built_in">^</span>&#123;cd&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: ${ab}^{cd}$</p><h3 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>&#123;a&#125;<span class="built_in">_</span>&#123;bc&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: ${a}_{bc}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>x<span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $x_a^b$</p><h3 id="连加"><a href="#连加" class="headerlink" title="连加"></a>连加</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\sum$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\sum_a^b$</p><h3 id="连乘"><a href="#连乘" class="headerlink" title="连乘"></a>连乘</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\prod$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\prod</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\prod_a^b$</p><h3 id="副积"><a href="#副积" class="headerlink" title="副积"></a>副积</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\coprod</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\coprod$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\coprod</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\coprod_a^b$</p><h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\int$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\int</span><span class="built_in">_</span>&#123;a&#125;<span class="built_in">^</span>&#123;b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\int_{a}^{b}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\oint</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\oint$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\oint</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\oint_a^b$</p><h3 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span>C<span class="built_in">_</span>n<span class="built_in">^</span>2<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $C_n^2$  </p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\sum</span> <span class="keyword">\frac</span>&#123;1&#125;&#123;i<span class="built_in">^</span>2&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\sum \frac{1}{i^2}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcap</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigcap$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcap</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigcap_a^b$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigcup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigcup</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigcup_a^b$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigsqcup</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigsqcup$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigsqcup</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigsqcup_a^b$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigvee</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigvee$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigvee</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigvee_a^b$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigwedge</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigwedge$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\bigwedge</span><span class="built_in">_</span>a<span class="built_in">^</span>b<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\bigwedge_a^b$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\widetilde</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\widetilde{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\widehat</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\widehat{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overleftarrow</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\overleftarrow{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overrightarrow</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\overrightarrow{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overbrace</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\overbrace{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\underbrace</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\underbrace{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\underline</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\underline{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\overline</span>&#123;ab&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\overline{ab}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> a&#125;&#123;<span class="keyword">\partial</span> b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\frac{\partial a}{\partial b}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\frac</span>&#123;<span class="keyword">\text</span>&#123;d&#125;x&#125;&#123;<span class="keyword">\text</span>&#123;d&#125;y&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\frac{\text{d}x}{\text{d}y}$</p><figure class="highlight latex"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="keyword">\lim</span><span class="built_in">_</span>&#123;a <span class="keyword">\rightarrow</span> b&#125;<span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>效果: $\lim_{a \rightarrow b}$</p><h2 id="复杂表达式"><a href="#复杂表达式" class="headerlink" title="复杂表达式"></a>复杂表达式</h2><p><strong>注意: 部分公式显示失败, 请自行安装对应插件</strong></p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>无括号版:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;matrix&#125;</span><br><span class="line">1&amp;0&amp;0\\</span><br><span class="line">0&amp;1&amp;0\\</span><br><span class="line">0&amp;0&amp;1\\</span><br><span class="line">\end&#123;matrix&#125;$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\begin{matrix}<br>1&amp;0&amp;0\<br>0&amp;1&amp;0\<br>0&amp;0&amp;1\<br>\end{matrix}$$</p><p>中括号版:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;bmatrix&#125;</span><br><span class="line">&#123;a_&#123;11&#125;&#125;&amp;&#123;a_&#123;12&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;1n&#125;&#125;\\</span><br><span class="line">&#123;a_&#123;21&#125;&#125;&amp;&#123;a_&#123;22&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;2n&#125;&#125;\\</span><br><span class="line">&#123;\vdots&#125;&amp;&#123;\vdots&#125;&amp;&#123;\ddots&#125;&amp;&#123;\vdots&#125;\\</span><br><span class="line">&#123;a_&#123;m1&#125;&#125;&amp;&#123;a_&#123;m2&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;mn&#125;&#125;\\</span><br><span class="line">\end&#123;bmatrix&#125;$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\begin{bmatrix}<br>{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\<br>{a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\<br>{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\<br>{a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\<br>\end{bmatrix}$$</p><p>小括号版:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;pmatrix&#125;</span><br><span class="line">&#123;a_&#123;11&#125;&#125;&amp;&#123;a_&#123;12&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;1n&#125;&#125;\\</span><br><span class="line">&#123;a_&#123;21&#125;&#125;&amp;&#123;a_&#123;22&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;2n&#125;&#125;\\</span><br><span class="line">&#123;\vdots&#125;&amp;&#123;\vdots&#125;&amp;&#123;\ddots&#125;&amp;&#123;\vdots&#125;\\</span><br><span class="line">&#123;a_&#123;m1&#125;&#125;&amp;&#123;a_&#123;m2&#125;&#125;&amp;&#123;\cdots&#125;&amp;&#123;a_&#123;mn&#125;&#125;\\</span><br><span class="line">\end&#123;pmatrix&#125;$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\begin{pmatrix}<br>{a_{11}}&amp;{a_{12}}&amp;{\cdots}&amp;{a_{1n}}\<br>{a_{21}}&amp;{a_{22}}&amp;{\cdots}&amp;{a_{2n}}\<br>{\vdots}&amp;{\vdots}&amp;{\ddots}&amp;{\vdots}\<br>{a_{m1}}&amp;{a_{m2}}&amp;{\cdots}&amp;{a_{mn}}\<br>\end{pmatrix}$$</p><h3 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;cases&#125;</span><br><span class="line">a_1x+b_1y+c_1z=d_1\\</span><br><span class="line">a_2x+b_2y+c_2z=d_2\\</span><br><span class="line">a_3x+b_3y+c_3z=d_3\\</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\begin{cases}<br>a_1x+b_1y+c_1z&#x3D;d_1\<br>a_2x+b_2y+c_2z&#x3D;d_2\<br>a_3x+b_3y+c_3z&#x3D;d_3\<br>\end{cases}<br>$$<br>有条件版:</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$Sum=\begin&#123;cases&#125; L == 0 &amp; H[R]\\</span><br><span class="line">L != 0 &amp; H[R] = H[L-1]\end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$Sum&#x3D;\begin{cases} L &#x3D;&#x3D; 0 &amp; H[R]\<br>L !&#x3D; 0 &amp; H[R] &#x3D; H[L-1]\end{cases}$$  </p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;cases&#125;a &amp; x = 0\\ </span><br><span class="line">b &amp; x &gt; 0</span><br><span class="line">\end&#123;cases&#125;$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\begin{cases}a &amp; x &#x3D; 0\<br>b &amp; x &gt; 0<br>\end{cases}$$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;希腊字母表&quot;&gt;&lt;a href=&quot;#希腊字母表&quot; class=&quot;headerlink&quot; title=&quot;希腊字母表&quot;&gt;&lt;/a&gt;希腊字母表&lt;/h2&gt;&lt;figure class=&quot;highlight latex&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Markdown" scheme="http://fu-jw.com/tags/Markdown/"/>
    
    <category term="LaTex" scheme="http://fu-jw.com/tags/LaTex/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 常用语法</title>
    <link href="http://fu-jw.com/posts/e317821c.html"/>
    <id>http://fu-jw.com/posts/e317821c.html</id>
    <published>2022-12-30T00:00:00.000Z</published>
    <updated>2023-07-07T13:51:57.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h2><h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$\mathbf&#123;你好啊&#125;$</span><br></pre></td></tr></table></figure><p>普通: 你好啊<br>效果: $\mathbf{你好啊}$</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">**你好啊**</span><br></pre></td></tr></table></figure><p>效果: <strong>你好啊</strong></p><h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$\mathit&#123;世界&#125;$</span><br></pre></td></tr></table></figure><p>效果: $\mathit{世界}$</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">*世界*</span><br></pre></td></tr></table></figure><p>效果: <em>世界</em></p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$\tiny 你好(tiny)$</span><br><span class="line"></span><br><span class="line">$\scriptsize 你好(scriptsize)$</span><br><span class="line"></span><br><span class="line">$\small 你好(small)$</span><br><span class="line"></span><br><span class="line">$\normalsize 你好(normalsize)$</span><br><span class="line"></span><br><span class="line">$\large 你好(large)$</span><br><span class="line"></span><br><span class="line">$\Large 你好(Large)$</span><br><span class="line"></span><br><span class="line">$\huge 你好(huge)$</span><br><span class="line"></span><br><span class="line">$\Huge 你好(Huge)$</span><br></pre></td></tr></table></figure><p>效果:<br>$\tiny 你好(tiny)$</p><p>$\scriptsize 你好(scriptsize)$</p><p>$\small 你好(small)$</p><p>$\normalsize 你好(normalsize)$</p><p>$\large 你好(large)$</p><p>$\Large 你好(Large)$</p><p>$\huge 你好(huge)$</p><p>$\Huge 你好(Huge)$</p><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$\color&#123;Red&#125;&#123;红色&#125;$, $\color&#123;blue&#125;&#123;蓝色&#125;$,  $\color&#123;orange&#125;&#123;橘色&#125;$,  </span><br><span class="line">$\color&#123;Green&#125;&#123;绿色&#125;$,  $\color&#123;gray&#125;&#123;灰色&#125;$,  $\color&#123;purple&#125;&#123;紫色&#125;$.</span><br></pre></td></tr></table></figure><p>效果:<br>$\color{Red}{红色}$, $\color{blue}{蓝色}$,  $\color{orange}{橘色}$,<br>$\color{Green}{绿色}$,  $\color{gray}{灰色}$,  $\color{purple}{紫色}$.</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><h4 id="两个及以上空格-回车"><a href="#两个及以上空格-回车" class="headerlink" title="两个及以上空格 + 回车"></a>两个及以上空格 + 回车</h4><p>第一行<br>第二行</p><h4 id="html-标签-lt-x2F-br-gt"><a href="#html-标签-lt-x2F-br-gt" class="headerlink" title="html 标签 &lt;&#x2F;br&gt;"></a>html 标签 &lt;&#x2F;br&gt;</h4><p>第一行</br>第二行</p><h3 id="横线"><a href="#横线" class="headerlink" title="横线"></a>横线</h3><h4 id="上横线"><a href="#上横线" class="headerlink" title="上横线"></a>上横线</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$\overline&#123;\text&#123;上划线&#125;&#125;$</span><br></pre></td></tr></table></figure><p>效果:  $\overline{\text{上划线}}$</p><h4 id="中横线"><a href="#中横线" class="headerlink" title="中横线"></a>中横线</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">~~中划线~~</span><br></pre></td></tr></table></figure><p>效果: <del>中划线</del></p><h4 id="下横线"><a href="#下横线" class="headerlink" title="下横线"></a>下横线</h4><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">$\underline&#123;\text&#123;下划线1&#125;&#125;$</span><br><span class="line"></span><br><span class="line">&lt;u&gt;下划线2&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>效果: $\underline{\text{下划线1}}$    <u>下划线 2</u></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://www.baidu.com/">百度一下</a></p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;div STYLE=&quot;page-break-after: always;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><div STYLE="page-break-after: always;"></div>  <p>将这个插入到你要分页的地方</p><h3 id="折叠内容"><a href="#折叠内容" class="headerlink" title="折叠内容"></a>折叠内容</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;details&gt; &lt;summary&gt;Title&lt;/summary&gt;</span><br><span class="line">contents ...</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><details><summary>Title</summary>contents ...</details><h2 id="内嵌"><a href="#内嵌" class="headerlink" title="内嵌"></a>内嵌</h2><p><a href="https://publish.obsidian.md/help/How+to/Embed+files">https://publish.obsidian.md/help/How+to/Embed+files</a></p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">![[My File.pdf#page=number]]</span><br></pre></td></tr></table></figure><h3 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">![网络图片](https://s2.loli.net/2023/06/11/MVbHQs1Eui6fAzo.webp)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/06/11/MVbHQs1Eui6fAzo.webp" alt="网络图片"></p><h3 id="网络视频"><a href="#网络视频" class="headerlink" title="网络视频"></a>网络视频</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;https://player.bilibili.com/player.html?aid=586848024&amp;bvid=BV1Kz4y1m74W&amp;cid=300166684&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; height=300 width=400&gt; </span><br><span class="line">&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><iframe src=" https://player.bilibili.com/player.html?aid=586848024&bvid=BV1Kz4y1m74W&cid=300166684&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" height=300 width=400></iframe><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;文本相关&quot;&gt;&lt;a href=&quot;#文本相关&quot; class=&quot;headerlink&quot; title=&quot;文本相关&quot;&gt;&lt;/a&gt;文本相关&lt;/h2&gt;&lt;h3 id=&quot;加粗&quot;&gt;&lt;a href=&quot;#加粗&quot; class=&quot;headerlink&quot; title=&quot;加粗&quot;&gt;&lt;/a&gt;加粗&lt;/h</summary>
      
    
    
    
    <category term="学习" scheme="http://fu-jw.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Markdown" scheme="http://fu-jw.com/tags/Markdown/"/>
    
  </entry>
  
</feed>
